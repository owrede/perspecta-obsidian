/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PerspectaPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/changelog.ts
var CHANGELOG = [
  {
    version: "0.1.11",
    date: "2025-12-06",
    changes: [
      "Proxy windows now show image thumbnails for image files",
      "Proxy windows show file type icon for PDFs and other binary files",
      "Fixed broken display when converting image/PDF windows to proxy"
    ]
  },
  {
    version: "0.1.10",
    date: "2025-12-06",
    changes: [
      "Hide perspecta-uid property from Properties view (still visible in source mode)"
    ]
  },
  {
    version: "0.1.9",
    date: "2025-12-06",
    changes: [
      "Removed excess padding from proxy window preview content",
      "Fixed bottom margin in proxy windows"
    ]
  },
  {
    version: "0.1.8",
    date: "2025-12-06",
    changes: [
      "Unified changelog system - single source of truth for all changelogs",
      "Added CHANGELOG.md file auto-generated from changelog data",
      "Reorganized README features to match settings pane structure",
      "Added Convert to proxy window command documentation",
      "Added backup reminder to external storage warning"
    ]
  },
  {
    version: "0.1.7",
    date: "2025-12-06",
    changes: [
      "Proxy windows now show scaled markdown preview of note content",
      "Draggable title bar - drag header to move proxy window",
      "Scrollable content - use mouse wheel or arrow keys to scroll preview",
      "Keyboard navigation: \u2191/\u2193, j/k, Page Up/Down, Home/End, Enter/Space",
      "Configurable preview scale factor in Experimental settings (default 35%)",
      "Canvas viewport and zoom level now saved and restored",
      "Context indicator (target icon) now appears correctly in popout windows",
      "Fixed duplicate proxy windows when restoring contexts",
      "Fixed concurrent restore guard to prevent window duplication"
    ]
  },
  {
    version: "0.1.6",
    date: "2025-12-05",
    changes: [
      "Experimental: Proxy windows - minimalist window showing only note title",
      "Click proxy to restore latest arrangement, Shift+click for selector",
      "Click proxy without arrangement to expand to full window",
      "Proxy window positions and sizes saved/restored with arrangements",
      "Added Experimental settings tab to enable/disable proxy windows",
      "Fixed notifications not auto-dismissing (4 second timeout)",
      "Notifications and focus tints no longer appear in proxy windows"
    ]
  },
  {
    version: "0.1.3",
    date: "2025-12-04",
    changes: [
      "Multi-arrangement storage: store up to 5 arrangements per note",
      "Arrangement selector modal with visual SVG previews",
      "Delete button to remove specific arrangements from history",
      "Confirmation dialog when overwriting single arrangement",
      "Backup & restore functionality to perspecta folder",
      "SVG previews show windows, splits, sidebars, and focus highlight",
      "Instant tooltips on SVG areas showing note names",
      'Renamed "Focus tint duration" setting for clarity',
      "Fixed notification toast not disappearing"
    ]
  },
  {
    version: "0.1.2",
    changes: [
      "Improved plugin compliance with Obsidian guidelines"
    ]
  },
  {
    version: "0.1.1",
    changes: [
      "Save and restore scroll position for all tabs",
      "Save and restore split sizes (pane proportions)"
    ]
  },
  {
    version: "0.1.0",
    changes: [
      "Initial release",
      "Save and restore window arrangements (tabs, splits, popouts)",
      "External storage mode for cleaner notes",
      "Frontmatter storage mode for portability",
      "Auto-generate UIDs for file tracking",
      "Context indicators in file explorer",
      "Focus tint animation on restore"
    ]
  }
];
function renderChangelogToContainer(containerEl) {
  containerEl.createEl("h2", { text: "Changelog" });
  for (const entry of CHANGELOG) {
    const versionDiv = containerEl.createDiv({ cls: "perspecta-changelog-version" });
    versionDiv.createEl("h3", { text: `v${entry.version}` });
    const list = versionDiv.createEl("ul");
    for (const change of entry.changes) {
      list.createEl("li", { text: change });
    }
  }
}

// src/types.ts
var DEFAULT_SETTINGS = {
  enableVisualMapping: true,
  enableAutomation: true,
  automationScriptsPath: "perspecta/scripts/",
  perspectaFolderPath: "perspecta",
  showDebugModal: true,
  enableDebugLogging: false,
  focusTintDuration: 8,
  autoGenerateUids: true,
  storageMode: "frontmatter",
  maxArrangementsPerNote: 1,
  autoConfirmOverwrite: false,
  // Experimental features
  enableProxyWindows: false,
  proxyPreviewScale: 0.35
};
var FRONTMATTER_KEY = "perspecta-arrangement";
var UID_FRONTMATTER_KEY = "perspecta-uid";

// src/utils/perf-timer.ts
var PerfTimer = class {
  static begin(operation) {
    if (!this.enabled)
      return;
    this.times = [];
    this.start = performance.now();
    this.lastMark = this.start;
    this.currentOperation = operation;
    console.log(`[Perspecta] \u25B6 ${operation} started at ${this.start.toFixed(0)}`);
  }
  static mark(label) {
    if (!this.enabled)
      return;
    const now = performance.now();
    const elapsed = now - this.lastMark;
    const fromStart = now - this.start;
    this.times.push({ label, elapsed, fromStart });
    this.lastMark = now;
    const flag = elapsed > 50 ? "\u26A0 SLOW" : "\u2713";
    console.log(`[Perspecta]   ${flag} ${label}: ${elapsed.toFixed(1)}ms (total: ${fromStart.toFixed(1)}ms)`);
  }
  static end(operation) {
    if (!this.enabled)
      return;
    const total = performance.now() - this.start;
    console.log(`[Perspecta] \u25FC ${operation} completed in ${total.toFixed(1)}ms`);
    if (this.times.length > 0) {
      console.log("[Perspecta] Full breakdown:");
      for (const t of this.times) {
        const flag = t.elapsed > 50 ? "\u26A0" : "\u2713";
        console.log(`  ${flag} ${t.label}: ${t.elapsed.toFixed(1)}ms (at ${t.fromStart.toFixed(1)}ms)`);
      }
    }
  }
  static async timeAsync(label, fn) {
    if (!this.enabled)
      return fn();
    const start = performance.now();
    try {
      return await fn();
    } finally {
      const elapsed = performance.now() - start;
      const fromStart = performance.now() - this.start;
      this.times.push({ label, elapsed, fromStart });
      const flag = elapsed > 50 ? "\u26A0 SLOW" : "\u2713";
      console.log(`[Perspecta]   ${flag} ${label}: ${elapsed.toFixed(1)}ms (total: ${fromStart.toFixed(1)}ms)`);
    }
  }
  static setEnabled(enabled) {
    this.enabled = enabled;
  }
  static isEnabled() {
    return this.enabled;
  }
};
PerfTimer.enabled = false;
PerfTimer.times = [];
PerfTimer.start = 0;
PerfTimer.lastMark = 0;
PerfTimer.currentOperation = "";

// src/utils/coordinates.ts
var VIRTUAL_SCREEN = {
  width: 1728,
  height: 1117
};
var coordinateDebug = false;
function getPhysicalScreen() {
  var _a, _b;
  return {
    width: window.screen.availWidth,
    height: window.screen.availHeight,
    x: (_a = window.screen.availLeft) != null ? _a : 0,
    y: (_b = window.screen.availTop) != null ? _b : 0
  };
}
function physicalToVirtual(physical) {
  const screen = getPhysicalScreen();
  const scaleX = VIRTUAL_SCREEN.width / screen.width;
  const scaleY = VIRTUAL_SCREEN.height / screen.height;
  const result = {
    x: Math.round((physical.x - screen.x) * scaleX),
    y: Math.round((physical.y - screen.y) * scaleY),
    width: Math.round(physical.width * scaleX),
    height: Math.round(physical.height * scaleY)
  };
  if (coordinateDebug) {
    console.log(`[Perspecta] physicalToVirtual:`, {
      physical,
      screen,
      virtualRef: VIRTUAL_SCREEN,
      scale: { x: scaleX.toFixed(3), y: scaleY.toFixed(3) },
      result
    });
  }
  return result;
}
function virtualToPhysical(virtual, sourceScreen) {
  const screen = getPhysicalScreen();
  const scaleX = screen.width / VIRTUAL_SCREEN.width;
  const scaleY = screen.height / VIRTUAL_SCREEN.height;
  let x = Math.round(virtual.x * scaleX) + screen.x;
  let y = Math.round(virtual.y * scaleY) + screen.y;
  let width = Math.round(virtual.width * scaleX);
  let height = Math.round(virtual.height * scaleY);
  width = Math.min(width, screen.width);
  height = Math.min(height, screen.height);
  x = Math.max(screen.x, Math.min(x, screen.x + screen.width - width));
  y = Math.max(screen.y, Math.min(y, screen.y + screen.height - height));
  const result = { x, y, width, height };
  if (coordinateDebug) {
    console.log(`[Perspecta] virtualToPhysical:`, {
      virtual,
      screen,
      virtualRef: VIRTUAL_SCREEN,
      sourceScreen,
      scale: { x: scaleX.toFixed(3), y: scaleY.toFixed(3) },
      result
    });
  }
  return result;
}
function getAspectRatioDifference(sourceScreen) {
  if (!sourceScreen)
    return 0;
  const targetScreen = getPhysicalScreen();
  const targetAspectRatio = targetScreen.width / targetScreen.height;
  return Math.abs(sourceScreen.aspectRatio - targetAspectRatio);
}
function needsTiling(sourceScreen) {
  if (!sourceScreen)
    return false;
  const diff = getAspectRatioDifference(sourceScreen);
  return diff > 0.5;
}
function calculateTiledLayout(windowCount, mainWindowState) {
  const screen = getPhysicalScreen();
  const results = [];
  if (windowCount === 0)
    return results;
  if (windowCount === 1) {
    results.push({
      x: screen.x,
      y: screen.y,
      width: screen.width,
      height: screen.height
    });
    return results;
  }
  if (windowCount === 2) {
    const halfWidth = Math.floor(screen.width / 2);
    results.push({
      x: screen.x,
      y: screen.y,
      width: halfWidth,
      height: screen.height
    });
    results.push({
      x: screen.x + halfWidth,
      y: screen.y,
      width: screen.width - halfWidth,
      height: screen.height
    });
    return results;
  }
  const mainWidth = Math.floor(screen.width / 2);
  results.push({
    x: screen.x,
    y: screen.y,
    width: mainWidth,
    height: screen.height
  });
  const popoutCount = windowCount - 1;
  const popoutWidth = screen.width - mainWidth;
  const popoutHeight = Math.floor(screen.height / popoutCount);
  for (let i = 0; i < popoutCount; i++) {
    const isLast = i === popoutCount - 1;
    results.push({
      x: screen.x + mainWidth,
      y: screen.y + i * popoutHeight,
      width: popoutWidth,
      height: isLast ? screen.height - i * popoutHeight : popoutHeight
    });
  }
  return results;
}

// src/utils/uid.ts
function generateUid() {
  if (typeof crypto !== "undefined" && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
function getUidFromCache(app, file) {
  var _a;
  const cache = app.metadataCache.getFileCache(file);
  return (_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a[UID_FRONTMATTER_KEY];
}
async function addUidToFile(app, file, uid) {
  const content = await app.vault.read(file);
  const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
  const match = content.match(frontmatterRegex);
  let newContent;
  if (match) {
    let fm = match[1];
    if (fm.includes(`${UID_FRONTMATTER_KEY}:`)) {
      if (fm.match(/^uid:\s*["']?[^"'\n]+["']?\s*$/m)) {
        fm = fm.replace(/^uid:\s*["']?[^"'\n]+["']?\n?/gm, "").trim();
        newContent = content.replace(frontmatterRegex, `---
${fm}
---`);
        await app.vault.modify(file, newContent);
      }
      return;
    }
    fm = fm.replace(/^uid:\s*["']?[^"'\n]+["']?\n?/gm, "").trim();
    const newFm = `${UID_FRONTMATTER_KEY}: "${uid}"
${fm}`;
    newContent = content.replace(frontmatterRegex, `---
${newFm}
---`);
  } else {
    newContent = `---
${UID_FRONTMATTER_KEY}: "${uid}"
---
${content}`;
  }
  await app.vault.modify(file, newContent);
}
async function cleanupOldUid(app, file) {
  const content = await app.vault.read(file);
  const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
  const match = content.match(frontmatterRegex);
  if (!match)
    return false;
  const fm = match[1];
  if (!fm.includes(`${UID_FRONTMATTER_KEY}:`))
    return false;
  if (!fm.match(/^uid:\s*["']?[^"'\n]+["']?\s*$/m))
    return false;
  const newFm = fm.replace(/^uid:\s*["']?[^"'\n]+["']?\n?/gm, "").trim();
  const newContent = content.replace(frontmatterRegex, `---
${newFm}
---`);
  if (newContent !== content) {
    await app.vault.modify(file, newContent);
    return true;
  }
  return false;
}

// src/storage/markdown.ts
function markdownHasContext(app, file) {
  var _a;
  if (file.extension !== "md")
    return false;
  const cache = app.metadataCache.getFileCache(file);
  return ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a[FRONTMATTER_KEY]) != null;
}

// src/storage/canvas.ts
async function getUidFromCanvas(app, file) {
  var _a;
  if (file.extension !== "canvas")
    return void 0;
  try {
    const content = await app.vault.read(file);
    const data = JSON.parse(content);
    return (_a = data.perspecta) == null ? void 0 : _a.uid;
  } catch (e) {
    return void 0;
  }
}
async function getContextFromCanvas(app, file) {
  var _a, _b;
  if (file.extension !== "canvas")
    return null;
  try {
    const content = await app.vault.read(file);
    const data = JSON.parse(content);
    return (_b = (_a = data.perspecta) == null ? void 0 : _a.context) != null ? _b : null;
  } catch (e) {
    return null;
  }
}
async function saveContextToCanvas(app, file, context) {
  if (file.extension !== "canvas")
    return;
  try {
    const content = await app.vault.read(file);
    const data = JSON.parse(content);
    if (!data.perspecta) {
      data.perspecta = {};
    }
    data.perspecta.context = context;
    await app.vault.modify(file, JSON.stringify(data, null, "	"));
  } catch (e) {
    console.error("[Perspecta] Failed to save context to canvas:", e);
    throw e;
  }
}
async function canvasHasContext(app, file) {
  var _a;
  if (file.extension !== "canvas")
    return false;
  try {
    const content = await app.vault.read(file);
    const data = JSON.parse(content);
    return !!((_a = data.perspecta) == null ? void 0 : _a.context);
  } catch (e) {
    return false;
  }
}

// src/storage/base.ts
var import_obsidian = require("obsidian");
async function getUidFromBase(app, file) {
  var _a;
  if (file.extension !== "base")
    return void 0;
  try {
    const content = await app.vault.read(file);
    const data = (0, import_obsidian.parseYaml)(content);
    return (_a = data == null ? void 0 : data.perspecta) == null ? void 0 : _a.uid;
  } catch (e) {
    return void 0;
  }
}
async function getContextFromBase(app, file) {
  var _a;
  if (file.extension !== "base")
    return null;
  try {
    const content = await app.vault.read(file);
    const data = (0, import_obsidian.parseYaml)(content);
    const encoded = (_a = data == null ? void 0 : data.perspecta) == null ? void 0 : _a.context;
    if (!encoded)
      return null;
    const json = decodeURIComponent(escape(atob(encoded)));
    return JSON.parse(json);
  } catch (e) {
    return null;
  }
}
async function saveContextToBase(app, file, context) {
  if (file.extension !== "base")
    return;
  try {
    const content = await app.vault.read(file);
    const data = content.trim() ? (0, import_obsidian.parseYaml)(content) : {};
    if (!data.perspecta) {
      data.perspecta = {};
    }
    const json = JSON.stringify(context);
    const base64 = btoa(unescape(encodeURIComponent(json)));
    data.perspecta.context = base64;
    await app.vault.modify(file, (0, import_obsidian.stringifyYaml)(data));
  } catch (e) {
    console.error("[Perspecta] Failed to save context to base file:", e);
    throw e;
  }
}
async function baseHasContext(app, file) {
  var _a;
  if (file.extension !== "base")
    return false;
  try {
    const content = await app.vault.read(file);
    const data = (0, import_obsidian.parseYaml)(content);
    return !!((_a = data == null ? void 0 : data.perspecta) == null ? void 0 : _a.context);
  } catch (e) {
    return false;
  }
}

// src/storage/external-store.ts
var CONTEXTS_FOLDER = "contexts";
function isArrangementCollection(data) {
  return typeof data === "object" && data !== null && "arrangements" in data && Array.isArray(data.arrangements);
}
var ExternalContextStore = class {
  constructor(config) {
    this.cache = /* @__PURE__ */ new Map();
    this.dirty = /* @__PURE__ */ new Set();
    this.saveTimeout = null;
    this.initialized = false;
    this.app = config.app;
    this.manifest = config.manifest;
  }
  get adapter() {
    return this.app.vault.adapter;
  }
  getContextsPath() {
    return `${this.manifest.dir}/${CONTEXTS_FOLDER}`;
  }
  async initialize() {
    var _a;
    if (this.initialized)
      return;
    const contextsPath = this.getContextsPath();
    try {
      if (!await this.adapter.exists(contextsPath)) {
        await this.adapter.mkdir(contextsPath);
      }
      const files = await this.adapter.list(contextsPath);
      for (const file of files.files) {
        if (file.endsWith(".json")) {
          try {
            const content = await this.adapter.read(file);
            const data = JSON.parse(content);
            const uid = (_a = file.split("/").pop()) == null ? void 0 : _a.replace(".json", "");
            if (uid && data) {
              if (isArrangementCollection(data)) {
                this.cache.set(uid, data);
              } else {
                const arrangement = data;
                const collection = {
                  arrangements: [{
                    arrangement,
                    savedAt: arrangement.ts || Date.now()
                  }]
                };
                this.cache.set(uid, collection);
                this.dirty.add(uid);
              }
            }
          } catch (e) {
            console.warn(`[Perspecta] Failed to load context file: ${file}`, e);
          }
        }
      }
      this.initialized = true;
      if (PerfTimer.isEnabled()) {
        console.log(`[Perspecta] External store initialized with ${this.cache.size} contexts`);
      }
    } catch (e) {
      console.error("[Perspecta] Failed to initialize external store:", e);
    }
  }
  // Get the most recent arrangement (for backward compatibility)
  get(uid) {
    const collection = this.cache.get(uid);
    if (!collection || collection.arrangements.length === 0)
      return null;
    return collection.arrangements[collection.arrangements.length - 1].arrangement;
  }
  // Get all arrangements for a UID
  getAll(uid) {
    const collection = this.cache.get(uid);
    if (!collection)
      return [];
    return [...collection.arrangements].sort((a, b) => b.savedAt - a.savedAt);
  }
  // Get arrangement count for a UID
  getCount(uid) {
    var _a;
    const collection = this.cache.get(uid);
    return (_a = collection == null ? void 0 : collection.arrangements.length) != null ? _a : 0;
  }
  has(uid) {
    const collection = this.cache.get(uid);
    return collection !== void 0 && collection.arrangements.length > 0;
  }
  // Add a new arrangement, respecting the max limit
  set(uid, context, maxArrangements = 1) {
    let collection = this.cache.get(uid);
    if (!collection) {
      collection = { arrangements: [] };
    }
    const timestamped = {
      arrangement: context,
      savedAt: Date.now()
    };
    collection.arrangements.push(timestamped);
    collection.arrangements.sort((a, b) => a.savedAt - b.savedAt);
    while (collection.arrangements.length > maxArrangements) {
      collection.arrangements.shift();
    }
    this.cache.set(uid, collection);
    this.dirty.add(uid);
    this.scheduleSave();
  }
  // Delete a specific arrangement by timestamp
  deleteArrangement(uid, savedAt) {
    const collection = this.cache.get(uid);
    if (!collection)
      return;
    collection.arrangements = collection.arrangements.filter((a) => a.savedAt !== savedAt);
    if (collection.arrangements.length === 0) {
      this.cache.delete(uid);
    } else {
      this.cache.set(uid, collection);
    }
    this.dirty.add(uid);
    this.scheduleSave();
  }
  async delete(uid) {
    this.cache.delete(uid);
    this.dirty.delete(uid);
    const filePath = `${this.getContextsPath()}/${uid}.json`;
    try {
      if (await this.adapter.exists(filePath)) {
        await this.adapter.remove(filePath);
      }
    } catch (e) {
      console.warn(`[Perspecta] Failed to delete context file: ${filePath}`, e);
    }
  }
  getAllUids() {
    return Array.from(this.cache.keys());
  }
  scheduleSave() {
    if (this.saveTimeout) {
      clearTimeout(this.saveTimeout);
    }
    this.saveTimeout = setTimeout(() => this.flushDirty(), 2e3);
  }
  async flushDirty() {
    if (this.dirty.size === 0)
      return;
    const contextsPath = this.getContextsPath();
    if (!await this.adapter.exists(contextsPath)) {
      await this.adapter.mkdir(contextsPath);
    }
    const toSave = Array.from(this.dirty);
    this.dirty.clear();
    for (const uid of toSave) {
      const collection = this.cache.get(uid);
      const filePath = `${contextsPath}/${uid}.json`;
      if (collection && collection.arrangements.length > 0) {
        try {
          const json = JSON.stringify(collection);
          await this.adapter.write(filePath, json);
        } catch (e) {
          console.error(`[Perspecta] Failed to save context: ${uid}`, e);
          this.dirty.add(uid);
        }
      } else {
        try {
          if (await this.adapter.exists(filePath)) {
            await this.adapter.remove(filePath);
          }
        } catch (e) {
          console.warn(`[Perspecta] Failed to delete empty context file: ${filePath}`, e);
        }
      }
    }
    if (PerfTimer.isEnabled()) {
      console.log(`[Perspecta] Saved ${toSave.length} context(s) to disk`);
    }
  }
  async cleanup() {
    if (this.saveTimeout) {
      clearTimeout(this.saveTimeout);
    }
    await this.flushDirty();
  }
};

// src/ui/modals.ts
var SVG_NS = "http://www.w3.org/2000/svg";
function generateArrangementPreview(arrangement, width, height) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  const arr = arrangement.arrangement;
  const svg = document.createElementNS(SVG_NS, "svg");
  svg.setAttribute("width", String(width));
  svg.setAttribute("height", String(height));
  svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
  svg.classList.add("perspecta-arrangement-preview");
  const padding = 2;
  const cornerRadius = 2;
  const screenWidth = (_b = (_a = arr.sourceScreen) == null ? void 0 : _a.width) != null ? _b : 1920;
  const screenHeight = (_d = (_c = arr.sourceScreen) == null ? void 0 : _c.height) != null ? _d : 1080;
  const availableWidth = width - padding * 2;
  const availableHeight = height - padding * 2;
  const scale = Math.min(availableWidth / screenWidth, availableHeight / screenHeight);
  const scaledScreenWidth = screenWidth * scale;
  const scaledScreenHeight = screenHeight * scale;
  const screenX = padding + (availableWidth - scaledScreenWidth) / 2;
  const screenY = padding + (availableHeight - scaledScreenHeight) / 2;
  const screenRect = createRect({
    x: screenX,
    y: screenY,
    width: scaledScreenWidth,
    height: scaledScreenHeight
  }, "var(--background-modifier-border)", "none", cornerRadius);
  svg.appendChild(screenRect);
  const windows = [];
  if (arr.main) {
    windows.push({ state: arr.main, isMain: true });
  }
  if (arr.popouts) {
    arr.popouts.forEach((p) => windows.push({ state: p, isMain: false }));
  }
  windows.forEach(({ state, isMain }) => {
    var _a2, _b2, _c2, _d2;
    const x = (_a2 = state.x) != null ? _a2 : 0;
    const y = (_b2 = state.y) != null ? _b2 : 0;
    const w = (_c2 = state.width) != null ? _c2 : 800;
    const h = (_d2 = state.height) != null ? _d2 : 600;
    const winRect = {
      x: screenX + x * scale,
      y: screenY + y * scale,
      width: w * scale,
      height: h * scale
    };
    const windowEl = createRect(
      winRect,
      "var(--background-primary)",
      "var(--background-primary-alt)",
      cornerRadius
    );
    windowEl.setAttribute("stroke-width", "1");
    svg.appendChild(windowEl);
    if (isMain) {
      const sidebarWidth = Math.max(5, winRect.width * 0.18);
      const sidebarPadding = 2;
      if (arr.leftSidebar && !arr.leftSidebar.collapsed) {
        const leftSidebar = createRect({
          x: winRect.x + sidebarPadding,
          y: winRect.y + sidebarPadding,
          width: sidebarWidth,
          height: winRect.height - sidebarPadding * 2
        }, "var(--background-modifier-border)", "none", 1);
        svg.appendChild(leftSidebar);
      }
      if (arr.rightSidebar && !arr.rightSidebar.collapsed) {
        const rightSidebar = createRect({
          x: winRect.x + winRect.width - sidebarWidth - sidebarPadding,
          y: winRect.y + sidebarPadding,
          width: sidebarWidth,
          height: winRect.height - sidebarPadding * 2
        }, "var(--background-modifier-border)", "none", 1);
        svg.appendChild(rightSidebar);
      }
    }
    if (state.root) {
      drawSplitLines(svg, state.root, winRect);
      drawTabAreas(svg, state.root, winRect);
    }
  });
  const focusedWindowIndex = (_e = arr.focusedWindow) != null ? _e : -1;
  let focusedState = null;
  if (focusedWindowIndex === -1 && arr.main) {
    focusedState = arr.main;
  } else if (focusedWindowIndex >= 0 && arr.popouts && arr.popouts[focusedWindowIndex]) {
    focusedState = arr.popouts[focusedWindowIndex];
  }
  if (focusedState == null ? void 0 : focusedState.root) {
    const x = (_f = focusedState.x) != null ? _f : 0;
    const y = (_g = focusedState.y) != null ? _g : 0;
    const w = (_h = focusedState.width) != null ? _h : 800;
    const h = (_i = focusedState.height) != null ? _i : 600;
    const winRect = {
      x: screenX + x * scale,
      y: screenY + y * scale,
      width: w * scale,
      height: h * scale
    };
    drawFocusHighlight(svg, focusedState.root, winRect, cornerRadius);
  }
  return svg;
}
function drawSplitLines(svg, node, bounds) {
  if (!node || node.type !== "split")
    return;
  const children = node.children || [];
  if (children.length < 2)
    return;
  const sizes = node.sizes || children.map(() => 1 / children.length);
  const direction = node.direction;
  const totalSize = sizes.reduce((a, b) => a + b, 0);
  const normalizedSizes = sizes.map((s) => s / totalSize);
  let offset = 0;
  children.forEach((child, i) => {
    const size = normalizedSizes[i] || 1 / children.length;
    if (i > 0) {
      const line = document.createElementNS(SVG_NS, "line");
      if (direction === "vertical") {
        const lineX = bounds.x + offset * bounds.width;
        line.setAttribute("x1", String(lineX));
        line.setAttribute("y1", String(bounds.y + 2));
        line.setAttribute("x2", String(lineX));
        line.setAttribute("y2", String(bounds.y + bounds.height - 2));
      } else {
        const lineY = bounds.y + offset * bounds.height;
        line.setAttribute("x1", String(bounds.x + 2));
        line.setAttribute("y1", String(lineY));
        line.setAttribute("x2", String(bounds.x + bounds.width - 2));
        line.setAttribute("y2", String(lineY));
      }
      line.setAttribute("stroke", "var(--text-muted)");
      line.setAttribute("stroke-width", "1");
      line.setAttribute("stroke-dasharray", "2,2");
      line.setAttribute("opacity", "0.6");
      svg.appendChild(line);
    }
    let childBounds;
    if (direction === "vertical") {
      childBounds = {
        x: bounds.x + offset * bounds.width,
        y: bounds.y,
        width: size * bounds.width,
        height: bounds.height
      };
    } else {
      childBounds = {
        x: bounds.x,
        y: bounds.y + offset * bounds.height,
        width: bounds.width,
        height: size * bounds.height
      };
    }
    drawSplitLines(svg, child, childBounds);
    offset += size;
  });
}
function drawFocusHighlight(svg, node, bounds, cornerRadius) {
  var _a;
  if (!node)
    return false;
  if (node.type === "tabs") {
    const hasActive = (_a = node.tabs) == null ? void 0 : _a.some((t) => t.active);
    if (hasActive) {
      const highlight = createRect(bounds, "none", "var(--interactive-accent)", cornerRadius);
      highlight.setAttribute("stroke-width", "1.5");
      svg.appendChild(highlight);
      return true;
    }
    return false;
  }
  if (node.type === "split") {
    const children = node.children || [];
    if (children.length === 0)
      return false;
    const sizes = node.sizes || children.map(() => 1 / children.length);
    const direction = node.direction;
    const totalSize = sizes.reduce((a, b) => a + b, 0);
    const normalizedSizes = sizes.map((s) => s / totalSize);
    let offset = 0;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      const size = normalizedSizes[i] || 1 / children.length;
      let childBounds;
      if (direction === "vertical") {
        childBounds = {
          x: bounds.x + offset * bounds.width,
          y: bounds.y,
          width: size * bounds.width,
          height: bounds.height
        };
      } else {
        childBounds = {
          x: bounds.x,
          y: bounds.y + offset * bounds.height,
          width: bounds.width,
          height: size * bounds.height
        };
      }
      if (drawFocusHighlight(svg, child, childBounds, cornerRadius)) {
        return true;
      }
      offset += size;
    }
  }
  return false;
}
function drawTabAreas(svg, node, bounds) {
  if (!node)
    return;
  if (node.type === "tabs") {
    const tabs = node.tabs || [];
    if (tabs.length === 0)
      return;
    const noteNames = tabs.map((tab) => {
      if (tab.name)
        return tab.name;
      const path = tab.path || "";
      const fileName = path.split("/").pop() || path;
      return fileName.replace(/\.md$/, "");
    });
    const activeIndex = tabs.findIndex((t) => t.active);
    let tooltipText;
    if (tabs.length === 1) {
      tooltipText = noteNames[0];
    } else {
      tooltipText = noteNames.map(
        (name, i) => i === activeIndex ? `\u25B8 ${name}` : `  ${name}`
      ).join("\n");
    }
    const area = document.createElementNS(SVG_NS, "rect");
    area.setAttribute("x", String(bounds.x));
    area.setAttribute("y", String(bounds.y));
    area.setAttribute("width", String(Math.max(0, bounds.width)));
    area.setAttribute("height", String(Math.max(0, bounds.height)));
    area.setAttribute("fill", "transparent");
    area.setAttribute("class", "perspecta-preview-tab-area");
    area.setAttribute("data-tooltip", tooltipText);
    svg.appendChild(area);
    return;
  }
  if (node.type === "split") {
    const children = node.children || [];
    if (children.length === 0)
      return;
    const sizes = node.sizes || children.map(() => 1 / children.length);
    const direction = node.direction;
    const totalSize = sizes.reduce((a, b) => a + b, 0);
    const normalizedSizes = sizes.map((s) => s / totalSize);
    let offset = 0;
    children.forEach((child, i) => {
      const size = normalizedSizes[i] || 1 / children.length;
      let childBounds;
      if (direction === "vertical") {
        childBounds = {
          x: bounds.x + offset * bounds.width,
          y: bounds.y,
          width: size * bounds.width,
          height: bounds.height
        };
      } else {
        childBounds = {
          x: bounds.x,
          y: bounds.y + offset * bounds.height,
          width: bounds.width,
          height: size * bounds.height
        };
      }
      drawTabAreas(svg, child, childBounds);
      offset += size;
    });
  }
}
function setupPreviewTooltips(container, doc) {
  let tooltip = null;
  const showTooltip = (e) => {
    const target = e.target;
    const text = target.getAttribute("data-tooltip");
    if (!text)
      return;
    if (tooltip)
      tooltip.remove();
    tooltip = doc.createElement("div");
    tooltip.className = "perspecta-preview-tooltip";
    tooltip.textContent = text;
    doc.body.appendChild(tooltip);
    const rect = target.getBoundingClientRect();
    tooltip.style.left = `${rect.right + 8}px`;
    tooltip.style.top = `${rect.top}px`;
    const tooltipRect = tooltip.getBoundingClientRect();
    if (tooltipRect.right > doc.documentElement.clientWidth) {
      tooltip.style.left = `${rect.left - tooltipRect.width - 8}px`;
    }
    if (tooltipRect.bottom > doc.documentElement.clientHeight) {
      tooltip.style.top = `${doc.documentElement.clientHeight - tooltipRect.height - 8}px`;
    }
  };
  const hideTooltip = () => {
    if (tooltip) {
      tooltip.remove();
      tooltip = null;
    }
  };
  container.addEventListener("mouseover", (e) => {
    if (e.target.classList.contains("perspecta-preview-tab-area")) {
      showTooltip(e);
    }
  });
  container.addEventListener("mouseout", (e) => {
    if (e.target.classList.contains("perspecta-preview-tab-area")) {
      hideTooltip();
    }
  });
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      mutation.removedNodes.forEach((node) => {
        var _a;
        if (node === container || ((_a = node.contains) == null ? void 0 : _a.call(node, container))) {
          hideTooltip();
          observer.disconnect();
        }
      });
    });
  });
  observer.observe(doc.body, { childList: true, subtree: true });
}
function createRect(rect, fill, stroke, rx) {
  const rectEl = document.createElementNS(SVG_NS, "rect");
  rectEl.setAttribute("x", String(rect.x));
  rectEl.setAttribute("y", String(rect.y));
  rectEl.setAttribute("width", String(Math.max(0, rect.width)));
  rectEl.setAttribute("height", String(Math.max(0, rect.height)));
  rectEl.setAttribute("fill", fill);
  rectEl.setAttribute("stroke", stroke);
  rectEl.setAttribute("rx", String(rx));
  return rectEl;
}
function formatTimestamp(ts) {
  const date = new Date(ts);
  const now = new Date();
  const isToday = date.toDateString() === now.toDateString();
  const yesterday = new Date(now);
  yesterday.setDate(yesterday.getDate() - 1);
  const isYesterday = date.toDateString() === yesterday.toDateString();
  const timeStr = date.toLocaleTimeString(void 0, {
    hour: "2-digit",
    minute: "2-digit"
  });
  if (isToday) {
    return `Today at ${timeStr}`;
  } else if (isYesterday) {
    return `Yesterday at ${timeStr}`;
  } else {
    const dateStr = date.toLocaleDateString(void 0, {
      month: "short",
      day: "numeric",
      year: date.getFullYear() !== now.getFullYear() ? "numeric" : void 0
    });
    return `${dateStr} at ${timeStr}`;
  }
}
function getArrangementSummary(arrangement) {
  var _a, _b, _c, _d;
  const arr = arrangement.arrangement;
  const windowCount = 1 + ((_b = (_a = arr.popouts) == null ? void 0 : _a.length) != null ? _b : 0);
  let tabCount = 0;
  const countTabs = (node) => {
    if (!node || typeof node !== "object")
      return;
    const n = node;
    if (n.type === "tabs" && Array.isArray(n.tabs)) {
      tabCount += n.tabs.length;
    } else if (n.type === "split" && Array.isArray(n.children)) {
      n.children.forEach(countTabs);
    }
  };
  countTabs((_c = arr.main) == null ? void 0 : _c.root);
  (_d = arr.popouts) == null ? void 0 : _d.forEach((p) => countTabs(p.root));
  const windowText = windowCount === 1 ? "1 window" : `${windowCount} windows`;
  const tabText = tabCount === 1 ? "1 tab" : `${tabCount} tabs`;
  return `${windowText}, ${tabText}`;
}
function showArrangementSelector(arrangements, fileName, onDelete, targetWindow = window) {
  return new Promise((resolve) => {
    const doc = targetWindow.document;
    const overlay = doc.createElement("div");
    overlay.className = "perspecta-debug-overlay";
    const modal = doc.createElement("div");
    modal.className = "perspecta-arrangement-selector";
    const title = modal.createDiv({ cls: "perspecta-modal-title" });
    title.setText(`Select Arrangement - ${fileName}`);
    const subtitle = modal.createDiv({ cls: "perspecta-modal-subtitle" });
    const updateSubtitle = (count) => {
      subtitle.setText(`${count} saved arrangement${count > 1 ? "s" : ""}`);
    };
    updateSubtitle(arrangements.length);
    const list = modal.createDiv({ cls: "perspecta-arrangement-list" });
    const sorted = [...arrangements].sort((a, b) => b.savedAt - a.savedAt);
    const cleanup = () => {
      modal.remove();
      overlay.remove();
    };
    const renderList = () => {
      list.empty();
      const remaining = sorted.filter((a) => !deletedTimestamps.has(a.savedAt));
      updateSubtitle(remaining.length);
      if (remaining.length === 0) {
        cleanup();
        resolve({ arrangement: sorted[0], cancelled: true });
        return;
      }
      remaining.forEach((arr, index) => {
        const item = list.createDiv({ cls: "perspecta-arrangement-item" });
        const previewContainer = item.createDiv({ cls: "perspecta-arrangement-preview-container" });
        const preview = generateArrangementPreview(arr, 80, 50);
        previewContainer.appendChild(preview);
        setupPreviewTooltips(previewContainer, doc);
        const info = item.createDiv({ cls: "perspecta-arrangement-info" });
        const timeLabel = info.createDiv({ cls: "perspecta-arrangement-time" });
        timeLabel.setText(formatTimestamp(arr.savedAt));
        if (index === 0) {
          const badge = timeLabel.createSpan({ cls: "perspecta-arrangement-badge" });
          badge.setText("Latest");
        }
        const summary = info.createDiv({ cls: "perspecta-arrangement-summary" });
        summary.setText(getArrangementSummary(arr));
        const deleteBtn = item.createDiv({ cls: "perspecta-arrangement-delete" });
        deleteBtn.innerHTML = `<svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
					<circle cx="12" cy="12" r="10"/>
					<line x1="15" y1="9" x2="9" y2="15"/>
					<line x1="9" y1="9" x2="15" y2="15"/>
				</svg>`;
        deleteBtn.setAttribute("aria-label", "Delete arrangement");
        deleteBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          deletedTimestamps.add(arr.savedAt);
          if (onDelete) {
            onDelete(arr.savedAt);
          }
          renderList();
        });
        item.addEventListener("click", () => {
          cleanup();
          resolve({ arrangement: arr, cancelled: false });
        });
      });
    };
    const deletedTimestamps = /* @__PURE__ */ new Set();
    renderList();
    const buttonRow = modal.createDiv({ cls: "perspecta-modal-buttons" });
    const cancelBtn = buttonRow.createEl("button", {
      cls: "perspecta-modal-button perspecta-modal-button-secondary",
      text: "Cancel"
    });
    overlay.onclick = () => {
      cleanup();
      resolve({ arrangement: sorted[0], cancelled: true });
    };
    cancelBtn.addEventListener("click", () => {
      cleanup();
      resolve({ arrangement: sorted[0], cancelled: true });
    });
    doc.body.appendChild(overlay);
    doc.body.appendChild(modal);
  });
}
function showConfirmOverwrite(existingArrangement, fileName, targetWindow = window) {
  return new Promise((resolve) => {
    const doc = targetWindow.document;
    const overlay = doc.createElement("div");
    overlay.className = "perspecta-debug-overlay";
    const modal = doc.createElement("div");
    modal.className = "perspecta-confirm-modal";
    const title = modal.createDiv({ cls: "perspecta-modal-title" });
    title.setText("Overwrite Arrangement?");
    const content = modal.createDiv({ cls: "perspecta-confirm-content" });
    content.createDiv({ text: `"${fileName}" already has a saved arrangement:` });
    const existingInfo = content.createDiv({ cls: "perspecta-existing-info" });
    const previewContainer = existingInfo.createDiv({ cls: "perspecta-arrangement-preview-container" });
    const preview = generateArrangementPreview(existingArrangement, 80, 50);
    previewContainer.appendChild(preview);
    setupPreviewTooltips(previewContainer, doc);
    const infoText = existingInfo.createDiv({ cls: "perspecta-existing-info-text" });
    infoText.createDiv({
      cls: "perspecta-arrangement-time",
      text: formatTimestamp(existingArrangement.savedAt)
    });
    infoText.createDiv({
      cls: "perspecta-arrangement-summary",
      text: getArrangementSummary(existingArrangement)
    });
    content.createDiv({
      cls: "perspecta-confirm-warning",
      text: "This will replace the existing arrangement."
    });
    const buttonRow = modal.createDiv({ cls: "perspecta-modal-buttons" });
    const cancelBtn = buttonRow.createEl("button", {
      cls: "perspecta-modal-button perspecta-modal-button-secondary",
      text: "Cancel"
    });
    const confirmBtn = buttonRow.createEl("button", {
      cls: "perspecta-modal-button perspecta-modal-button-primary",
      text: "Overwrite"
    });
    const cleanup = () => {
      modal.remove();
      overlay.remove();
    };
    overlay.onclick = () => {
      cleanup();
      resolve({ confirmed: false });
    };
    cancelBtn.addEventListener("click", () => {
      cleanup();
      resolve({ confirmed: false });
    });
    confirmBtn.addEventListener("click", () => {
      cleanup();
      resolve({ confirmed: true });
    });
    doc.body.appendChild(overlay);
    doc.body.appendChild(modal);
    confirmBtn.focus();
  });
}

// src/ui/proxy-view.ts
var import_obsidian2 = require("obsidian");
var PROXY_VIEW_TYPE = "perspecta-proxy-view";
function getElectronRemote() {
  try {
    return require("@electron/remote");
  } catch (e) {
    try {
      return require("electron").remote;
    } catch (e2) {
      return null;
    }
  }
}
var ProxyNoteView = class extends import_obsidian2.ItemView {
  constructor(leaf) {
    super(leaf);
    this.state = { filePath: "" };
    this.file = null;
    this.renderComponent = null;
  }
  getViewType() {
    return PROXY_VIEW_TYPE;
  }
  getDisplayText() {
    var _a;
    return ((_a = this.file) == null ? void 0 : _a.basename) || "Proxy";
  }
  getIcon() {
    return "minimize-2";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("perspecta-proxy-container");
    this.applyProxyWindowClass();
    this.renderContent(container);
    this.configureElectronWindow();
    setTimeout(() => this.configureElectronWindow(), 50);
    setTimeout(() => this.configureElectronWindow(), 150);
    setTimeout(() => this.configureElectronWindow(), 300);
  }
  applyProxyWindowClass() {
    var _a, _b, _c;
    const win = this.containerEl.win || ((_b = (_a = this.leaf.view) == null ? void 0 : _a.containerEl) == null ? void 0 : _b.win);
    if (win && win !== window && ((_c = win.document) == null ? void 0 : _c.body)) {
      win.document.body.classList.add("perspecta-proxy-window");
    }
    const workspaceEl = this.containerEl.closest(".workspace");
    if (workspaceEl) {
      workspaceEl.classList.add("perspecta-proxy-workspace");
    }
  }
  configureElectronWindow() {
    var _a, _b;
    const win = this.containerEl.win || ((_b = (_a = this.leaf.view) == null ? void 0 : _a.containerEl) == null ? void 0 : _b.win);
    if (!win || win === window)
      return;
    const doc = win.document;
    if (!doc)
      return;
    const headerEl = doc.querySelector(".workspace-tab-header-container");
    if (headerEl) {
      headerEl.remove();
    }
    const titlebarEl = doc.querySelector(".titlebar");
    if (titlebarEl) {
      titlebarEl.innerHTML = "";
      titlebarEl.style.height = "0";
      titlebarEl.style.minHeight = "0";
    }
    const viewHeader = doc.querySelector(".view-header");
    if (viewHeader) {
      viewHeader.style.display = "none";
    }
    this.configureElectronBrowserWindow();
  }
  configureElectronBrowserWindow() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    const remote = getElectronRemote();
    if (!remote)
      return;
    const win = this.containerEl.win || ((_b = (_a = this.leaf.view) == null ? void 0 : _a.containerEl) == null ? void 0 : _b.win);
    if (!win || win === window)
      return;
    try {
      const allWindows = remote.BrowserWindow.getAllWindows();
      for (const bw of allWindows) {
        const webContents = bw.webContents;
        if (webContents) {
          try {
            const bwDoc = (_d = (_c = webContents.mainFrame) == null ? void 0 : _c.window) == null ? void 0 : _d.document;
            if (bwDoc === win.document) {
              this.applyBrowserWindowConfig(bw);
              return;
            }
          } catch (e) {
          }
        }
        const title = ((_e = bw.getTitle) == null ? void 0 : _e.call(bw)) || "";
        if (((_f = this.file) == null ? void 0 : _f.basename) && title.includes(this.file.basename)) {
          this.applyBrowserWindowConfig(bw);
          return;
        }
      }
      for (const bw of allWindows) {
        if (!((_g = bw.isMainWindow) == null ? void 0 : _g.call(bw)) && ((_i = (_h = bw.getMinimumSize) == null ? void 0 : _h.call(bw)) == null ? void 0 : _i[0]) !== 150) {
          const title = ((_j = bw.getTitle) == null ? void 0 : _j.call(bw)) || "";
          if (title.includes("Proxy") || ((_k = this.file) == null ? void 0 : _k.basename) && title.includes(this.file.basename)) {
            this.applyBrowserWindowConfig(bw);
          }
        }
      }
    } catch (e) {
      console.log("[Perspecta] Could not configure window:", e);
    }
  }
  applyBrowserWindowConfig(bw) {
    bw.setMinimumSize(150, 40);
    if (import_obsidian2.Platform.isMacOS && typeof bw.setWindowButtonVisibility === "function") {
      bw.setWindowButtonVisibility(false);
    }
  }
  async renderContent(container) {
    var _a, _b, _c, _d;
    const headerRow = container.createDiv({ cls: "perspecta-proxy-header" });
    headerRow.style.cssText += "-webkit-app-region: drag; cursor: move;";
    headerRow.createDiv({
      cls: "perspecta-proxy-title",
      text: ((_a = this.file) == null ? void 0 : _a.basename) || "No file"
    });
    const expandBtn = headerRow.createDiv({ cls: "perspecta-proxy-expand" });
    expandBtn.style.cssText += "-webkit-app-region: no-drag; cursor: pointer;";
    (0, import_obsidian2.setIcon)(expandBtn, "maximize-2");
    expandBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      this.expandToFullWindow();
    });
    const previewWrapper = container.createDiv({ cls: "perspecta-proxy-preview-wrapper" });
    const previewContent = previewWrapper.createDiv({ cls: "perspecta-proxy-preview-content" });
    const ext = ((_b = this.file) == null ? void 0 : _b.extension.toLowerCase()) || "";
    const needsScaling = !this.isImageFile(ext) && !this.isPdfFile(ext) && !this.isNonRenderableFile(ext);
    if (needsScaling) {
      const plugin = this.app.plugins.plugins["perspecta-obsidian"];
      const scale = (_d = (_c = plugin == null ? void 0 : plugin.settings) == null ? void 0 : _c.proxyPreviewScale) != null ? _d : 0.35;
      const inverseScale = 100 / (scale * 100);
      previewContent.style.width = `${inverseScale * 100}%`;
      previewContent.style.height = `${inverseScale * 100}%`;
      previewContent.style.transform = `scale(${scale})`;
    } else {
      previewContent.style.width = "100%";
      previewContent.style.height = "100%";
      previewContent.style.position = "relative";
    }
    await this.renderMarkdownPreview(previewContent);
    previewWrapper.style.overflow = "auto";
    previewWrapper.style.cursor = "pointer";
    previewContent.style.pointerEvents = "auto";
    previewWrapper.addEventListener("click", (e) => {
      if (this.state.arrangementUid) {
        const forceLatest = !e.shiftKey;
        this.restoreArrangement(forceLatest);
      } else {
        this.expandToFullWindow();
      }
    });
    container.tabIndex = 0;
    container.addEventListener("keydown", (e) => {
      const scrollAmount = 50;
      if (e.key === "ArrowDown" || e.key === "j") {
        previewWrapper.scrollTop += scrollAmount;
        e.preventDefault();
      } else if (e.key === "ArrowUp" || e.key === "k") {
        previewWrapper.scrollTop -= scrollAmount;
        e.preventDefault();
      } else if (e.key === "PageDown") {
        previewWrapper.scrollTop += previewWrapper.clientHeight;
        e.preventDefault();
      } else if (e.key === "PageUp") {
        previewWrapper.scrollTop -= previewWrapper.clientHeight;
        e.preventDefault();
      } else if (e.key === "Home") {
        previewWrapper.scrollTop = 0;
        e.preventDefault();
      } else if (e.key === "End") {
        previewWrapper.scrollTop = previewWrapper.scrollHeight;
        e.preventDefault();
      } else if (e.key === "Enter" || e.key === " ") {
        if (this.state.arrangementUid) {
          this.restoreArrangement(true);
        } else {
          this.expandToFullWindow();
        }
        e.preventDefault();
      }
    });
    container.addEventListener("mousedown", () => {
      container.focus();
    });
    previewWrapper.addEventListener("mouseenter", () => {
      previewWrapper.style.backgroundColor = "var(--background-secondary)";
    });
    previewWrapper.addEventListener("mouseleave", () => {
      previewWrapper.style.backgroundColor = "";
    });
  }
  async renderMarkdownPreview(container) {
    if (!this.file)
      return;
    const ext = this.file.extension.toLowerCase();
    if (this.isImageFile(ext)) {
      this.renderImagePreview(container);
      return;
    }
    if (this.isPdfFile(ext)) {
      this.renderFileTypeIcon(container, "file-text", "PDF");
      return;
    }
    if (this.isNonRenderableFile(ext)) {
      this.renderFileTypeIcon(container, "file", ext.toUpperCase());
      return;
    }
    try {
      const content = await this.app.vault.cachedRead(this.file);
      if (this.renderComponent) {
        this.renderComponent.unload();
      }
      this.renderComponent = new import_obsidian2.Component();
      this.renderComponent.load();
      await import_obsidian2.MarkdownRenderer.render(
        this.app,
        content,
        container,
        this.file.path,
        this.renderComponent
      );
    } catch (e) {
      console.log("[Perspecta] Could not render preview:", e);
      container.setText("Preview unavailable");
    }
  }
  isImageFile(ext) {
    return ["png", "jpg", "jpeg", "gif", "bmp", "svg", "webp", "ico", "avif"].includes(ext);
  }
  isPdfFile(ext) {
    return ext === "pdf";
  }
  isNonRenderableFile(ext) {
    return [
      "pdf",
      "doc",
      "docx",
      "xls",
      "xlsx",
      "ppt",
      "pptx",
      "zip",
      "rar",
      "7z",
      "tar",
      "gz",
      "mp3",
      "wav",
      "ogg",
      "flac",
      "m4a",
      "mp4",
      "mov",
      "avi",
      "mkv",
      "webm",
      "exe",
      "dmg",
      "app",
      "bin"
    ].includes(ext);
  }
  renderImagePreview(container) {
    if (!this.file)
      return;
    const imgContainer = container.createDiv({ cls: "perspecta-proxy-image-preview" });
    const resourcePath = this.app.vault.getResourcePath(this.file);
    const img = imgContainer.createEl("img", {
      attr: {
        src: resourcePath,
        alt: this.file.basename
      }
    });
    img.style.maxWidth = "100%";
    img.style.maxHeight = "100%";
    img.style.objectFit = "contain";
    imgContainer.style.display = "flex";
    imgContainer.style.alignItems = "center";
    imgContainer.style.justifyContent = "center";
    imgContainer.style.height = "100%";
    imgContainer.style.padding = "8px";
    imgContainer.style.boxSizing = "border-box";
  }
  renderFileTypeIcon(container, iconName, fileType) {
    const iconContainer = container.createDiv({ cls: "perspecta-proxy-file-icon" });
    const iconEl = iconContainer.createDiv({ cls: "perspecta-proxy-file-icon-svg" });
    (0, import_obsidian2.setIcon)(iconEl, iconName);
    iconContainer.createDiv({
      cls: "perspecta-proxy-file-type-label",
      text: fileType
    });
    iconContainer.style.display = "flex";
    iconContainer.style.flexDirection = "column";
    iconContainer.style.alignItems = "center";
    iconContainer.style.justifyContent = "center";
    iconContainer.style.height = "100%";
    iconContainer.style.gap = "8px";
    iconContainer.style.color = "var(--text-muted)";
    iconEl.style.width = "48px";
    iconEl.style.height = "48px";
    const svg = iconEl.querySelector("svg");
    if (svg) {
      svg.style.width = "100%";
      svg.style.height = "100%";
    }
  }
  async onClose() {
    if (this.renderComponent) {
      this.renderComponent.unload();
      this.renderComponent = null;
    }
  }
  async setState(state, result) {
    this.state = state;
    if (state.filePath) {
      this.file = this.app.vault.getAbstractFileByPath(state.filePath);
    }
    const container = this.containerEl.children[1];
    if (container) {
      container.empty();
      this.renderContent(container);
    }
    return super.setState(state, result);
  }
  getState() {
    return this.state;
  }
  async restoreArrangement(forceLatest = true) {
    if (!this.state.arrangementUid || !this.file)
      return;
    const file = this.file;
    const plugin = this.app.plugins.plugins["perspecta-obsidian"];
    this.leaf.detach();
    if (plugin && typeof plugin.restoreContext === "function") {
      await plugin.restoreContext(file, forceLatest);
    }
  }
  async expandToFullWindow() {
    if (!this.file)
      return;
    const win = this.leaf.view.containerEl.win;
    const x = (win == null ? void 0 : win.screenX) || 100;
    const y = (win == null ? void 0 : win.screenY) || 100;
    this.leaf.detach();
    const newLeaf = this.app.workspace.openPopoutLeaf({
      size: { width: 800, height: 600 }
    });
    await newLeaf.openFile(this.file);
    const newWin = newLeaf.view.containerEl.win;
    if (newWin && newWin !== window) {
      try {
        newWin.moveTo(x, y);
      } catch (e) {
      }
    }
  }
};

// src/main.ts
async function getUidFromFile(app, file) {
  if (file.extension === "canvas") {
    return getUidFromCanvas(app, file);
  }
  if (file.extension === "base") {
    return getUidFromBase(app, file);
  }
  return getUidFromCache(app, file);
}
function resolveFile(app, tab) {
  const fileByPath = app.vault.getAbstractFileByPath(tab.path);
  if (fileByPath instanceof import_obsidian3.TFile) {
    return { file: fileByPath, method: "path" };
  }
  if (tab.uid) {
    const files = app.vault.getMarkdownFiles();
    for (const file of files) {
      const fileUid = getUidFromCache(app, file);
      if (fileUid === tab.uid) {
        return { file, method: "uid" };
      }
    }
  }
  if (tab.name) {
    const files = app.vault.getMarkdownFiles();
    const matches = files.filter((f) => f.basename === tab.name);
    if (matches.length === 1) {
      return { file: matches[0], method: "name" };
    }
  }
  return { file: null, method: "not_found" };
}
var COORDINATE_DEBUG = false;
var PerspectaPlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.focusedWindowIndex = -1;
    this.windowFocusListeners = /* @__PURE__ */ new Map();
    this.filesWithContext = /* @__PURE__ */ new Set();
    this.refreshIndicatorsTimeout = null;
    this.isClosingWindow = false;
    // ============================================================================
    // Context Restore (Optimized)
    // ============================================================================
    // Track path corrections during restore (populated by restoreTabGroup and helpers)
    this.pathCorrections = /* @__PURE__ */ new Map();
    this.isRestoring = false;
    // Queue of pending tab activations to process after restore
    this.pendingTabActivations = [];
  }
  // External context storage
  async onload() {
    await this.loadSettings();
    this.externalStore = new ExternalContextStore({ app: this.app, manifest: this.manifest });
    if (this.settings.storageMode === "external") {
      await this.externalStore.initialize();
    }
    this.hideInternalProperties();
    this.registerView(PROXY_VIEW_TYPE, (leaf) => new ProxyNoteView(leaf));
    this.addRibbonIcon("layout-grid", "Perspecta", () => {
    });
    this.addCommand({
      id: "save-context",
      name: "Save context",
      callback: () => this.saveContext()
    });
    this.addCommand({
      id: "restore-context",
      name: "Restore context",
      callback: () => this.restoreContext()
    });
    this.addCommand({
      id: "show-context-details",
      name: "Show context details",
      callback: () => this.showContextDetails()
    });
    this.addCommand({
      id: "convert-to-proxy",
      name: "Convert to proxy window",
      checkCallback: (checking) => {
        var _a;
        if (!this.settings.enableProxyWindows)
          return false;
        const activeLeaf = this.app.workspace.activeLeaf;
        if (!activeLeaf)
          return false;
        const win = activeLeaf.view.containerEl.win;
        if (!win || win === window)
          return false;
        const file = (_a = activeLeaf.view) == null ? void 0 : _a.file;
        if (!file)
          return false;
        if (!checking) {
          this.convertToProxyWindow(activeLeaf, file);
        }
        return true;
      }
    });
    this.setupFocusTracking();
    this.setupContextIndicator();
    this.setupFileExplorerIndicators();
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        if (file instanceof import_obsidian3.TFile && file.extension === "md") {
          menu.addItem((item) => {
            item.setTitle("Remember note context").setIcon("target").onClick(() => this.saveContext(file));
          });
        }
      })
    );
    this.registerDomEvent(document, "auxclick", (evt) => {
      if (evt.button === 1) {
        const link = evt.target.closest("a.internal-link");
        if (link) {
          evt.preventDefault();
          const href = link.getAttribute("data-href");
          if (href) {
            const file = this.app.metadataCache.getFirstLinkpathDest(href, "");
            if (file instanceof import_obsidian3.TFile)
              this.openInNewWindow(file);
          }
        }
      }
    });
    this.registerDomEvent(document, "click", (evt) => {
      if (evt.altKey && evt.button === 0) {
        const link = evt.target.closest("a.internal-link");
        if (link) {
          evt.preventDefault();
          evt.stopPropagation();
          const href = link.getAttribute("data-href");
          if (href) {
            const file = this.app.metadataCache.getFirstLinkpathDest(href, "");
            if (file instanceof import_obsidian3.TFile)
              this.openInNewWindow(file);
          }
        }
      }
    }, true);
    this.addSettingTab(new PerspectaSettingTab(this.app, this));
  }
  async onunload() {
    await this.externalStore.cleanup();
    this.windowFocusListeners.forEach((listener, win) => {
      win.removeEventListener("focus", listener);
    });
    this.windowFocusListeners.clear();
  }
  // ============================================================================
  // Focus Tracking
  // ============================================================================
  setupFocusTracking() {
    this.registerDomEvent(window, "focus", () => this.focusedWindowIndex = -1);
    this.registerEvent(
      this.app.workspace.on("window-open", (_, win) => {
        this.trackPopoutWindowFocus(win);
      })
    );
    this.registerEvent(
      this.app.workspace.on("window-close", (_, win) => {
        this.isClosingWindow = true;
        const listener = this.windowFocusListeners.get(win);
        if (listener) {
          win.removeEventListener("focus", listener);
          this.windowFocusListeners.delete(win);
        }
        setTimeout(() => {
          this.isClosingWindow = false;
        }, 100);
      })
    );
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        if (this.isClosingWindow) {
          return;
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", (leaf) => {
        if (this.isClosingWindow)
          return;
      })
    );
  }
  trackPopoutWindowFocus(win) {
    if (this.windowFocusListeners.has(win))
      return;
    const listener = () => {
      if (this.isClosingWindow) {
        return;
      }
      PerfTimer.begin("popoutFocusHandler");
      const popouts = this.getPopoutWindowObjects();
      PerfTimer.mark("getPopoutWindowObjects");
      this.focusedWindowIndex = popouts.indexOf(win);
      PerfTimer.end("popoutFocusHandler");
    };
    win.addEventListener("focus", listener);
    this.windowFocusListeners.set(win, listener);
  }
  // ============================================================================
  // Window Arrangement Capture (Optimized)
  // ============================================================================
  captureWindowArrangement() {
    PerfTimer.mark("captureWindowArrangement:start");
    const workspace = this.app.workspace;
    const main = this.captureWindowState(workspace.rootSplit, window);
    PerfTimer.mark("captureMainWindow");
    const popouts = this.capturePopoutStates();
    PerfTimer.mark("capturePopouts");
    const leftSidebar = this.captureSidebarState("left");
    const rightSidebar = this.captureSidebarState("right");
    PerfTimer.mark("captureSidebars");
    const screen = getPhysicalScreen();
    const sourceScreen = {
      width: screen.width,
      height: screen.height,
      aspectRatio: screen.width / screen.height
    };
    return {
      v: 2,
      ts: Date.now(),
      main,
      popouts,
      focusedWindow: this.focusedWindowIndex,
      leftSidebar,
      rightSidebar,
      sourceScreen
    };
  }
  captureWindowState(rootSplit, win) {
    const physical = {
      x: win.screenX,
      y: win.screenY,
      width: win.outerWidth,
      height: win.outerHeight
    };
    const virtual = physicalToVirtual(physical);
    console.log(`[Perspecta] captureWindowState:`, { physical, virtual });
    return {
      root: this.captureSplitOrTabs(rootSplit),
      x: virtual.x,
      y: virtual.y,
      width: virtual.width,
      height: virtual.height
    };
  }
  capturePopoutStates() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const states = [];
    const workspace = this.app.workspace;
    const floatingSplit = workspace.floatingSplit;
    if (!(floatingSplit == null ? void 0 : floatingSplit.children))
      return states;
    const seenWindows = /* @__PURE__ */ new Set();
    for (const container of floatingSplit.children) {
      const win = container == null ? void 0 : container.win;
      if (!win || win === window)
        continue;
      if (seenWindows.has(win)) {
        console.log("[Perspecta] Skipping duplicate window in capturePopoutStates");
        continue;
      }
      seenWindows.add(win);
      if (COORDINATE_DEBUG) {
        console.log(`[Perspecta] capturePopoutStates container:`, {
          containerType: (_a = container == null ? void 0 : container.constructor) == null ? void 0 : _a.name,
          containerDirection: container == null ? void 0 : container.direction,
          containerChildren: (_b = container == null ? void 0 : container.children) == null ? void 0 : _b.length,
          firstChildType: (_e = (_d = (_c = container == null ? void 0 : container.children) == null ? void 0 : _c[0]) == null ? void 0 : _d.constructor) == null ? void 0 : _e.name,
          firstChildDirection: (_g = (_f = container == null ? void 0 : container.children) == null ? void 0 : _f[0]) == null ? void 0 : _g.direction
        });
      }
      if (((_h = container == null ? void 0 : container.children) == null ? void 0 : _h.length) > 0) {
        const virtual = physicalToVirtual({
          x: win.screenX,
          y: win.screenY,
          width: win.outerWidth,
          height: win.outerHeight
        });
        const isProxy = this.isProxyWindow(container);
        states.push({
          root: this.captureSplitOrTabs(container),
          x: virtual.x,
          y: virtual.y,
          width: virtual.width,
          height: virtual.height,
          isProxy
        });
      }
    }
    return states;
  }
  /**
   * Check if a popout container contains a proxy view
   */
  isProxyWindow(container) {
    var _a, _b, _c, _d;
    if (!(container == null ? void 0 : container.children))
      return false;
    for (const child of container.children) {
      if (((_b = (_a = child == null ? void 0 : child.view) == null ? void 0 : _a.getViewType) == null ? void 0 : _b.call(_a)) === PROXY_VIEW_TYPE) {
        return true;
      }
      if (child == null ? void 0 : child.children) {
        for (const leaf of child.children) {
          if (((_d = (_c = leaf == null ? void 0 : leaf.view) == null ? void 0 : _c.getViewType) == null ? void 0 : _d.call(_c)) === PROXY_VIEW_TYPE) {
            return true;
          }
        }
      }
    }
    return false;
  }
  captureSplitOrTabs(node) {
    var _a, _b, _c;
    if (!node)
      return { type: "tabs", tabs: [] };
    if (node.direction && Array.isArray(node.children)) {
      const children = [];
      const sizes = [];
      for (const child of node.children) {
        const childState = this.captureSplitOrTabs(child);
        if (childState.type === "split" || childState.tabs.length > 0) {
          children.push(childState);
          const size = (_c = (_b = (_a = child.dimension) != null ? _a : child.size) != null ? _b : child.width) != null ? _c : child.height;
          sizes.push(size != null ? size : 50);
        }
      }
      if (children.length === 1)
        return children[0];
      if (children.length === 0)
        return { type: "tabs", tabs: [] };
      if (COORDINATE_DEBUG) {
        console.log(`[Perspecta] captureSplitOrTabs: direction=${node.direction}, children=${children.length}, sizes=${JSON.stringify(sizes)}`);
        if (node.children[0]) {
          const props = Object.keys(node.children[0]).filter(
            (k) => typeof node.children[0][k] === "number" || typeof node.children[0][k] === "string" && !k.startsWith("_")
          );
          console.log(`[Perspecta] Child properties:`, props.map((p) => `${p}=${node.children[0][p]}`));
        }
      }
      return { type: "split", direction: node.direction, children, sizes };
    }
    return this.captureTabGroup(node);
  }
  captureTabGroup(tabContainer) {
    var _a, _b, _c, _d, _e, _f;
    const tabs = [];
    const children = (tabContainer == null ? void 0 : tabContainer.children) || [];
    const currentTabIndex = (_a = tabContainer == null ? void 0 : tabContainer.currentTab) != null ? _a : 0;
    if (PerfTimer.isEnabled()) {
      console.log(`[Perspecta] captureTabGroup: ${children.length} children, currentTab=${tabContainer == null ? void 0 : tabContainer.currentTab}, using index=${currentTabIndex}`);
    }
    for (let i = 0; i < children.length; i++) {
      const leaf = children[i];
      const file = (_b = leaf == null ? void 0 : leaf.view) == null ? void 0 : _b.file;
      if (file) {
        const uid = getUidFromCache(this.app, file);
        const name = file.basename;
        const scroll = (_e = (_d = (_c = leaf == null ? void 0 : leaf.view) == null ? void 0 : _c.currentMode) == null ? void 0 : _d.getScroll) == null ? void 0 : _e.call(_d);
        let canvasViewport;
        const canvas = (_f = leaf == null ? void 0 : leaf.view) == null ? void 0 : _f.canvas;
        if (canvas && typeof canvas.tx === "number") {
          canvasViewport = {
            tx: canvas.tx,
            ty: canvas.ty,
            zoom: canvas.tZoom
          };
        }
        const isActive = i === currentTabIndex;
        if (PerfTimer.isEnabled()) {
          console.log(`[Perspecta]   tab[${i}]: ${file.basename}, active=${isActive}, scroll=${scroll}${canvasViewport ? `, canvas: tx=${canvasViewport.tx.toFixed(0)}, ty=${canvasViewport.ty.toFixed(0)}, zoom=${canvasViewport.zoom.toFixed(2)}` : ""}`);
        }
        tabs.push({
          path: file.path,
          active: isActive,
          uid,
          name,
          scroll: typeof scroll === "number" ? scroll : void 0,
          canvasViewport
        });
      }
    }
    return { type: "tabs", tabs };
  }
  captureSidebarState(side) {
    var _a, _b, _c;
    const workspace = this.app.workspace;
    const sidebar = side === "left" ? workspace.leftSplit : workspace.rightSplit;
    if (!sidebar)
      return { collapsed: true };
    let activeTab;
    try {
      const leaf = side === "left" ? workspace.leftLeaf : workspace.rightLeaf;
      activeTab = (_b = (_a = leaf == null ? void 0 : leaf.view) == null ? void 0 : _a.getViewType) == null ? void 0 : _b.call(_a);
    } catch (e) {
    }
    return { collapsed: (_c = sidebar.collapsed) != null ? _c : false, activeTab };
  }
  getPopoutWindowObjects() {
    const start = performance.now();
    const windows = [];
    const seen = /* @__PURE__ */ new Set([window]);
    this.app.workspace.iterateAllLeaves((leaf) => {
      var _a, _b;
      const win = (_b = (_a = leaf.view) == null ? void 0 : _a.containerEl) == null ? void 0 : _b.win;
      if (win && !seen.has(win)) {
        seen.add(win);
        windows.push(win);
      }
    });
    const elapsed = performance.now() - start;
    if (elapsed > 20) {
      console.warn(`[Perspecta] \u26A0 SLOW getPopoutWindowObjects: ${elapsed.toFixed(1)}ms`);
    }
    return windows;
  }
  // ============================================================================
  // Context Save (Optimized)
  // ============================================================================
  async saveContext(file) {
    PerfTimer.begin("saveContext");
    const targetFile = file != null ? file : this.app.workspace.getActiveFile();
    PerfTimer.mark("getActiveFile");
    if (!targetFile) {
      new import_obsidian3.Notice("No active file to save context to", 4e3);
      return;
    }
    const isMarkdown = targetFile.extension === "md";
    const isCanvas = targetFile.extension === "canvas";
    const isBase = targetFile.extension === "base";
    if (!isMarkdown && !isCanvas && !isBase) {
      new import_obsidian3.Notice(`Cannot save context to ${targetFile.extension} files. Please use a markdown, canvas, or base file.`, 4e3);
      PerfTimer.end("saveContext");
      return;
    }
    let context = this.captureWindowArrangement();
    PerfTimer.mark("captureWindowArrangement");
    if (this.settings.autoGenerateUids || this.settings.storageMode === "external") {
      context = await this.ensureUidsForContext(context);
      PerfTimer.mark("ensureUidsForContext");
    }
    let saved = true;
    if (isCanvas) {
      await saveContextToCanvas(this.app, targetFile, context);
      this.filesWithContext.add(targetFile.path);
      this.debouncedRefreshIndicators();
      PerfTimer.mark("saveContextToCanvas");
    } else if (isBase) {
      await saveContextToBase(this.app, targetFile, context);
      this.filesWithContext.add(targetFile.path);
      this.debouncedRefreshIndicators();
      PerfTimer.mark("saveContextToBase");
    } else if (this.settings.storageMode === "external") {
      saved = await this.saveContextExternal(targetFile, context);
      PerfTimer.mark("saveContextExternal");
    } else {
      await this.saveArrangementToNote(targetFile, context);
      PerfTimer.mark("saveArrangementToNote");
    }
    if (saved) {
      if (this.settings.showDebugModal) {
        this.showContextDebugModal(context, targetFile.name);
        PerfTimer.mark("showContextDebugModal");
      } else {
        new import_obsidian3.Notice(`Context saved to ${targetFile.name}`, 4e3);
      }
    }
    PerfTimer.end("saveContext");
  }
  // Save context to external store (using file's UID as key)
  // Returns true if save was successful, false if cancelled
  async saveContextExternal(file, context) {
    let uid = getUidFromCache(this.app, file);
    if (!uid) {
      uid = generateUid();
      await addUidToFile(this.app, file, uid);
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
    if (!this.externalStore["initialized"]) {
      await this.externalStore.initialize();
    }
    const maxArrangements = this.settings.maxArrangementsPerNote;
    const existingCount = this.externalStore.getCount(uid);
    if (maxArrangements === 1 && existingCount > 0 && !this.settings.autoConfirmOverwrite) {
      const existingArrangements = this.externalStore.getAll(uid);
      if (existingArrangements.length > 0) {
        const result = await showConfirmOverwrite(existingArrangements[0], file.name);
        if (!result.confirmed) {
          return false;
        }
      }
    }
    this.externalStore.set(uid, context, maxArrangements);
    await this.removeArrangementFromFrontmatter(file);
    this.filesWithContext.add(file.path);
    this.debouncedRefreshIndicators();
    return true;
  }
  // Remove perspecta-arrangement property from a file's frontmatter
  async removeArrangementFromFrontmatter(file) {
    const content = await this.app.vault.read(file);
    const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
    const match = content.match(frontmatterRegex);
    if (!match)
      return false;
    const fm = match[1];
    if (!fm.includes(`${FRONTMATTER_KEY}:`))
      return false;
    let newFm = fm.replace(/perspecta-arrangement:[\s\S]*?(?=\n[^\s]|\n$|$)/g, "").replace(/perspecta-arrangement: ".*"\n?/g, "").trim();
    const newContent = content.replace(frontmatterRegex, `---
${newFm}
---`);
    if (newContent !== content) {
      await this.app.vault.modify(file, newContent);
      return true;
    }
    return false;
  }
  // ============================================================================
  // Storage Migration & Cleanup
  // ============================================================================
  // Hide internal properties (perspecta-uid) from the Properties view
  // They remain visible in source mode for transparency
  hideInternalProperties() {
    try {
      const metadataTypeManager = this.app.metadataTypeManager;
      if (!metadataTypeManager)
        return;
      if (metadataTypeManager.properties) {
        const props = metadataTypeManager.properties;
        if (props[UID_FRONTMATTER_KEY]) {
          props[UID_FRONTMATTER_KEY].hidden = true;
        } else {
          props[UID_FRONTMATTER_KEY] = { name: UID_FRONTMATTER_KEY, type: "text", hidden: true };
        }
      }
      if (typeof metadataTypeManager.setType === "function") {
        metadataTypeManager.setType(UID_FRONTMATTER_KEY, "text");
      }
      if (metadataTypeManager.types) {
        if (!metadataTypeManager.types[UID_FRONTMATTER_KEY]) {
          metadataTypeManager.types[UID_FRONTMATTER_KEY] = { type: "text" };
        }
        metadataTypeManager.types[UID_FRONTMATTER_KEY].hidden = true;
      }
      if (typeof metadataTypeManager.save === "function") {
        metadataTypeManager.save();
      }
    } catch (e) {
      console.log("[Perspecta] Could not hide internal properties:", e);
    }
  }
  // Clean up old 'uid' properties from all files that have perspecta-uid
  async cleanupOldUidProperties() {
    const files = this.app.vault.getMarkdownFiles();
    let cleaned = 0;
    for (const file of files) {
      try {
        if (await cleanupOldUid(this.app, file)) {
          cleaned++;
        }
      } catch (e) {
        console.warn(`[Perspecta] Failed to cleanup ${file.path}:`, e);
      }
    }
    return cleaned;
  }
  // Migrate all contexts from frontmatter to external storage
  async migrateToExternalStorage() {
    const files = this.app.vault.getMarkdownFiles();
    let migrated = 0;
    let errors = 0;
    if (!this.externalStore["initialized"]) {
      await this.externalStore.initialize();
    }
    for (const file of files) {
      try {
        const context = this.getContextFromNote(file);
        if (!context)
          continue;
        let uid = getUidFromCache(this.app, file);
        if (!uid) {
          uid = generateUid();
          await addUidToFile(this.app, file, uid);
          await new Promise((resolve) => setTimeout(resolve, 50));
        }
        const v2 = this.normalizeToV2(context);
        this.externalStore.set(uid, v2);
        await this.removeArrangementFromFrontmatter(file);
        migrated++;
      } catch (e) {
        console.error(`[Perspecta] Failed to migrate ${file.path}:`, e);
        errors++;
      }
    }
    await this.externalStore.flushDirty();
    this.settings.storageMode = "external";
    await this.saveSettings();
    this.filesWithContext.clear();
    await this.setupFileExplorerIndicators();
    return { migrated, errors };
  }
  // Migrate all contexts from external storage to frontmatter
  async migrateToFrontmatter() {
    const files = this.app.vault.getMarkdownFiles();
    let migrated = 0;
    let errors = 0;
    if (!this.externalStore["initialized"]) {
      await this.externalStore.initialize();
    }
    for (const file of files) {
      try {
        const uid = getUidFromCache(this.app, file);
        if (!uid)
          continue;
        const context = this.externalStore.get(uid);
        if (!context)
          continue;
        await this.saveArrangementToNote(file, context);
        await this.externalStore.delete(uid);
        migrated++;
      } catch (e) {
        console.error(`[Perspecta] Failed to migrate ${file.path}:`, e);
        errors++;
      }
    }
    this.settings.storageMode = "frontmatter";
    await this.saveSettings();
    this.filesWithContext.clear();
    await this.setupFileExplorerIndicators();
    return { migrated, errors };
  }
  // Get the backup folder path
  getBackupFolderPath() {
    const basePath = this.settings.perspectaFolderPath.replace(/\/+$/, "");
    return `${basePath}/backups`;
  }
  // Backup all arrangements to the perspecta folder
  async backupArrangements() {
    if (!this.externalStore["initialized"]) {
      await this.externalStore.initialize();
    }
    const allArrangements = {};
    const uids = this.externalStore.getAllUids();
    for (const uid of uids) {
      const arrangements = this.externalStore.getAll(uid);
      if (arrangements.length > 0) {
        allArrangements[uid] = arrangements;
      }
    }
    const backupFolder = this.getBackupFolderPath();
    if (!await this.app.vault.adapter.exists(backupFolder)) {
      await this.app.vault.createFolder(backupFolder);
    }
    const now = new Date();
    const timestamp = now.toISOString().replace(/[:.]/g, "-").slice(0, 19);
    const backupFileName = `arrangements-backup-${timestamp}.json`;
    const backupPath = `${backupFolder}/${backupFileName}`;
    const backupData = {
      version: 1,
      createdAt: now.toISOString(),
      arrangementCount: Object.keys(allArrangements).length,
      arrangements: allArrangements
    };
    await this.app.vault.create(backupPath, JSON.stringify(backupData, null, 2));
    return { count: Object.keys(allArrangements).length, path: backupPath };
  }
  // List available backups
  async listBackups() {
    const backupFolder = this.getBackupFolderPath();
    if (!await this.app.vault.adapter.exists(backupFolder)) {
      return [];
    }
    const files = await this.app.vault.adapter.list(backupFolder);
    const backups = [];
    for (const filePath of files.files) {
      if (filePath.endsWith(".json")) {
        const fileName = filePath.split("/").pop() || "";
        const match = fileName.match(/arrangements-backup-(\d{4}-\d{2}-\d{2}T\d{2}-\d{2}-\d{2})\.json/);
        if (match) {
          const dateStr = match[1].replace(/-/g, (m, offset) => offset > 9 ? ":" : "-").replace("T", "T");
          const date = new Date(dateStr.slice(0, 10) + "T" + dateStr.slice(11).replace(/-/g, ":"));
          backups.push({ name: fileName, path: filePath, date });
        }
      }
    }
    backups.sort((a, b) => b.date.getTime() - a.date.getTime());
    return backups;
  }
  // Restore arrangements from a backup file
  async restoreFromBackup(backupPath) {
    const content = await this.app.vault.adapter.read(backupPath);
    const backupData = JSON.parse(content);
    if (!backupData.arrangements || typeof backupData.arrangements !== "object") {
      throw new Error("Invalid backup file format");
    }
    if (!this.externalStore["initialized"]) {
      await this.externalStore.initialize();
    }
    let restored = 0;
    let errors = 0;
    for (const [uid, arrangements] of Object.entries(backupData.arrangements)) {
      try {
        const arrList = arrangements;
        for (const item of arrList) {
          this.externalStore.set(uid, item.arrangement, this.settings.maxArrangementsPerNote);
        }
        restored++;
      } catch (e) {
        console.error(`[Perspecta] Failed to restore arrangements for UID ${uid}:`, e);
        errors++;
      }
    }
    await this.externalStore.flushDirty();
    this.filesWithContext.clear();
    await this.setupFileExplorerIndicators();
    return { restored, errors };
  }
  // Generate UIDs for any files in the context that don't have them
  async ensureUidsForContext(context) {
    const filesToUpdate = [];
    this.collectFilesNeedingUids(context.main.root, filesToUpdate);
    for (const popout of context.popouts) {
      this.collectFilesNeedingUids(popout.root, filesToUpdate);
    }
    for (const { file, uid } of filesToUpdate) {
      try {
        await addUidToFile(this.app, file, uid);
        if (PerfTimer.isEnabled()) {
          console.log(`[Perspecta] Added UID to ${file.path}: ${uid}`);
        }
      } catch (e) {
        console.warn(`[Perspecta] Failed to add UID to ${file.path}:`, e);
      }
    }
    if (filesToUpdate.length > 0) {
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
    if (filesToUpdate.length > 0) {
      return this.captureWindowArrangement();
    }
    return context;
  }
  // Helper to collect files that need UIDs from a workspace node
  collectFilesNeedingUids(node, result) {
    if (node.type === "tabs") {
      for (const tab of node.tabs) {
        if (!tab.uid) {
          const file = this.app.vault.getAbstractFileByPath(tab.path);
          if (file instanceof import_obsidian3.TFile && file.extension === "md") {
            const existingUid = getUidFromCache(this.app, file);
            if (!existingUid) {
              result.push({ file, uid: generateUid() });
            }
          }
        }
      }
    } else if (node.type === "split") {
      for (const child of node.children) {
        this.collectFilesNeedingUids(child, result);
      }
    }
  }
  async saveArrangementToNote(file, arrangement) {
    const readStart = performance.now();
    const content = await this.app.vault.read(file);
    if (PerfTimer.isEnabled()) {
      console.log(`[Perspecta]   \u2713 vault.read: ${(performance.now() - readStart).toFixed(1)}ms`);
    }
    const fmStart = performance.now();
    const newContent = this.updateFrontmatter(content, arrangement);
    if (PerfTimer.isEnabled()) {
      console.log(`[Perspecta]   \u2713 updateFrontmatter: ${(performance.now() - fmStart).toFixed(1)}ms`);
    }
    const writeStart = performance.now();
    await this.app.vault.modify(file, newContent);
    if (PerfTimer.isEnabled()) {
      console.log(`[Perspecta]   \u2713 vault.modify: ${(performance.now() - writeStart).toFixed(1)}ms`);
    }
  }
  updateFrontmatter(content, arrangement) {
    const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
    const match = content.match(frontmatterRegex);
    const encoded = this.encodeArrangement(arrangement);
    if (match) {
      let fm = match[1].replace(/perspecta-arrangement:[\s\S]*?(?=\n[^\s]|\n$|$)/g, "").replace(/perspecta-arrangement: ".*"/g, "").trim();
      fm = fm ? fm + "\n" + encoded : encoded;
      return content.replace(frontmatterRegex, `---
${fm}
---`);
    }
    return `---
${encoded}
---
${content}`;
  }
  // Encode arrangement as compact base64 JSON blob
  encodeArrangement(arr) {
    const compact = this.createCompactArrangement(arr);
    const json = JSON.stringify(compact);
    const base64 = btoa(unescape(encodeURIComponent(json)));
    return `${FRONTMATTER_KEY}: "${base64}"`;
  }
  // Create compact arrangement with minimal data
  createCompactArrangement(arr) {
    const compact = {
      v: arr.v,
      ts: arr.ts,
      f: arr.focusedWindow,
      // short key: focusedWindow
      m: this.compactWindow(arr.main)
      // short key: main
    };
    if (arr.popouts.length > 0) {
      compact.p = arr.popouts.map((p) => this.compactWindow(p));
    }
    if (arr.leftSidebar) {
      compact.ls = { c: arr.leftSidebar.collapsed };
      if (arr.leftSidebar.activeTab)
        compact.ls.t = arr.leftSidebar.activeTab;
    }
    if (arr.rightSidebar) {
      compact.rs = { c: arr.rightSidebar.collapsed };
      if (arr.rightSidebar.activeTab)
        compact.rs.t = arr.rightSidebar.activeTab;
    }
    if (arr.sourceScreen) {
      compact.ar = Math.round(arr.sourceScreen.aspectRatio * 100) / 100;
    }
    return compact;
  }
  compactWindow(win) {
    const compact = {
      r: this.compactNode(win.root)
      // short key: root
    };
    if (win.x !== void 0 && win.y !== void 0 && win.width !== void 0 && win.height !== void 0) {
      compact.g = [win.x, win.y, win.width, win.height];
    }
    return compact;
  }
  compactNode(node) {
    if (node.type === "tabs") {
      return node.tabs.map((tab) => {
        const arr = [tab.path];
        if (tab.uid)
          arr.push(tab.uid);
        else if (tab.active)
          arr.push(null);
        if (tab.active)
          arr.push(1);
        return arr.length === 1 ? tab.path : arr;
      });
    } else {
      return {
        d: node.direction === "horizontal" ? "h" : "v",
        c: node.children.map((child) => this.compactNode(child))
      };
    }
  }
  // Decode base64 JSON blob back to WindowArrangementV2
  decodeArrangement(encoded) {
    try {
      const json = decodeURIComponent(escape(atob(encoded)));
      const compact = JSON.parse(json);
      return this.expandCompactArrangement(compact);
    } catch (e) {
      console.error("[Perspecta] Failed to decode arrangement:", e);
      return null;
    }
  }
  expandCompactArrangement(compact) {
    var _a;
    const arr = {
      v: compact.v || 2,
      ts: compact.ts || Date.now(),
      focusedWindow: (_a = compact.f) != null ? _a : -1,
      main: this.expandWindow(compact.m),
      popouts: (compact.p || []).map((p) => this.expandWindow(p))
    };
    if (compact.ls) {
      arr.leftSidebar = { collapsed: compact.ls.c, activeTab: compact.ls.t };
    }
    if (compact.rs) {
      arr.rightSidebar = { collapsed: compact.rs.c, activeTab: compact.rs.t };
    }
    if (compact.ar) {
      arr.sourceScreen = {
        width: Math.round(1117 * compact.ar),
        // Use reference height
        height: 1117,
        aspectRatio: compact.ar
      };
    }
    return arr;
  }
  expandWindow(compact) {
    const win = {
      root: this.expandNode(compact.r)
    };
    if (compact.g) {
      win.x = compact.g[0];
      win.y = compact.g[1];
      win.width = compact.g[2];
      win.height = compact.g[3];
    }
    return win;
  }
  expandNode(compact) {
    if (Array.isArray(compact)) {
      const tabs = compact.map((item) => {
        var _a, _b;
        if (typeof item === "string") {
          return { path: item, active: false, name: (_a = item.split("/").pop()) == null ? void 0 : _a.replace(/\.md$/, "") };
        } else {
          const path = item[0];
          const uid = item[1] || void 0;
          const active = item[2] === 1;
          return { path, uid, active, name: (_b = path.split("/").pop()) == null ? void 0 : _b.replace(/\.md$/, "") };
        }
      });
      return { type: "tabs", tabs };
    } else {
      return {
        type: "split",
        direction: compact.d === "h" ? "horizontal" : "vertical",
        children: compact.c.map((child) => this.expandNode(child))
      };
    }
  }
  // Guard against concurrent restores
  async restoreContext(file, forceLatest = false) {
    if (this.isRestoring) {
      console.log("[Perspecta] Skipping restoreContext - already restoring");
      return;
    }
    this.isRestoring = true;
    const fullStart = performance.now();
    PerfTimer.begin("restoreContext");
    this.pathCorrections.clear();
    const targetFile = file != null ? file : this.app.workspace.getActiveFile();
    PerfTimer.mark("getActiveFile");
    if (!targetFile) {
      new import_obsidian3.Notice("No active file", 4e3);
      this.isRestoring = false;
      return;
    }
    try {
      const contextResult = await this.getContextForFileWithSelection(targetFile, forceLatest);
      PerfTimer.mark("getContextForFileWithSelection");
      if (!contextResult || contextResult.cancelled) {
        PerfTimer.end("restoreContext");
        return;
      }
      const context = contextResult.context;
      if (!context) {
        new import_obsidian3.Notice("No context found in this note", 4e3);
        return;
      }
      const focusedWin = await this.applyArrangement(context, targetFile.path);
      PerfTimer.mark("applyArrangement");
      if (this.pathCorrections.size > 0) {
        await this.updateContextWithCorrectedPaths(targetFile, context);
        PerfTimer.mark("updateContextWithCorrectedPaths");
      }
      PerfTimer.end("restoreContext");
      if (PerfTimer.isEnabled()) {
        requestIdleCallback(() => {
          const totalTime = performance.now() - fullStart;
          console.log(`[Perspecta] \u{1F3C1} Full restore (including render): ${totalTime.toFixed(0)}ms`);
        }, { timeout: 5e3 });
      }
    } finally {
      this.isRestoring = false;
    }
  }
  // Get context with potential user selection for multiple arrangements
  // If forceLatest is true, always use the most recent arrangement without showing selector
  async getContextForFileWithSelection(file, forceLatest = false) {
    if (file.extension === "canvas") {
      return { context: await getContextFromCanvas(this.app, file), cancelled: false };
    }
    if (file.extension === "base") {
      return { context: await getContextFromBase(this.app, file), cancelled: false };
    }
    if (this.settings.storageMode === "external") {
      const uid = getUidFromCache(this.app, file);
      if (uid) {
        if (!this.externalStore["initialized"]) {
          await this.externalStore.initialize();
        }
        const arrangements = this.externalStore.getAll(uid);
        if (arrangements.length === 0) {
          return { context: this.getContextFromNote(file), cancelled: false };
        }
        if (arrangements.length === 1 || forceLatest) {
          return { context: arrangements[0].arrangement, cancelled: false };
        }
        const result = await showArrangementSelector(
          arrangements,
          file.name,
          (savedAt) => {
            this.externalStore.deleteArrangement(uid, savedAt);
          }
        );
        if (result.cancelled) {
          return { context: null, cancelled: true };
        }
        return { context: result.arrangement.arrangement, cancelled: false };
      }
    }
    return { context: this.getContextFromNote(file), cancelled: false };
  }
  // Get context for file - handles markdown, canvas, base, and external storage
  async getContextForFile(file) {
    if (file.extension === "canvas") {
      return getContextFromCanvas(this.app, file);
    }
    if (file.extension === "base") {
      return getContextFromBase(this.app, file);
    }
    if (this.settings.storageMode === "external") {
      const uid = getUidFromCache(this.app, file);
      if (uid) {
        if (!this.externalStore["initialized"]) {
          await this.externalStore.initialize();
        }
        const context = this.externalStore.get(uid);
        if (context)
          return context;
      }
    }
    return this.getContextFromNote(file);
  }
  getContextFromNote(file) {
    var _a;
    const cache = this.app.metadataCache.getFileCache(file);
    const rawValue = (_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a[FRONTMATTER_KEY];
    if (!rawValue)
      return null;
    if (typeof rawValue === "string") {
      return this.decodeArrangement(rawValue);
    } else {
      return rawValue;
    }
  }
  // Update saved context with corrected file paths after fallback resolution
  async updateContextWithCorrectedPaths(contextFile, originalContext) {
    if (this.pathCorrections.size === 0)
      return;
    const correctedContext = this.captureWindowArrangement();
    correctedContext.ts = originalContext.ts;
    correctedContext.focusedWindow = originalContext.focusedWindow;
    const v2Original = this.normalizeToV2(originalContext);
    if (v2Original.sourceScreen) {
      correctedContext.sourceScreen = v2Original.sourceScreen;
    }
    if (contextFile.extension === "canvas") {
      await saveContextToCanvas(this.app, contextFile, correctedContext);
    } else if (contextFile.extension === "base") {
      await saveContextToBase(this.app, contextFile, correctedContext);
    } else if (this.settings.storageMode === "external") {
      const uid = getUidFromCache(this.app, contextFile);
      if (uid) {
        this.externalStore.set(uid, correctedContext);
      }
    } else {
      await this.saveArrangementToNote(contextFile, correctedContext);
    }
    if (PerfTimer.isEnabled()) {
      console.log(`[Perspecta] Updated context with ${this.pathCorrections.size} corrected paths:`);
      this.pathCorrections.forEach((correction, oldPath) => {
        console.log(`  ${oldPath} \u2192 ${correction.newPath}`);
      });
    }
  }
  async applyArrangement(arrangement, contextNotePath) {
    var _a, _b;
    try {
      PerfTimer.mark("applyArrangement:start");
      const v2 = this.normalizeToV2(arrangement);
      PerfTimer.mark("normalizeToV2");
      const useTiling = needsTiling(v2.sourceScreen);
      let tiledPositions = [];
      if (useTiling) {
        const windowCount = 1 + v2.popouts.length;
        tiledPositions = calculateTiledLayout(windowCount, v2.main);
        if (COORDINATE_DEBUG) {
          console.log(`[Perspecta] Using tiled layout due to aspect ratio mismatch:`, {
            sourceAspect: (_b = (_a = v2.sourceScreen) == null ? void 0 : _a.aspectRatio) == null ? void 0 : _b.toFixed(2),
            targetAspect: (getPhysicalScreen().width / getPhysicalScreen().height).toFixed(2),
            windowCount,
            tiledPositions
          });
        }
        new import_obsidian3.Notice(`Screen shape changed - tiling ${windowCount} windows`, 4e3);
      }
      PerfTimer.mark("checkTilingNeeded");
      const popoutWindows = this.getPopoutWindowObjects();
      PerfTimer.mark("getPopoutWindowObjects");
      for (const win of popoutWindows) {
        this.closePopoutWindow(win);
      }
      PerfTimer.mark("closePopoutWindows");
      const mainLeaves = this.getMainWindowLeaves();
      PerfTimer.mark("getMainWindowLeaves");
      for (let i = 1; i < mainLeaves.length; i++)
        mainLeaves[i].detach();
      PerfTimer.mark("detachExtraLeaves");
      if (useTiling && tiledPositions.length > 0) {
        this.restoreWindowGeometryDirect(window, tiledPositions[0]);
      } else {
        this.restoreWindowGeometry(window, v2.main, v2.sourceScreen);
      }
      PerfTimer.mark("restoreWindowGeometry");
      const workspace = this.app.workspace;
      await this.restoreWorkspaceNode(workspace.rootSplit, v2.main.root, mainLeaves[0]);
      PerfTimer.mark("restoreMainWorkspace");
      const restoredPaths = /* @__PURE__ */ new Set();
      for (let i = 0; i < v2.popouts.length; i++) {
        const firstTab = this.getFirstTab(v2.popouts[i].root);
        const popoutPath = firstTab == null ? void 0 : firstTab.path;
        if (popoutPath && restoredPaths.has(popoutPath)) {
          continue;
        }
        if (popoutPath) {
          restoredPaths.add(popoutPath);
        }
        const tiledPosition = useTiling && tiledPositions.length > i + 1 ? tiledPositions[i + 1] : void 0;
        await this.restorePopoutWindow(v2.popouts[i], v2.sourceScreen, tiledPosition);
        PerfTimer.mark(`restorePopout[${i}]`);
      }
      if (this.pendingTabActivations.length > 0) {
        requestAnimationFrame(() => {
          setTimeout(() => {
            this.processPendingTabActivations();
          }, 100);
        });
      }
      if (v2.leftSidebar)
        this.restoreSidebarState("left", v2.leftSidebar);
      if (v2.rightSidebar)
        this.restoreSidebarState("right", v2.rightSidebar);
      PerfTimer.mark("restoreSidebars");
      this.scheduleScrollRestoration(v2.main.root);
      for (const popout of v2.popouts) {
        this.scheduleScrollRestoration(popout.root);
      }
      PerfTimer.mark("scheduleScrollRestoration");
      let contextNoteWin = null;
      if (contextNotePath) {
        contextNoteWin = this.findWindowContainingFile(contextNotePath);
      }
      const focusedWin = contextNoteWin != null ? contextNoteWin : this.getFocusedWindow(v2);
      if (focusedWin) {
        if (contextNotePath && contextNoteWin) {
          this.activateLeafByPath(contextNoteWin, contextNotePath);
        } else {
          this.activateWindowLeaf(focusedWin, v2);
        }
        focusedWin.focus();
        this.showFocusTint(focusedWin);
      }
      PerfTimer.mark("activateFocusedWindow");
      return focusedWin;
    } catch (e) {
      new import_obsidian3.Notice("Error restoring context: " + e.message, 4e3);
      return null;
    }
  }
  getMainWindowLeaves() {
    const leaves = [];
    this.app.workspace.iterateAllLeaves((leaf) => {
      var _a, _b;
      const win = (_b = (_a = leaf.view) == null ? void 0 : _a.containerEl) == null ? void 0 : _b.win;
      if ((!win || win === window) && this.isInRootSplit(leaf)) {
        leaves.push(leaf);
      }
    });
    return leaves;
  }
  normalizeToV2(arr) {
    if (arr.v === 2)
      return arr;
    const v1 = arr;
    return {
      v: 2,
      ts: v1.ts,
      focusedWindow: v1.focusedWindow,
      main: { root: { type: "tabs", tabs: v1.main.tabs }, x: v1.main.x, y: v1.main.y, width: v1.main.width, height: v1.main.height },
      popouts: v1.popouts.map((p) => ({ root: { type: "tabs", tabs: p.tabs }, x: p.x, y: p.y, width: p.width, height: p.height })),
      leftSidebar: v1.leftSidebar,
      rightSidebar: v1.rightSidebar
    };
  }
  async restoreWorkspaceNode(parent, state, existingLeaf) {
    if (!(state == null ? void 0 : state.type)) {
      if ("tabs" in state)
        return this.restoreTabGroup(parent, { type: "tabs", tabs: state.tabs }, existingLeaf);
      return existingLeaf;
    }
    return state.type === "tabs" ? this.restoreTabGroup(parent, state, existingLeaf) : this.restoreSplit(parent, state, existingLeaf);
  }
  async restoreTabGroup(parent, state, existingLeaf) {
    var _a, _b, _c;
    if (!((_a = state.tabs) == null ? void 0 : _a.length))
      return existingLeaf;
    let activeTabIdx = state.tabs.findIndex((t) => t.active);
    if (activeTabIdx < 0)
      activeTabIdx = 0;
    const reorderedTabs = [];
    for (let i = 0; i < state.tabs.length; i++) {
      reorderedTabs.push({ tab: state.tabs[i], originalIndex: i });
    }
    reorderedTabs.sort((a, b) => {
      if (a.tab.active && !b.tab.active)
        return 1;
      if (!a.tab.active && b.tab.active)
        return -1;
      return a.originalIndex - b.originalIndex;
    });
    if (PerfTimer.isEnabled()) {
      console.log(`[Perspecta] restoreTabGroup: ${state.tabs.length} tabs, active at index ${activeTabIdx}`);
      console.log(`[Perspecta]   Opening order: ${reorderedTabs.map((r) => r.tab.name || r.tab.path).join(" \u2192 ")}`);
    }
    let firstLeaf;
    let container = null;
    let isFirstTabOpened = false;
    for (let i = 0; i < reorderedTabs.length; i++) {
      const { tab, originalIndex } = reorderedTabs[i];
      const tabStart = performance.now();
      const { file, method } = resolveFile(this.app, tab);
      if (!file) {
        if (PerfTimer.isEnabled()) {
          console.log(`[Perspecta]   \u2717 File not found: ${tab.path} (tried path, uid: ${tab.uid || "none"}, name: ${tab.name || "none"})`);
        }
        continue;
      }
      if (method !== "path") {
        this.pathCorrections.set(tab.path, {
          newPath: file.path,
          newName: file.basename
        });
        if (PerfTimer.isEnabled()) {
          console.log(`[Perspecta]   \u21AA Resolved ${tab.path} \u2192 ${file.path} (via ${method})`);
        }
      }
      let leaf;
      if (!isFirstTabOpened && existingLeaf) {
        await existingLeaf.openFile(file);
        leaf = existingLeaf;
        container = existingLeaf.parent;
        firstLeaf = leaf;
        isFirstTabOpened = true;
      } else if (!isFirstTabOpened) {
        leaf = this.app.workspace.createLeafInParent(parent, 0);
        await leaf.openFile(file);
        container = leaf.parent;
        firstLeaf = leaf;
        isFirstTabOpened = true;
      } else {
        if (!container)
          continue;
        leaf = this.app.workspace.createLeafInParent(container, (_c = (_b = container.children) == null ? void 0 : _b.length) != null ? _c : 0);
        await leaf.openFile(file);
      }
      const elapsed = performance.now() - tabStart;
      if (PerfTimer.isEnabled()) {
        const flag = elapsed > 50 ? "\u26A0 SLOW" : "\u2713";
        const methodSuffix = method !== "path" ? ` [${method}]` : "";
        console.log(`[Perspecta]   ${flag} openFile[${originalIndex}]: ${file.basename} - ${elapsed.toFixed(1)}ms${methodSuffix}${tab.active ? " [ACTIVE]" : ""}`);
      }
    }
    return firstLeaf;
  }
  /**
   * Restore a split structure.
   *
   * The challenge: Obsidian's getLeaf('split') creates splits at the LEAF level,
   * not at the container level. So if we have a horizontal container [A, B] and
   * split vertically from B, we get [A, vertical[B, C]] instead of vertical[[A,B], C].
   *
   * Solution: Use createLeafBySplit with the FIRST leaf of a nested structure.
   * When we split from the first leaf in a different direction, Obsidian properly
   * wraps the entire sibling group.
   *
   * For:
   *   vertical split
   *    horizontal split (A | B)
   *    C
   *
   * Order:
   * 1. Start with leaf (A)
   * 2. Build horizontal: split from A  B (now [A, B] in horizontal)
   * 3. Split vertically from A (FIRST leaf)  C
   *    This should wrap [A, B] as a unit
   */
  async restoreSplit(parent, state, existingLeaf) {
    var _a;
    if (!state.children.length)
      return existingLeaf;
    if (COORDINATE_DEBUG) {
      console.log(`[Perspecta] restoreSplit START: direction=${state.direction}, children=${state.children.length}, parent:`, {
        type: (_a = parent == null ? void 0 : parent.constructor) == null ? void 0 : _a.name,
        direction: parent == null ? void 0 : parent.direction
      });
    }
    if (parent && parent.direction !== state.direction) {
      parent.direction = state.direction;
      if (COORDINATE_DEBUG) {
        console.log(`[Perspecta] restoreSplit: changed parent direction to ${state.direction}`);
      }
    }
    let firstLeaf = existingLeaf;
    const firstChild = state.children[0];
    if (firstChild.type === "tabs") {
      const firstTab = firstChild.tabs[0];
      if (firstTab && existingLeaf) {
        const { file: f, method } = resolveFile(this.app, firstTab);
        if (f) {
          if (method !== "path") {
            this.pathCorrections.set(firstTab.path, { newPath: f.path, newName: f.basename });
          }
          await existingLeaf.openFile(f);
        }
      }
      if (firstChild.tabs.length > 1 && existingLeaf) {
        await this.restoreRemainingTabs(existingLeaf, firstChild.tabs, 1);
      }
      firstLeaf = existingLeaf;
    } else {
      firstLeaf = await this.buildNestedSplit(existingLeaf, firstChild);
    }
    for (let i = 1; i < state.children.length; i++) {
      const child = state.children[i];
      await new Promise((resolve) => setTimeout(resolve, 50));
      const newLeaf = this.app.workspace.createLeafBySplit(firstLeaf, state.direction);
      await new Promise((resolve) => setTimeout(resolve, 50));
      if (child.type === "tabs") {
        const firstTab = child.tabs[0];
        if (firstTab) {
          const { file: f, method } = resolveFile(this.app, firstTab);
          if (f) {
            if (method !== "path") {
              this.pathCorrections.set(firstTab.path, { newPath: f.path, newName: f.basename });
            }
            await newLeaf.openFile(f);
          }
        }
        if (child.tabs.length > 1) {
          await this.restoreRemainingTabs(newLeaf, child.tabs, 1);
        }
      } else {
        const firstTab = this.getFirstTabFromNode(child);
        if (firstTab) {
          const { file: f, method } = resolveFile(this.app, firstTab);
          if (f) {
            if (method !== "path") {
              this.pathCorrections.set(firstTab.path, { newPath: f.path, newName: f.basename });
            }
            await newLeaf.openFile(f);
          }
        }
        await this.buildNestedSplit(newLeaf, child);
      }
    }
    if (state.sizes && state.sizes.length > 0 && firstLeaf) {
      await this.applySplitSizes(firstLeaf, state.sizes);
    }
    if (COORDINATE_DEBUG) {
      console.log(`[Perspecta] restoreSplit END: direction=${state.direction}`);
    }
    return firstLeaf;
  }
  /**
   * Apply saved sizes to a split container.
   * Gets the parent container from any leaf and sets dimension on its children.
   */
  async applySplitSizes(anyLeaf, sizes) {
    var _a;
    await new Promise((resolve) => setTimeout(resolve, 200));
    let parent = anyLeaf.parent;
    let attempts = 0;
    const maxAttempts = 5;
    while (parent && attempts < maxAttempts) {
      if (((_a = parent.children) == null ? void 0 : _a.length) === sizes.length && parent.direction) {
        break;
      }
      parent = parent.parent;
      attempts++;
    }
    if (!(parent == null ? void 0 : parent.children) || parent.children.length !== sizes.length) {
      console.log(`[Perspecta] applySplitSizes: could not find matching parent - expected ${sizes.length} children`);
      return;
    }
    const total = sizes.reduce((a, b) => a + b, 0);
    const normalizedSizes = sizes.map((s) => s / total * 100);
    console.log(`[Perspecta] applySplitSizes: found parent with ${parent.children.length} children, direction=${parent.direction}, applying sizes:`, normalizedSizes);
    for (let i = 0; i < normalizedSizes.length; i++) {
      const child = parent.children[i];
      if (child && normalizedSizes[i] !== void 0) {
        if (typeof child.setDimension === "function") {
          child.setDimension(normalizedSizes[i]);
          console.log(`[Perspecta] applySplitSizes: called child[${i}].setDimension(${normalizedSizes[i]})`);
        } else {
          child.dimension = normalizedSizes[i];
          console.log(`[Perspecta] applySplitSizes: set child[${i}].dimension = ${normalizedSizes[i]}`);
        }
      }
    }
    if (typeof parent.onResize === "function") {
      parent.onResize();
      console.log(`[Perspecta] applySplitSizes: called parent.onResize()`);
    }
    const workspace = this.app.workspace;
    if (typeof workspace.requestResize === "function") {
      workspace.requestResize();
      console.log(`[Perspecta] applySplitSizes: called workspace.requestResize()`);
    }
    const rootSplit = workspace.rootSplit;
    if (rootSplit && typeof rootSplit.onResize === "function") {
      rootSplit.onResize();
      console.log(`[Perspecta] applySplitSizes: called rootSplit.onResize()`);
    }
    window.dispatchEvent(new Event("resize"));
    console.log(`[Perspecta] applySplitSizes: dispatched window resize event`);
  }
  /**
   * Apply scroll position to a leaf's view.
   * Must be called after the file is fully loaded.
   */
  applyScrollPosition(leaf, scroll) {
    if (scroll === void 0 || scroll === 0)
      return;
    setTimeout(() => {
      var _a;
      const view = leaf.view;
      if ((_a = view == null ? void 0 : view.currentMode) == null ? void 0 : _a.applyScroll) {
        view.currentMode.applyScroll(scroll);
        if (PerfTimer.isEnabled()) {
          console.log(`[Perspecta] applyScrollPosition: scrolled to ${scroll}`);
        }
      }
    }, 100);
  }
  /**
   * Collect scroll/viewport positions from a workspace node state and apply them to matching leaves.
   */
  scheduleScrollRestoration(state) {
    const scrollMap = /* @__PURE__ */ new Map();
    const canvasViewportMap = /* @__PURE__ */ new Map();
    this.collectViewPositions(state, scrollMap, canvasViewportMap);
    if (scrollMap.size === 0 && canvasViewportMap.size === 0)
      return;
    if (PerfTimer.isEnabled()) {
      console.log(`[Perspecta] scheduleScrollRestoration: ${scrollMap.size} scroll, ${canvasViewportMap.size} canvas viewports`);
    }
    setTimeout(() => {
      this.app.workspace.iterateAllLeaves((leaf) => {
        var _a, _b;
        const file = (_a = leaf.view) == null ? void 0 : _a.file;
        if (!file)
          return;
        if (scrollMap.has(file.path)) {
          const scroll = scrollMap.get(file.path);
          if (scroll !== void 0 && scroll > 0) {
            const view = leaf.view;
            if ((_b = view == null ? void 0 : view.currentMode) == null ? void 0 : _b.applyScroll) {
              view.currentMode.applyScroll(scroll);
              if (PerfTimer.isEnabled()) {
                console.log(`[Perspecta] scheduleScrollRestoration: ${file.basename} -> scroll ${scroll}`);
              }
            }
          }
        }
        if (canvasViewportMap.has(file.path)) {
          const viewport = canvasViewportMap.get(file.path);
          if (viewport) {
            this.restoreCanvasViewport(leaf, viewport);
          }
        }
      });
    }, 500);
  }
  collectViewPositions(node, scrollMap, canvasViewportMap) {
    if (node.type === "tabs") {
      for (const tab of node.tabs) {
        if (tab.scroll !== void 0 && tab.scroll > 0) {
          scrollMap.set(tab.path, tab.scroll);
        }
        if (tab.canvasViewport) {
          canvasViewportMap.set(tab.path, tab.canvasViewport);
        }
      }
    } else {
      for (const child of node.children) {
        this.collectViewPositions(child, scrollMap, canvasViewportMap);
      }
    }
  }
  /**
   * Restore canvas viewport (pan and zoom)
   */
  restoreCanvasViewport(leaf, viewport) {
    var _a, _b;
    const canvas = (_a = leaf.view) == null ? void 0 : _a.canvas;
    if (!canvas)
      return;
    try {
      const currentZoom = canvas.tZoom || 1;
      const zoomDelta = viewport.zoom / currentZoom;
      if (typeof canvas.zoomBy === "function") {
        canvas.zoomBy(zoomDelta);
      }
      if (typeof canvas.panTo === "function") {
        canvas.panTo(viewport.tx, viewport.ty);
      }
      if (typeof canvas.markViewportChanged === "function") {
        canvas.markViewportChanged();
      }
      if (typeof canvas.requestFrame === "function") {
        canvas.requestFrame();
      }
      if (PerfTimer.isEnabled()) {
        const file = (_b = leaf.view) == null ? void 0 : _b.file;
        console.log(`[Perspecta] restoreCanvasViewport: ${file == null ? void 0 : file.basename} -> tx=${viewport.tx.toFixed(0)}, ty=${viewport.ty.toFixed(0)}, zoom=${viewport.zoom.toFixed(2)}`);
      }
    } catch (e) {
      console.log("[Perspecta] Could not restore canvas viewport:", e);
    }
  }
  /**
   * Build a nested split structure starting from a leaf.
   * Returns the first leaf in the created structure.
   */
  async buildNestedSplit(startLeaf, state) {
    if (!state.children.length || !startLeaf) {
      return startLeaf;
    }
    if (COORDINATE_DEBUG) {
      console.log(`[Perspecta] buildNestedSplit: direction=${state.direction}, children=${state.children.length}`);
    }
    let firstLeaf = startLeaf;
    const firstChild = state.children[0];
    if (firstChild.type === "tabs") {
      const firstTab = firstChild.tabs[0];
      if (firstTab) {
        const { file: f, method } = resolveFile(this.app, firstTab);
        if (f) {
          if (method !== "path") {
            this.pathCorrections.set(firstTab.path, { newPath: f.path, newName: f.basename });
          }
          await startLeaf.openFile(f);
        }
      }
      if (firstChild.tabs.length > 1) {
        await this.restoreRemainingTabs(startLeaf, firstChild.tabs, 1);
      }
      firstLeaf = startLeaf;
    } else {
      const result = await this.buildNestedSplit(startLeaf, firstChild);
      if (result)
        firstLeaf = result;
    }
    for (let i = 1; i < state.children.length; i++) {
      const child = state.children[i];
      await new Promise((resolve) => setTimeout(resolve, 50));
      const newLeaf = this.app.workspace.createLeafBySplit(firstLeaf, state.direction);
      await new Promise((resolve) => setTimeout(resolve, 50));
      if (child.type === "tabs") {
        const firstTab = child.tabs[0];
        if (firstTab) {
          const { file: f, method } = resolveFile(this.app, firstTab);
          if (f) {
            if (method !== "path") {
              this.pathCorrections.set(firstTab.path, { newPath: f.path, newName: f.basename });
            }
            await newLeaf.openFile(f);
          }
        }
        if (child.tabs.length > 1) {
          await this.restoreRemainingTabs(newLeaf, child.tabs, 1);
        }
      } else {
        const firstTab = this.getFirstTabFromNode(child);
        if (firstTab) {
          const { file: f, method } = resolveFile(this.app, firstTab);
          if (f) {
            if (method !== "path") {
              this.pathCorrections.set(firstTab.path, { newPath: f.path, newName: f.basename });
            }
            await newLeaf.openFile(f);
          }
        }
        await this.buildNestedSplit(newLeaf, child);
      }
    }
    if (state.sizes && state.sizes.length > 0 && firstLeaf) {
      await this.applySplitSizes(firstLeaf, state.sizes);
    }
    return firstLeaf;
  }
  async restorePopoutWindow(state, sourceScreen, tiledPosition) {
    var _a, _b;
    const popoutStart = performance.now();
    if (state.isProxy && this.settings.enableProxyWindows) {
      await this.restoreProxyWindow(state, sourceScreen, tiledPosition);
      return;
    }
    const firstTab = this.getFirstTab(state.root);
    if (!firstTab)
      return;
    const { file, method } = resolveFile(this.app, firstTab);
    if (!file)
      return;
    if (method !== "path") {
      this.pathCorrections.set(firstTab.path, {
        newPath: file.path,
        newName: file.basename
      });
    }
    const openPopoutStart = performance.now();
    const popoutLeaf = this.app.workspace.openPopoutLeaf();
    if (PerfTimer.isEnabled()) {
      console.log(`[Perspecta]     \u2713 openPopoutLeaf: ${(performance.now() - openPopoutStart).toFixed(1)}ms`);
    }
    const openFileStart = performance.now();
    await popoutLeaf.openFile(file);
    if (PerfTimer.isEnabled()) {
      console.log(`[Perspecta]     \u2713 openFile (popout first): ${(performance.now() - openFileStart).toFixed(1)}ms`);
    }
    const win = (_b = (_a = popoutLeaf.view) == null ? void 0 : _a.containerEl) == null ? void 0 : _b.win;
    if (win) {
      if (tiledPosition) {
        this.restoreWindowGeometryDirect(win, tiledPosition);
      } else {
        this.restoreWindowGeometry(win, state, sourceScreen);
      }
    }
    if (state.root.type === "tabs") {
      await this.restorePopoutTabs(popoutLeaf, state.root.tabs);
    } else if (state.root.type === "split") {
      await this.restoreSplitOuterFirst(popoutLeaf, state.root);
    }
  }
  /**
   * Restore a proxy window (minimalist window showing just the note title)
   */
  async restoreProxyWindow(state, sourceScreen, tiledPosition) {
    var _a, _b;
    const firstTab = this.getFirstTab(state.root);
    if (!firstTab)
      return;
    const { file } = resolveFile(this.app, firstTab);
    if (!file)
      return;
    let arrangementUid;
    const uid = await getUidFromFile(this.app, file);
    if (uid) {
      arrangementUid = uid;
    }
    let initialWidth = 250;
    let initialHeight = 80;
    if (tiledPosition) {
      initialWidth = tiledPosition.width;
      initialHeight = tiledPosition.height;
    } else if (state.width !== void 0 && state.height !== void 0) {
      const physical = virtualToPhysical({
        x: state.x || 0,
        y: state.y || 0,
        width: state.width,
        height: state.height
      });
      initialWidth = physical.width;
      initialHeight = physical.height;
    }
    const proxyLeaf = this.app.workspace.openPopoutLeaf({
      size: { width: initialWidth, height: initialHeight }
    });
    await proxyLeaf.setViewState({
      type: PROXY_VIEW_TYPE,
      state: {
        filePath: file.path,
        arrangementUid
      }
    });
    await new Promise((resolve) => setTimeout(resolve, 100));
    const win = (_b = (_a = proxyLeaf.view) == null ? void 0 : _a.containerEl) == null ? void 0 : _b.win;
    if (win) {
      if (tiledPosition) {
        this.restoreWindowGeometryDirect(win, tiledPosition);
      } else {
        this.restoreWindowGeometry(win, state, sourceScreen);
      }
    }
    if (PerfTimer.isEnabled()) {
      console.log(`[Perspecta]     \u2713 restoreProxyWindow: ${file.basename}`);
    }
  }
  // Restore split using "outer-first" approach:
  // 1. First create all siblings at the current level
  // 2. Then recursively fill in any nested splits
  async restoreSplitOuterFirst(existingLeaf, state) {
    var _a;
    if (!state.children.length)
      return;
    if (COORDINATE_DEBUG) {
      console.log(`[Perspecta] restoreSplitOuterFirst: direction=${state.direction}, children=${state.children.length}`);
    }
    const leafSlots = [];
    leafSlots.push(existingLeaf);
    let lastLeaf = existingLeaf;
    for (let i = 1; i < state.children.length; i++) {
      this.app.workspace.setActiveLeaf(lastLeaf, { focus: false });
      const newLeaf = this.app.workspace.getLeaf("split", state.direction);
      const childFirstTab = this.getFirstTabFromNode(state.children[i]);
      if (childFirstTab) {
        const { file: f, method } = resolveFile(this.app, childFirstTab);
        if (f) {
          if (method !== "path") {
            this.pathCorrections.set(childFirstTab.path, {
              newPath: f.path,
              newName: f.basename
            });
          }
          await newLeaf.openFile(f);
        }
      }
      leafSlots.push(newLeaf);
      lastLeaf = newLeaf;
    }
    const firstTab = this.getFirstTabFromNode(state.children[0]);
    if (firstTab) {
      const { file: f, method } = resolveFile(this.app, firstTab);
      if (f) {
        if (method !== "path") {
          this.pathCorrections.set(firstTab.path, {
            newPath: f.path,
            newName: f.basename
          });
        }
        await existingLeaf.openFile(f);
      }
    }
    if (COORDINATE_DEBUG) {
      console.log(`[Perspecta] restoreSplitOuterFirst: created ${leafSlots.length} leaf slots`);
      leafSlots.forEach((leaf, idx) => {
        var _a2, _b;
        const path = ((_b = (_a2 = leaf == null ? void 0 : leaf.view) == null ? void 0 : _a2.file) == null ? void 0 : _b.path) || "unknown";
        console.log(`  slot[${idx}]: ${path}`);
      });
    }
    for (let i = 0; i < state.children.length; i++) {
      const child = state.children[i];
      const leafSlot = leafSlots[i];
      if (child.type === "tabs") {
        if (child.tabs.length > 1) {
          await this.restoreRemainingTabs(leafSlot, child.tabs, 1);
        }
      } else if (child.type === "split") {
        await this.restoreNestedSplitInPlace(leafSlot, child);
      }
    }
    if (((_a = state.sizes) == null ? void 0 : _a.length) && leafSlots.length > 0) {
      await this.applySplitSizes(leafSlots[0], state.sizes);
    }
  }
  // Restore a nested split within an existing leaf's position
  async restoreNestedSplitInPlace(leafSlot, state) {
    var _a, _b;
    if (state.children.length <= 1) {
      if (((_a = state.children[0]) == null ? void 0 : _a.type) === "tabs" && state.children[0].tabs.length > 1) {
        await this.restoreRemainingTabs(leafSlot, state.children[0].tabs, 1);
      }
      return;
    }
    if (COORDINATE_DEBUG) {
      console.log(`[Perspecta] restoreNestedSplitInPlace: direction=${state.direction}, children=${state.children.length}`);
    }
    const firstChild = state.children[0];
    if (firstChild.type === "tabs" && firstChild.tabs.length > 1) {
      await this.restoreRemainingTabs(leafSlot, firstChild.tabs, 1);
    } else if (firstChild.type === "split") {
      await this.restoreNestedSplitInPlace(leafSlot, firstChild);
    }
    let lastLeaf = leafSlot;
    for (let i = 1; i < state.children.length; i++) {
      const child = state.children[i];
      this.app.workspace.setActiveLeaf(lastLeaf, { focus: false });
      const newLeaf = this.app.workspace.getLeaf("split", state.direction);
      lastLeaf = newLeaf;
      const childFirstTab = this.getFirstTabFromNode(child);
      if (childFirstTab) {
        const { file: f, method } = resolveFile(this.app, childFirstTab);
        if (f) {
          if (method !== "path") {
            this.pathCorrections.set(childFirstTab.path, {
              newPath: f.path,
              newName: f.basename
            });
          }
          await newLeaf.openFile(f);
        }
      }
      if (child.type === "tabs" && child.tabs.length > 1) {
        await this.restoreRemainingTabs(newLeaf, child.tabs, 1);
      } else if (child.type === "split") {
        await this.restoreNestedSplitInPlace(newLeaf, child);
      }
    }
    if ((_b = state.sizes) == null ? void 0 : _b.length) {
      await this.applySplitSizes(leafSlot, state.sizes);
    }
  }
  // Get the first tab from any node (tabs or split) - returns full TabState for fallback resolution
  getFirstTabFromNode(node) {
    if (node.type === "tabs") {
      return node.tabs[0] || null;
    } else if (node.type === "split" && node.children.length > 0) {
      return this.getFirstTabFromNode(node.children[0]);
    }
    return null;
  }
  /**
   * Restore tabs in a popout window, preserving both tab ORDER and active state.
   *
   * Strategy:
   * 1. Open all tabs in the correct order (preserving visual tab order)
   * 2. Track which leaf corresponds to the active tab
   * 3. Schedule the active tab to be selected after the window is fully ready
   */
  async restorePopoutTabs(existingLeaf, tabs) {
    var _a, _b;
    if (tabs.length <= 1)
      return;
    let activeTabIndex = tabs.findIndex((t) => t.active);
    if (activeTabIndex < 0)
      activeTabIndex = 0;
    const container = existingLeaf.parent;
    if (!container)
      return;
    if (PerfTimer.isEnabled()) {
      console.log(`[Perspecta] restorePopoutTabs: ${tabs.length} tabs, active at index ${activeTabIndex}`);
    }
    const openedLeaves = [];
    openedLeaves.push(existingLeaf);
    for (let i = 1; i < tabs.length; i++) {
      const tab = tabs[i];
      const { file, method } = resolveFile(this.app, tab);
      if (!file) {
        if (PerfTimer.isEnabled()) {
          console.log(`[Perspecta]   \u2717 File not found: ${tab.path}`);
        }
        continue;
      }
      if (method !== "path") {
        this.pathCorrections.set(tab.path, {
          newPath: file.path,
          newName: file.basename
        });
      }
      const leaf = this.app.workspace.createLeafInParent(container, (_b = (_a = container.children) == null ? void 0 : _a.length) != null ? _b : 0);
      await leaf.openFile(file);
      openedLeaves.push(leaf);
      if (PerfTimer.isEnabled()) {
        console.log(`[Perspecta]   \u2713 Opened[${i}]: ${file.basename}`);
      }
    }
    const activeLeaf = openedLeaves[activeTabIndex];
    if (!activeLeaf)
      return;
    this.pendingTabActivations.push({
      container,
      activeTabIndex,
      activeLeaf
    });
    if (PerfTimer.isEnabled()) {
      console.log(`[Perspecta]   Queued tab activation for index ${activeTabIndex}`);
    }
  }
  /**
   * Process all pending tab activations after windows are fully initialized
   */
  processPendingTabActivations() {
    var _a;
    if (this.pendingTabActivations.length === 0)
      return;
    if (PerfTimer.isEnabled()) {
      console.log(`[Perspecta] Processing ${this.pendingTabActivations.length} pending tab activations`);
    }
    for (const { container, activeTabIndex, activeLeaf } of this.pendingTabActivations) {
      if (typeof container.currentTab !== "undefined") {
        container.currentTab = activeTabIndex;
        if (typeof container.updateTabDisplay === "function") {
          container.updateTabDisplay();
        }
        if (typeof container.onResize === "function") {
          container.onResize();
        }
      }
      if (typeof container.selectTab === "function") {
        container.selectTab(activeLeaf);
      }
      if ((_a = activeLeaf.view) == null ? void 0 : _a.containerEl) {
        activeLeaf.view.containerEl.focus();
      }
      if (PerfTimer.isEnabled()) {
        console.log(`[Perspecta]   Activated tab at index ${activeTabIndex}`);
      }
    }
    this.pendingTabActivations = [];
  }
  async restoreRemainingTabs(existingLeaf, tabs, startIndex) {
    var _a, _b;
    if (PerfTimer.isEnabled()) {
      console.log(`[Perspecta] restoreRemainingTabs: ${tabs.length} total tabs, starting from index ${startIndex}`);
    }
    let activeTabIndex = 0;
    for (let i = 0; i < tabs.length; i++) {
      if (tabs[i].active) {
        activeTabIndex = i;
        break;
      }
    }
    const parent = existingLeaf.parent;
    if (!parent)
      return;
    const tabsToOpen = [];
    for (let i = startIndex; i < tabs.length; i++) {
      tabsToOpen.push({ tab: tabs[i], index: i });
    }
    tabsToOpen.sort((a, b) => {
      if (a.tab.active && !b.tab.active)
        return 1;
      if (!a.tab.active && b.tab.active)
        return -1;
      return a.index - b.index;
    });
    const activeIsFirstTab = activeTabIndex === 0;
    for (const { tab, index } of tabsToOpen) {
      const { file, method } = resolveFile(this.app, tab);
      if (!file) {
        if (PerfTimer.isEnabled()) {
          console.log(`[Perspecta]   tab[${index}]: file not found for ${tab.path}`);
        }
        continue;
      }
      if (method !== "path") {
        this.pathCorrections.set(tab.path, {
          newPath: file.path,
          newName: file.basename
        });
      }
      const leaf = this.app.workspace.createLeafInParent(parent, (_b = (_a = parent.children) == null ? void 0 : _a.length) != null ? _b : 0);
      await leaf.openFile(file);
      if (PerfTimer.isEnabled()) {
        console.log(`[Perspecta]   tab[${index}]: opened ${file.basename}, active=${tab.active}`);
      }
    }
    if (activeIsFirstTab) {
      setTimeout(() => {
        this.app.workspace.setActiveLeaf(existingLeaf, { focus: false });
        if (PerfTimer.isEnabled()) {
          console.log(`[Perspecta]   Activated first tab (existingLeaf)`);
        }
      }, 100);
    }
  }
  getFirstTab(node) {
    if (node.type === "tabs")
      return node.tabs[0] || null;
    for (const child of node.children) {
      const tab = this.getFirstTab(child);
      if (tab)
        return tab;
    }
    return null;
  }
  closePopoutWindow(win) {
    const leaves = [];
    this.app.workspace.iterateAllLeaves((leaf) => {
      var _a, _b;
      if (((_b = (_a = leaf.view) == null ? void 0 : _a.containerEl) == null ? void 0 : _b.win) === win)
        leaves.push(leaf);
    });
    leaves.forEach((l) => l.detach());
  }
  getFocusedWindow(arr) {
    if (arr.focusedWindow === -1)
      return window;
    const popouts = this.getPopoutWindowObjects();
    const win = popouts[arr.focusedWindow];
    if (win && win.document.body.classList.contains("perspecta-proxy-window")) {
      return window;
    }
    return win != null ? win : window;
  }
  findWindowContainingFile(filePath) {
    let foundWin = null;
    this.app.workspace.iterateAllLeaves((leaf) => {
      var _a, _b, _c, _d, _e;
      if (!foundWin && ((_b = (_a = leaf.view) == null ? void 0 : _a.file) == null ? void 0 : _b.path) === filePath) {
        const win = (_e = (_d = (_c = leaf.view) == null ? void 0 : _c.containerEl) == null ? void 0 : _d.win) != null ? _e : window;
        if (win !== window && win.document.body.classList.contains("perspecta-proxy-window")) {
          return;
        }
        foundWin = win;
      }
    });
    return foundWin;
  }
  activateLeafByPath(win, filePath) {
    this.app.workspace.iterateAllLeaves((leaf) => {
      var _a, _b, _c, _d;
      if (((_b = (_a = leaf.view) == null ? void 0 : _a.containerEl) == null ? void 0 : _b.win) === win && ((_d = (_c = leaf.view) == null ? void 0 : _c.file) == null ? void 0 : _d.path) === filePath) {
        this.app.workspace.setActiveLeaf(leaf, { focus: false });
      }
    });
  }
  activateWindowLeaf(win, arr) {
    var _a;
    const start = performance.now();
    const root = win === window ? arr.main.root : (_a = arr.popouts[this.getPopoutWindowObjects().indexOf(win)]) == null ? void 0 : _a.root;
    if (!root)
      return;
    const activePath = this.findActiveTabPath(root);
    if (!activePath)
      return;
    let targetLeaf = null;
    this.app.workspace.iterateAllLeaves((leaf) => {
      var _a2, _b, _c, _d;
      if (!targetLeaf && ((_b = (_a2 = leaf.view) == null ? void 0 : _a2.containerEl) == null ? void 0 : _b.win) === win && ((_d = (_c = leaf.view) == null ? void 0 : _c.file) == null ? void 0 : _d.path) === activePath) {
        targetLeaf = leaf;
      }
    });
    if (targetLeaf) {
      this.app.workspace.setActiveLeaf(targetLeaf, { focus: false });
    }
    const elapsed = performance.now() - start;
    if (elapsed > 50) {
      console.warn(`[Perspecta] \u26A0 SLOW activateWindowLeaf: ${elapsed.toFixed(1)}ms`);
    }
  }
  findActiveTabPath(node) {
    var _a, _b;
    if (node.type === "tabs") {
      return ((_a = node.tabs.find((t) => t.active)) == null ? void 0 : _a.path) || ((_b = node.tabs[0]) == null ? void 0 : _b.path) || null;
    }
    for (const child of node.children) {
      const path = this.findActiveTabPath(child);
      if (path)
        return path;
    }
    return null;
  }
  restoreWindowGeometry(win, state, sourceScreen) {
    if (COORDINATE_DEBUG) {
      console.log(`[Perspecta] restoreWindowGeometry called`, {
        hasCoords: state.x !== void 0 && state.y !== void 0,
        hasSize: state.width !== void 0 && state.height !== void 0,
        state: { x: state.x, y: state.y, width: state.width, height: state.height },
        sourceScreen
      });
    }
    if (state.width === void 0 || state.height === void 0 || state.x === void 0 || state.y === void 0) {
      if (COORDINATE_DEBUG) {
        console.log(`[Perspecta] restoreWindowGeometry: missing coordinates, skipping`);
      }
      return;
    }
    const physical = virtualToPhysical({
      x: state.x,
      y: state.y,
      width: state.width,
      height: state.height
    }, sourceScreen);
    if (COORDINATE_DEBUG) {
      console.log(`[Perspecta] restoreWindowGeometry: applying`, physical);
    }
    try {
      win.resizeTo(physical.width, physical.height);
    } catch (e) {
    }
    try {
      win.moveTo(physical.x, physical.y);
    } catch (e) {
    }
  }
  // Apply geometry directly without virtual-to-physical conversion (used for tiled layouts)
  restoreWindowGeometryDirect(win, geometry) {
    if (COORDINATE_DEBUG) {
      console.log(`[Perspecta] restoreWindowGeometryDirect: applying`, geometry);
    }
    try {
      win.resizeTo(geometry.width, geometry.height);
    } catch (e) {
    }
    try {
      win.moveTo(geometry.x, geometry.y);
    } catch (e) {
    }
  }
  isInRootSplit(leaf) {
    var _a;
    const el = (_a = leaf.view) == null ? void 0 : _a.containerEl;
    return el ? !el.closest(".mod-left-split") && !el.closest(".mod-right-split") : true;
  }
  restoreSidebarState(side, state) {
    var _a, _b;
    try {
      const workspace = this.app.workspace;
      const sidebar = side === "left" ? workspace.leftSplit : workspace.rightSplit;
      if (!sidebar)
        return;
      if (state.collapsed) {
        (_a = sidebar.collapse) == null ? void 0 : _a.call(sidebar);
        return;
      }
      (_b = sidebar.expand) == null ? void 0 : _b.call(sidebar);
      const views = state.activeTab ? [state.activeTab, side === "left" ? "file-explorer" : "backlink"] : [side === "left" ? "file-explorer" : "backlink"];
      for (const viewType of views) {
        const leaves = this.app.workspace.getLeavesOfType(viewType);
        const leaf = leaves.find((l) => {
          var _a2, _b2;
          return (_b2 = (_a2 = l.view) == null ? void 0 : _a2.containerEl) == null ? void 0 : _b2.closest(side === "left" ? ".mod-left-split" : ".mod-right-split");
        });
        if (leaf) {
          this.app.workspace.revealLeaf(leaf);
          break;
        }
      }
    } catch (e) {
    }
  }
  showFocusTint(win) {
    const duration = this.settings.focusTintDuration;
    if (duration <= 0)
      return;
    if (win.document.body.classList.contains("perspecta-proxy-window")) {
      return;
    }
    const overlay = win.document.createElement("div");
    overlay.className = "perspecta-focus-tint";
    overlay.style.animationDuration = `${duration}s`;
    win.document.body.appendChild(overlay);
    overlay.addEventListener("animationend", () => overlay.remove());
    setTimeout(() => overlay.parentNode && overlay.remove(), duration * 1e3 + 500);
  }
  showNoticeInWindow(win, message, timeout = 4e3) {
    if (win && win !== window) {
      if (win.document.body.classList.contains("perspecta-proxy-window")) {
        new import_obsidian3.Notice(message, timeout);
        return;
      }
      const el = win.document.createElement("div");
      el.className = "notice";
      el.textContent = message;
      let container = win.document.body.querySelector(".notice-container");
      if (!container) {
        container = win.document.createElement("div");
        container.className = "notice-container";
        win.document.body.appendChild(container);
      }
      container.appendChild(el);
      setTimeout(() => el.remove(), timeout);
    } else {
      new import_obsidian3.Notice(message, timeout);
    }
  }
  // ============================================================================
  // Context Details View
  // ============================================================================
  async showContextDetails() {
    var _a, _b, _c;
    const file = this.app.workspace.getActiveFile();
    if (!file) {
      new import_obsidian3.Notice("No active file", 4e3);
      return;
    }
    const context = await this.getContextForFile(file);
    if (!context) {
      new import_obsidian3.Notice("No context found in this note", 4e3);
      return;
    }
    const activeLeaf = this.app.workspace.activeLeaf;
    const targetWindow = (_c = (_b = (_a = activeLeaf == null ? void 0 : activeLeaf.view) == null ? void 0 : _a.containerEl) == null ? void 0 : _b.win) != null ? _c : window;
    const v2 = this.normalizeToV2(context);
    this.showContextDetailsModal(v2, file.name, targetWindow);
  }
  showContextDetailsModal(context, fileName, targetWindow) {
    const doc = targetWindow.document;
    const overlay = doc.createElement("div");
    overlay.className = "perspecta-debug-overlay";
    const modal = doc.createElement("div");
    modal.className = "perspecta-debug-modal perspecta-details-modal";
    const h3 = modal.createEl("h3", { text: "Context Details" });
    const header = modal.createDiv({ cls: "perspecta-details-header" });
    header.createSpan({ cls: "perspecta-details-file", text: fileName });
    const date = new Date(context.ts);
    header.createSpan({ cls: "perspecta-details-date", text: date.toLocaleDateString() + " " + date.toLocaleTimeString() });
    const content = modal.createDiv({ cls: "perspecta-details-content" });
    const mainSection = content.createDiv({ cls: "perspecta-window-section" });
    mainSection.createDiv({ cls: "perspecta-window-title", text: "Main Window" });
    this.buildNodeDetailsDOM(mainSection, context.main.root, context.focusedWindow === -1);
    context.popouts.forEach((p, i) => {
      const popoutSection = content.createDiv({ cls: "perspecta-window-section" });
      popoutSection.createDiv({ cls: "perspecta-window-title", text: `Popout ${i + 1}` });
      this.buildNodeDetailsDOM(popoutSection, p.root, context.focusedWindow === i);
    });
    if (context.sourceScreen) {
      const ar = context.sourceScreen.aspectRatio;
      const screenType = ar > 2 ? "ultrawide" : ar > 1.7 ? "wide" : "standard";
      content.createDiv({ cls: "perspecta-screen-info", text: `Screen: ${screenType} (${ar.toFixed(2)})` });
    }
    const closeBtn = modal.createEl("button", { cls: "perspecta-details-close", text: "Close" });
    const closeModal = () => {
      modal.remove();
      overlay.remove();
    };
    overlay.onclick = closeModal;
    closeBtn.addEventListener("click", closeModal);
    doc.body.appendChild(overlay);
    doc.body.appendChild(modal);
  }
  buildNodeDetailsDOM(container, node, isFocusedWindow, sizePercent) {
    var _a;
    if (node.type === "tabs") {
      const tabList = container.createDiv({ cls: "perspecta-tab-list" });
      if (sizePercent) {
        tabList.createSpan({ cls: "perspecta-size-badge", text: sizePercent });
      }
      for (const t of node.tabs) {
        const name = ((_a = t.path.split("/").pop()) == null ? void 0 : _a.replace(/\.md$/, "")) || t.path;
        const folder = t.path.includes("/") ? t.path.split("/").slice(0, -1).join("/") : "";
        const classes = ["perspecta-tab-item"];
        if (t.active)
          classes.push("perspecta-tab-active");
        if (t.active && isFocusedWindow)
          classes.push("perspecta-tab-focused");
        const tabItem = tabList.createDiv({ cls: classes.join(" ") });
        tabItem.createSpan({ cls: "perspecta-tab-name", text: name });
        if (t.uid) {
          tabItem.createSpan({ cls: "perspecta-uid-badge", text: "uid", attr: { title: "Has UID for move/rename resilience" } });
        }
        if (folder) {
          tabItem.createSpan({ cls: "perspecta-tab-folder", text: folder });
        }
      }
    } else {
      const icon = node.direction === "horizontal" ? "\u2194" : "\u2195";
      const sizes = node.sizes;
      const total = (sizes == null ? void 0 : sizes.reduce((a, b) => a + b, 0)) || 0;
      const percentages = sizes == null ? void 0 : sizes.map((s) => total > 0 ? Math.round(s / total * 100) + "%" : void 0);
      const splitDiv = container.createDiv({ cls: "perspecta-split" });
      const splitHeader = splitDiv.createDiv({ cls: "perspecta-split-header" });
      splitHeader.appendText(`${icon} Split (${node.direction})`);
      if (sizePercent) {
        splitHeader.createSpan({ cls: "perspecta-size-badge", text: sizePercent });
      }
      const childrenDiv = splitDiv.createDiv({ cls: "perspecta-split-children" });
      node.children.forEach((child, i) => {
        this.buildNodeDetailsDOM(childrenDiv, child, isFocusedWindow, percentages == null ? void 0 : percentages[i]);
      });
    }
  }
  // ============================================================================
  // Debug Modal (Save Confirmation)
  // ============================================================================
  showContextDebugModal(context, fileName) {
    const overlay = document.createElement("div");
    overlay.className = "perspecta-debug-overlay";
    const modal = document.createElement("div");
    modal.className = "perspecta-debug-modal";
    modal.createEl("h3", { text: "Context Saved" });
    const fileP = modal.createEl("p");
    fileP.createEl("strong", { text: "File: " });
    fileP.appendText(fileName);
    const focusedP = modal.createEl("p");
    focusedP.createEl("strong", { text: "Focused: " });
    focusedP.appendText(context.focusedWindow === -1 ? "Main" : `Popout #${context.focusedWindow + 1}`);
    modal.createEl("h4", { text: "Main Window" });
    this.buildDebugNodeDOM(modal, context.main.root, 0);
    if (context.popouts.length) {
      modal.createEl("h4", { text: `Popouts (${context.popouts.length})` });
      context.popouts.forEach((p, i) => {
        modal.createEl("p", { text: `Popout #${i + 1}:` });
        this.buildDebugNodeDOM(modal, p.root, 0);
      });
    }
    const closeBtn = modal.createEl("button", { cls: "perspecta-debug-close", text: "Close" });
    const closeModal = () => {
      modal.remove();
      overlay.remove();
    };
    overlay.onclick = closeModal;
    closeBtn.addEventListener("click", closeModal);
    document.body.appendChild(overlay);
    document.body.appendChild(modal);
  }
  buildDebugNodeDOM(container, node, depth, sizePercent) {
    const wrapper = container.createDiv({ cls: `perspecta-debug-node perspecta-debug-depth-${depth}` });
    if (node.type === "tabs") {
      const header = wrapper.createSpan({ cls: "perspecta-debug-muted", text: "Tabs" });
      if (sizePercent) {
        header.createSpan({ cls: "perspecta-debug-size", text: ` (${sizePercent})` });
      }
      for (const t of node.tabs) {
        const tabLine = wrapper.createDiv({ cls: "perspecta-debug-tab" });
        tabLine.appendText(`\u{1F4C4} ${t.path.split("/").pop() || t.path}`);
        if (t.active)
          tabLine.appendText(" \u2713");
      }
    } else {
      const sizes = node.sizes;
      const total = (sizes == null ? void 0 : sizes.reduce((a, b) => a + b, 0)) || 0;
      const percentages = sizes == null ? void 0 : sizes.map((s) => total > 0 ? Math.round(s / total * 100) + "%" : void 0);
      const icon = node.direction === "horizontal" ? "\u2194\uFE0F" : "\u2195\uFE0F";
      const header = wrapper.createDiv();
      header.appendText(`${icon} `);
      header.createEl("strong", { text: "Split" });
      header.appendText(` (${node.direction})`);
      if (sizePercent) {
        header.createSpan({ cls: "perspecta-debug-size", text: ` (${sizePercent})` });
      }
      node.children.forEach((child, i) => {
        this.buildDebugNodeDOM(wrapper, child, depth + 1, percentages == null ? void 0 : percentages[i]);
      });
    }
  }
  // ============================================================================
  // Context Indicator
  // ============================================================================
  setupContextIndicator() {
    this.registerEvent(this.app.workspace.on("file-open", (file) => {
      if (this.isClosingWindow)
        return;
      this.updateContextIndicator(file);
    }));
    this.registerEvent(this.app.metadataCache.on("changed", (file) => {
      if (this.isClosingWindow)
        return;
      if (file === this.app.workspace.getActiveFile())
        this.updateContextIndicator(file);
      this.updateFileExplorerIndicator(file);
    }));
  }
  updateContextIndicator(file) {
    var _a, _b;
    PerfTimer.begin("updateContextIndicator");
    const allDocs = this.getAllWindowDocuments();
    for (const doc of allDocs) {
      doc.querySelectorAll(".view-header-title-container .perspecta-context-indicator").forEach((el) => el.remove());
    }
    PerfTimer.mark("removeOldIndicators");
    if (!file) {
      PerfTimer.end("updateContextIndicator");
      return;
    }
    const hasContextFrontmatter = ((_b = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter) == null ? void 0 : _b[FRONTMATTER_KEY]) != null;
    let hasContextExternal = false;
    if (this.settings.storageMode === "external") {
      const uid = getUidFromCache(this.app, file);
      if (uid && this.externalStore.has(uid)) {
        hasContextExternal = true;
      }
    }
    const hasContext = hasContextFrontmatter || hasContextExternal;
    PerfTimer.mark("checkHasContext");
    if (hasContext) {
      for (const doc of allDocs) {
        const header = doc.querySelector(".workspace-leaf.mod-active .view-header-title-container");
        if (header && !header.querySelector(".perspecta-context-indicator")) {
          const icon = this.createTargetIcon(doc);
          icon.setAttribute("aria-label", "Has saved context - click to restore");
          icon.addEventListener("click", () => this.restoreContext(file));
          header.appendChild(icon);
        }
      }
    }
    PerfTimer.end("updateContextIndicator");
  }
  /**
   * Get all window documents (main window + popouts)
   */
  getAllWindowDocuments() {
    const docs = [document];
    const workspace = this.app.workspace;
    const floatingSplit = workspace.floatingSplit;
    if (floatingSplit == null ? void 0 : floatingSplit.children) {
      for (const container of floatingSplit.children) {
        const win = container == null ? void 0 : container.win;
        if (win && win !== window && win.document) {
          docs.push(win.document);
        }
      }
    }
    return docs;
  }
  createTargetIcon(doc = document) {
    const el = doc.createElement("span");
    el.className = "perspecta-context-indicator";
    (0, import_obsidian3.setIcon)(el, "target");
    return el;
  }
  // ============================================================================
  // File Explorer Indicators
  // ============================================================================
  async setupFileExplorerIndicators() {
    var _a, _b;
    PerfTimer.begin("setupFileExplorerIndicators");
    const mdFiles = this.app.vault.getMarkdownFiles();
    PerfTimer.mark(`getMarkdownFiles (${mdFiles.length} files)`);
    for (const file of mdFiles) {
      if ((_b = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter) == null ? void 0 : _b[FRONTMATTER_KEY]) {
        this.filesWithContext.add(file.path);
      }
    }
    PerfTimer.mark("scanForContextFiles (frontmatter)");
    const canvasFiles = this.app.vault.getFiles().filter((f) => f.extension === "canvas");
    for (const file of canvasFiles) {
      if (await canvasHasContext(this.app, file)) {
        this.filesWithContext.add(file.path);
      }
    }
    PerfTimer.mark(`scanForContextFiles (canvas: ${canvasFiles.length} files)`);
    const baseFiles = this.app.vault.getFiles().filter((f) => f.extension === "base");
    for (const file of baseFiles) {
      if (await baseHasContext(this.app, file)) {
        this.filesWithContext.add(file.path);
      }
    }
    PerfTimer.mark(`scanForContextFiles (base: ${baseFiles.length} files)`);
    if (this.settings.storageMode === "external") {
      if (!this.externalStore["initialized"]) {
        await this.externalStore.initialize();
      }
      const uidsWithContext = this.externalStore.getAllUids();
      for (const file of mdFiles) {
        const uid = getUidFromCache(this.app, file);
        if (uid && uidsWithContext.includes(uid)) {
          this.filesWithContext.add(file.path);
        }
      }
      PerfTimer.mark("scanForContextFiles (external)");
    }
    this.registerEvent(this.app.workspace.on("layout-change", () => this.debouncedRefreshIndicators()));
    setTimeout(() => this.refreshFileExplorerIndicators(), 500);
    PerfTimer.end("setupFileExplorerIndicators");
  }
  async updateFileExplorerIndicator(file) {
    var _a, _b;
    let hasContext = false;
    if (file.extension === "canvas") {
      hasContext = await canvasHasContext(this.app, file);
    } else if (file.extension === "base") {
      hasContext = await baseHasContext(this.app, file);
    } else {
      hasContext = ((_b = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter) == null ? void 0 : _b[FRONTMATTER_KEY]) != null;
      if (!hasContext && this.settings.storageMode === "external") {
        const uid = getUidFromCache(this.app, file);
        if (uid && this.externalStore.has(uid)) {
          hasContext = true;
        }
      }
    }
    hasContext ? this.filesWithContext.add(file.path) : this.filesWithContext.delete(file.path);
    this.debouncedRefreshIndicators();
  }
  debouncedRefreshIndicators() {
    if (this.refreshIndicatorsTimeout)
      clearTimeout(this.refreshIndicatorsTimeout);
    this.refreshIndicatorsTimeout = setTimeout(() => {
      if (this.isClosingWindow) {
        this.refreshIndicatorsTimeout = null;
        return;
      }
      this.refreshFileExplorerIndicators();
      this.refreshIndicatorsTimeout = null;
    }, 100);
  }
  refreshFileExplorerIndicators() {
    PerfTimer.begin("refreshFileExplorerIndicators");
    document.querySelectorAll(".nav-file-title .perspecta-context-indicator").forEach((el) => el.remove());
    PerfTimer.mark("removeOldIndicators");
    this.filesWithContext.forEach((path) => {
      const el = document.querySelector(`.nav-file-title[data-path="${CSS.escape(path)}"]`);
      if (el && !el.querySelector(".perspecta-context-indicator")) {
        const icon = this.createTargetIcon();
        icon.setAttribute("aria-label", "Has saved context");
        el.insertBefore(icon, el.firstChild);
      }
    });
    PerfTimer.mark(`addIndicators (${this.filesWithContext.size} files)`);
    PerfTimer.end("refreshFileExplorerIndicators");
  }
  // ============================================================================
  // Utility
  // ============================================================================
  async openInNewWindow(file) {
    const leaf = this.app.workspace.openPopoutLeaf();
    await leaf.openFile(file);
  }
  /**
   * Convert a popout window to a minimalist proxy window (experimental)
   */
  async convertToProxyWindow(leaf, file) {
    var _a, _b;
    const win = leaf.view.containerEl.win;
    const x = (win == null ? void 0 : win.screenX) || 100;
    const y = (win == null ? void 0 : win.screenY) || 100;
    let arrangementUid;
    const uid = await getUidFromFile(this.app, file);
    if (uid && this.settings.storageMode === "external") {
      const arrangements = this.externalStore.getAll(uid);
      if (arrangements.length > 0) {
        arrangementUid = uid;
      }
    } else if (this.settings.storageMode === "frontmatter" && file.extension === "md") {
      const hasContext = await markdownHasContext(this.app, file);
      if (hasContext) {
        arrangementUid = uid || "frontmatter";
      }
    }
    leaf.detach();
    await new Promise((resolve) => setTimeout(resolve, 100));
    const proxyLeaf = this.app.workspace.openPopoutLeaf({
      size: { width: 250, height: 50 }
    });
    await proxyLeaf.setViewState({
      type: PROXY_VIEW_TYPE,
      state: {
        filePath: file.path,
        arrangementUid
      }
    });
    await new Promise((resolve) => setTimeout(resolve, 100));
    const newWin = (_b = (_a = proxyLeaf.view) == null ? void 0 : _a.containerEl) == null ? void 0 : _b.win;
    if (newWin && newWin !== window) {
      try {
        newWin.moveTo(x, y);
      } catch (e) {
      }
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    PerfTimer.setEnabled(this.settings.enableDebugLogging);
    COORDINATE_DEBUG = this.settings.enableDebugLogging;
  }
  async saveSettings() {
    await this.saveData(this.settings);
    PerfTimer.setEnabled(this.settings.enableDebugLogging);
    COORDINATE_DEBUG = this.settings.enableDebugLogging;
  }
};
var PerspectaSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.currentTab = "changelog";
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Perspecta", cls: "perspecta-settings-title" });
    const tabNav = containerEl.createDiv({ cls: "perspecta-settings-tabs" });
    const tabs = [
      { id: "changelog", label: "Changelog" },
      { id: "context", label: "Context" },
      { id: "storage", label: "Storage" },
      { id: "backup", label: "Backup" },
      { id: "experimental", label: "Experimental" },
      { id: "debug", label: "Debug" }
    ];
    tabs.forEach((tab) => {
      const tabEl = tabNav.createEl("button", {
        cls: `perspecta-settings-tab ${this.currentTab === tab.id ? "is-active" : ""}`,
        text: tab.label
      });
      tabEl.addEventListener("click", () => {
        this.currentTab = tab.id;
        this.display();
      });
    });
    switch (this.currentTab) {
      case "changelog":
        this.displayChangelog(containerEl);
        break;
      case "context":
        this.displayContextSettings(containerEl);
        break;
      case "storage":
        this.displayStorageSettings(containerEl);
        break;
      case "backup":
        this.displayBackupSettings(containerEl);
        break;
      case "experimental":
        this.displayExperimentalSettings(containerEl);
        break;
      case "debug":
        this.displayDebugSettings(containerEl);
        break;
    }
  }
  displayChangelog(containerEl) {
    renderChangelogToContainer(containerEl);
  }
  displayContextSettings(containerEl) {
    const saveHotkey = this.getHotkeyDisplay("perspecta-obsidian:save-context");
    const restoreHotkey = this.getHotkeyDisplay("perspecta-obsidian:restore-context");
    new import_obsidian3.Setting(containerEl).setName("Hotkeys").setDesc("Customize in Settings \u2192 Hotkeys").addButton((btn) => btn.setButtonText(`Save: ${saveHotkey}`).setDisabled(true)).addButton((btn) => btn.setButtonText(`Restore: ${restoreHotkey}`).setDisabled(true));
    new import_obsidian3.Setting(containerEl).setName("Seconds for focus note highlight").setDesc("0 = disabled").addText((t) => t.setValue(String(this.plugin.settings.focusTintDuration)).onChange(async (v) => {
      const n = parseFloat(v);
      if (!isNaN(n) && n >= 0) {
        this.plugin.settings.focusTintDuration = n;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian3.Setting(containerEl).setName("Auto-generate file UIDs").setDesc("Automatically add unique IDs to files in saved contexts. This allows files to be found even after moving or renaming.").addToggle((t) => t.setValue(this.plugin.settings.autoGenerateUids).onChange(async (v) => {
      this.plugin.settings.autoGenerateUids = v;
      await this.plugin.saveSettings();
    }));
  }
  displayStorageSettings(containerEl) {
    new import_obsidian3.Setting(containerEl).setName("Perspecta folder").setDesc("Folder in your vault for Perspecta data (backups, scripts). Created if it doesn't exist.").addText((t) => t.setPlaceholder("perspecta").setValue(this.plugin.settings.perspectaFolderPath).onChange(async (v) => {
      this.plugin.settings.perspectaFolderPath = v.trim() || "perspecta";
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Store window arrangements in frontmatter").setDesc("When enabled, context data is stored in note frontmatter (syncs with note). When disabled, context is stored externally in the plugin folder (keeps notes cleaner, requires perspecta-uid in frontmatter).").addToggle((t) => t.setValue(this.plugin.settings.storageMode === "frontmatter").onChange(async (v) => {
      this.plugin.settings.storageMode = v ? "frontmatter" : "external";
      await this.plugin.saveSettings();
      if (!v) {
        await this.plugin.externalStore.initialize();
      }
      this.display();
    }));
    if (this.plugin.settings.storageMode === "external") {
      new import_obsidian3.Setting(containerEl).setName("Maximum arrangements per note").setDesc("How many window arrangements to store per note. Older arrangements are automatically removed when the limit is reached.").addDropdown((d) => d.addOptions({
        "1": "1",
        "2": "2",
        "3": "3",
        "4": "4",
        "5": "5"
      }).setValue(String(this.plugin.settings.maxArrangementsPerNote)).onChange(async (v) => {
        this.plugin.settings.maxArrangementsPerNote = parseInt(v);
        await this.plugin.saveSettings();
        this.display();
      }));
      if (this.plugin.settings.maxArrangementsPerNote === 1) {
        new import_obsidian3.Setting(containerEl).setName("Auto-confirm overwrite").setDesc("Skip confirmation when overwriting an existing arrangement. Only applies when storing a single arrangement per note.").addToggle((t) => t.setValue(this.plugin.settings.autoConfirmOverwrite).onChange(async (v) => {
          this.plugin.settings.autoConfirmOverwrite = v;
          await this.plugin.saveSettings();
        }));
      }
    }
    if (this.plugin.settings.storageMode === "frontmatter") {
      new import_obsidian3.Setting(containerEl).setName("Migrate to external storage").setDesc("Move all context data from note frontmatter to the plugin folder. This cleans up your notes by removing perspecta-arrangement properties.").addButton((btn) => btn.setButtonText("Migrate to external").setCta().onClick(async () => {
        btn.setDisabled(true);
        btn.setButtonText("Migrating...");
        try {
          const result = await this.plugin.migrateToExternalStorage();
          new import_obsidian3.Notice(`Migration complete: ${result.migrated} contexts moved${result.errors > 0 ? `, ${result.errors} errors` : ""}`, 4e3);
          this.display();
        } catch (e) {
          new import_obsidian3.Notice("Migration failed: " + e.message, 4e3);
          btn.setDisabled(false);
          btn.setButtonText("Migrate to external");
        }
      }));
    } else {
      new import_obsidian3.Setting(containerEl).setName("Migrate to frontmatter").setDesc("Move all context data from the plugin folder into note frontmatter. This makes contexts portable with your notes.").addButton((btn) => btn.setButtonText("Migrate to frontmatter").setCta().onClick(async () => {
        btn.setDisabled(true);
        btn.setButtonText("Migrating...");
        try {
          const result = await this.plugin.migrateToFrontmatter();
          new import_obsidian3.Notice(`Migration complete: ${result.migrated} contexts moved${result.errors > 0 ? `, ${result.errors} errors` : ""}`, 4e3);
          this.display();
        } catch (e) {
          new import_obsidian3.Notice("Migration failed: " + e.message, 4e3);
          btn.setDisabled(false);
          btn.setButtonText("Migrate to frontmatter");
        }
      }));
    }
    new import_obsidian3.Setting(containerEl).setName("Clean up old uid properties").setDesc('Remove obsolete "uid" properties from notes that already have "perspecta-uid". This cleans up leftover data from earlier versions.').addButton((btn) => btn.setButtonText("Clean up").onClick(async () => {
      btn.setDisabled(true);
      btn.setButtonText("Cleaning...");
      try {
        const count = await this.plugin.cleanupOldUidProperties();
        new import_obsidian3.Notice(count > 0 ? `Cleaned up ${count} file${count > 1 ? "s" : ""}` : "No old uid properties found", 4e3);
      } catch (e) {
        new import_obsidian3.Notice("Cleanup failed: " + e.message, 4e3);
      }
      btn.setDisabled(false);
      btn.setButtonText("Clean up");
    }));
  }
  displayBackupSettings(containerEl) {
    new import_obsidian3.Setting(containerEl).setName("Backup arrangements").setDesc(`Create a backup of all stored arrangements to the ${this.plugin.settings.perspectaFolderPath}/backups folder.`).addButton((btn) => btn.setButtonText("Create backup").onClick(async () => {
      btn.setDisabled(true);
      btn.setButtonText("Backing up...");
      try {
        const result = await this.plugin.backupArrangements();
        new import_obsidian3.Notice(`Backup created: ${result.count} arrangements saved to ${result.path}`, 4e3);
        this.display();
      } catch (e) {
        new import_obsidian3.Notice("Backup failed: " + e.message, 4e3);
      }
      btn.setDisabled(false);
      btn.setButtonText("Create backup");
    }));
    new import_obsidian3.Setting(containerEl).setName("Restore from backup").setDesc("Restore arrangements from a previous backup. This will overwrite existing arrangements with the same UIDs.");
    const backupListContainer = containerEl.createDiv({ cls: "perspecta-backup-list-container" });
    this.plugin.listBackups().then((backups) => {
      if (backups.length === 0) {
        backupListContainer.createDiv({
          cls: "perspecta-backup-empty",
          text: "No backups available"
        });
      } else {
        backups.forEach((backup) => {
          const item = backupListContainer.createDiv({ cls: "perspecta-backup-item" });
          const info = item.createDiv({ cls: "perspecta-backup-info" });
          info.createDiv({ cls: "perspecta-backup-name", text: backup.name });
          info.createDiv({
            cls: "perspecta-backup-date",
            text: backup.date.toLocaleString()
          });
          const restoreBtn = item.createEl("button", {
            cls: "perspecta-backup-restore-btn",
            text: "Restore"
          });
          restoreBtn.addEventListener("click", async () => {
            restoreBtn.disabled = true;
            restoreBtn.textContent = "Restoring...";
            try {
              const result = await this.plugin.restoreFromBackup(backup.path);
              new import_obsidian3.Notice(`Restore complete: ${result.restored} arrangements restored${result.errors > 0 ? `, ${result.errors} errors` : ""}`, 4e3);
            } catch (e) {
              new import_obsidian3.Notice("Restore failed: " + e.message, 4e3);
            }
            restoreBtn.disabled = false;
            restoreBtn.textContent = "Restore";
          });
        });
      }
    });
  }
  displayExperimentalSettings(containerEl) {
    const warning = containerEl.createDiv({ cls: "perspecta-experimental-warning" });
    warning.createSpan({ cls: "perspecta-experimental-warning-icon", text: "\u26A0\uFE0F" });
    warning.createSpan({ text: "These features are experimental and may change or break in future updates." });
    new import_obsidian3.Setting(containerEl).setName("Enable proxy windows").setDesc('Allows converting popout windows to minimalist "proxy" windows that show only the note title. Click the title to restore its arrangement.').addToggle((t) => t.setValue(this.plugin.settings.enableProxyWindows).onChange(async (v) => {
      this.plugin.settings.enableProxyWindows = v;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.enableProxyWindows) {
      new import_obsidian3.Setting(containerEl).setName("Preview scale").setDesc("Scale factor for the note preview in proxy windows (10% to 100%)").addSlider((slider) => slider.setLimits(10, 100, 5).setValue(this.plugin.settings.proxyPreviewScale * 100).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.proxyPreviewScale = value / 100;
        await this.plugin.saveSettings();
      }));
      const infoDiv = containerEl.createDiv({ cls: "setting-item-description" });
      infoDiv.style.marginTop = "12px";
      infoDiv.style.marginBottom = "12px";
      infoDiv.innerHTML = `
				<strong>How to use:</strong><br>
				\u2022 Use command "Convert to proxy window" on any popout window<br>
				\u2022 The proxy shows a scaled preview of the note content<br>
				\u2022 Click the expand icon (\u2197) to restore the full window<br>
				\u2022 If the note has a saved arrangement, click anywhere to restore it
			`;
    }
  }
  displayDebugSettings(containerEl) {
    new import_obsidian3.Setting(containerEl).setName("Show debug modal on save").setDesc("Show a modal with context details when saving").addToggle((t) => t.setValue(this.plugin.settings.showDebugModal).onChange(async (v) => {
      this.plugin.settings.showDebugModal = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Enable debug logging").setDesc("Log performance timing to the developer console (Cmd+Shift+I)").addToggle((t) => t.setValue(this.plugin.settings.enableDebugLogging).onChange(async (v) => {
      this.plugin.settings.enableDebugLogging = v;
      await this.plugin.saveSettings();
    }));
  }
  getHotkeyDisplay(commandId) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const hotkeyManager = this.app.hotkeyManager;
    if (!hotkeyManager)
      return "Not set";
    const customHotkeys = (_a = hotkeyManager.customKeys) == null ? void 0 : _a[commandId];
    const defaultHotkeys = (_b = hotkeyManager.defaultKeys) == null ? void 0 : _b[commandId];
    const hotkeys = (customHotkeys == null ? void 0 : customHotkeys.length) ? customHotkeys : defaultHotkeys;
    if (!hotkeys || hotkeys.length === 0)
      return "Not set";
    const hotkey = hotkeys[0];
    const parts = [];
    const isMac = import_obsidian3.Platform.isMacOS;
    if ((_c = hotkey.modifiers) == null ? void 0 : _c.includes("Mod")) {
      parts.push(isMac ? "\u2318" : "Ctrl");
    }
    if ((_d = hotkey.modifiers) == null ? void 0 : _d.includes("Ctrl")) {
      parts.push(isMac ? "\u2303" : "Ctrl");
    }
    if ((_e = hotkey.modifiers) == null ? void 0 : _e.includes("Alt")) {
      parts.push(isMac ? "\u2325" : "Alt");
    }
    if ((_f = hotkey.modifiers) == null ? void 0 : _f.includes("Shift")) {
      parts.push(isMac ? "\u21E7" : "Shift");
    }
    if ((_g = hotkey.modifiers) == null ? void 0 : _g.includes("Meta")) {
      parts.push(isMac ? "\u2318" : "Win");
    }
    parts.push(((_h = hotkey.key) == null ? void 0 : _h.toUpperCase()) || "?");
    return parts.join(isMac ? "" : "+");
  }
};
