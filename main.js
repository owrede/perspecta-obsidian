/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PerspectaPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/utils/constants.ts
var TIMING = {
  // Window chrome configuration delays (in ms)
  CHROME_RETRY_DELAY_1: 50,
  CHROME_RETRY_DELAY_2: 150,
  CHROME_RETRY_DELAY_3: 300,
  // External store debounce delay (in ms)
  EXTERNAL_STORE_DEBOUNCE: 2e3,
  // UI delays (in ms)
  INDICATORS_REFRESH_DELAY: 500,
  WINDOW_SPLIT_DELAY: 100,
  SCROLL_RESTORATION_DELAY: 200,
  TAB_ACTIVATION_DELAY: 100,
  BRIEF_PAUSE_DELAY: 50,
  // Window restore delays (in ms)
  RESTORE_PAUSE_SHORT: 100,
  RESTORE_PAUSE_LONG: 200
};
var CSS_CLASSES = {
  PROXY_WINDOW: "perspecta-proxy-window",
  PROXY_WORKSPACE: "perspecta-proxy-workspace",
  PROXY_HEADER: "perspecta-proxy-header",
  PROXY_TITLE: "perspecta-proxy-title",
  PROXY_EXPAND: "perspecta-proxy-expand",
  PROXY_PREVIEW_WRAPPER: "perspecta-proxy-preview-wrapper",
  PROXY_PREVIEW_CONTENT: "perspecta-proxy-preview-content",
  CONTEXT_INDICATOR: "perspecta-context-indicator"
};
var EVENTS = {
  FOCUS: "focus",
  CLICK: "click",
  MOUSE_DOWN: "mousedown",
  MOUSE_ENTER: "mouseenter",
  MOUSE_LEAVE: "mouseleave",
  KEY_DOWN: "keydown",
  MOUSE_OVER: "mouseover",
  MOUSE_OUT: "mouseout"
};

// src/utils/async-utils.ts
function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function briefPause() {
  return delay(TIMING.BRIEF_PAUSE_DELAY);
}
function debounceAsync(fn, delay2) {
  let timeoutId = null;
  let pendingPromise = null;
  return (...args) => {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    pendingPromise = new Promise((resolve, reject) => {
      timeoutId = setTimeout(async () => {
        try {
          const result = await fn(...args);
          resolve(result);
        } catch (error) {
          reject(error);
        } finally {
          timeoutId = null;
          pendingPromise = null;
        }
      }, delay2);
    });
    return pendingPromise;
  };
}
function safeTimeout(callback, delay2) {
  const timeoutId = setTimeout(callback, delay2);
  return () => {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
  };
}

// src/types.ts
var DEFAULT_SETTINGS = {
  enableVisualMapping: true,
  enableAutomation: true,
  automationScriptsPath: "perspecta/scripts/",
  perspectaFolderPath: "perspecta",
  showDebugModal: true,
  showDebugModalOnRestore: true,
  enableDebugLogging: false,
  focusTintDuration: 8,
  autoGenerateUids: true,
  storageMode: "frontmatter",
  maxArrangementsPerNote: 1,
  autoConfirmOverwrite: false,
  // Experimental features
  enableProxyWindows: false,
  proxyPreviewScale: 0.35,
  enableWallpaperCapture: false,
  enableWallpaperRestore: false,
  storeWallpapersLocally: true,
  // Default to local storage for portability
  // Performance settings
  enableParallelPopoutCreation: false
  // Default to sequential for safety
};
var FRONTMATTER_KEY = "perspecta-arrangement";
var UID_FRONTMATTER_KEY = "perspecta-uid";

// src/types/obsidian-internal.ts
function asExtendedLeaf(leaf) {
  return leaf;
}
function hasFloatingSplit(workspace) {
  if (workspace === null || typeof workspace !== "object")
    return false;
  const ws = workspace;
  if (!("floatingSplit" in ws) || ws.floatingSplit === void 0 || ws.floatingSplit === null)
    return false;
  const fs = ws.floatingSplit;
  return Array.isArray(fs.children);
}
function isSplit(container) {
  return container !== null && typeof container === "object" && "direction" in container && "children" in container && Array.isArray(container.children);
}
function hasMetadataTypeManager(app) {
  if (app === null || typeof app !== "object")
    return false;
  const a = app;
  return "metadataTypeManager" in a && a.metadataTypeManager !== void 0 && a.metadataTypeManager !== null;
}
function hasFile(view) {
  if (view === null || typeof view !== "object")
    return false;
  const v = view;
  return "file" in v && v.file !== void 0 && v.file !== null;
}
function hasScrollableMode(view) {
  if (view === null || typeof view !== "object")
    return false;
  const v = view;
  if (!("currentMode" in v) || v.currentMode === void 0 || v.currentMode === null)
    return false;
  const mode = v.currentMode;
  return typeof mode.getScroll === "function" && typeof mode.applyScroll === "function";
}
function isCanvasView(view) {
  if (view === null || typeof view !== "object")
    return false;
  const v = view;
  if (!("canvas" in v) || v.canvas === void 0 || v.canvas === null)
    return false;
  const canvas = v.canvas;
  return typeof canvas.tx === "number";
}
function getFloatingWindowContainers(workspace) {
  if (hasFloatingSplit(workspace)) {
    return workspace.floatingSplit.children;
  }
  return [];
}
function getCurrentTabIndex(container) {
  if (container === null || typeof container !== "object")
    return 0;
  const c = container;
  if ("currentTab" in c && typeof c.currentTab === "number") {
    return c.currentTab;
  }
  return 0;
}
function getScrollPosition(view) {
  if (hasScrollableMode(view)) {
    return view.currentMode.getScroll();
  }
  return void 0;
}
function applyScrollPosition(view, position) {
  if (hasScrollableMode(view)) {
    view.currentMode.applyScroll(position);
    return true;
  }
  return false;
}
function getCanvasViewport(view) {
  if (isCanvasView(view)) {
    return view.canvas;
  }
  return void 0;
}
function setContainerDimension(container, dimension) {
  if (container === null || typeof container !== "object") {
    return false;
  }
  const c = container;
  if (typeof c.setDimension === "function") {
    c.setDimension(dimension);
    return true;
  }
  if ("dimension" in c) {
    c.dimension = dimension;
    return true;
  }
  return false;
}
function triggerWorkspaceResize(workspace, rootSplit) {
  let triggered = false;
  const ws = workspace;
  if (typeof ws.requestResize === "function") {
    ws.requestResize();
    triggered = true;
  }
  if (rootSplit && typeof rootSplit.onResize === "function") {
    rootSplit.onResize();
    triggered = true;
  }
  if (typeof window !== "undefined") {
    window.dispatchEvent(new Event("resize"));
    triggered = true;
  }
  return triggered;
}
function hasParent(obj) {
  return obj !== null && typeof obj === "object" && "parent" in obj;
}
function getLeafTabGroup(leaf) {
  var _a;
  if (leaf === null || typeof leaf !== "object")
    return null;
  const l = leaf;
  const tabGroup = (_a = l.tabGroup) != null ? _a : l.parent;
  if (tabGroup === null || typeof tabGroup !== "object")
    return null;
  return tabGroup;
}
function asExtendedWorkspace(workspace) {
  return workspace;
}

// src/utils/perf-timer.ts
var PerfTimer = class {
  static begin(operation) {
    if (!this.enabled)
      return;
    this.times = [];
    this.start = performance.now();
    this.lastMark = this.start;
    this.currentOperation = operation;
    console.log(`[Perspecta] \u25B6 ${operation} started at ${this.start.toFixed(0)}`);
  }
  static mark(label) {
    if (!this.enabled)
      return;
    const now = performance.now();
    const elapsed = now - this.lastMark;
    const fromStart = now - this.start;
    this.times.push({ label, elapsed, fromStart });
    this.lastMark = now;
    const flag = elapsed > 50 ? "\u26A0 SLOW" : "\u2713";
    console.log(`[Perspecta]   ${flag} ${label}: ${elapsed.toFixed(1)}ms (total: ${fromStart.toFixed(1)}ms)`);
  }
  static end(operation) {
    if (!this.enabled)
      return;
    const total = performance.now() - this.start;
    console.log(`[Perspecta] \u25FC ${operation} completed in ${total.toFixed(1)}ms`);
    if (this.times.length > 0) {
      console.log("[Perspecta] Full breakdown:");
      for (const t of this.times) {
        const flag = t.elapsed > 50 ? "\u26A0" : "\u2713";
        console.log(`  ${flag} ${t.label}: ${t.elapsed.toFixed(1)}ms (at ${t.fromStart.toFixed(1)}ms)`);
      }
    }
  }
  static async timeAsync(label, fn) {
    if (!this.enabled)
      return fn();
    const start = performance.now();
    try {
      return await fn();
    } finally {
      const elapsed = performance.now() - start;
      const fromStart = performance.now() - this.start;
      this.times.push({ label, elapsed, fromStart });
      const flag = elapsed > 50 ? "\u26A0 SLOW" : "\u2713";
      console.log(`[Perspecta]   ${flag} ${label}: ${elapsed.toFixed(1)}ms (total: ${fromStart.toFixed(1)}ms)`);
    }
  }
  static setEnabled(enabled) {
    this.enabled = enabled;
  }
  static isEnabled() {
    return this.enabled;
  }
};
PerfTimer.enabled = false;
PerfTimer.times = [];
PerfTimer.start = 0;
PerfTimer.lastMark = 0;
PerfTimer.currentOperation = "";

// src/utils/logger.ts
var config = {
  level: 1 /* ERROR */,
  prefix: "[Perspecta]"
};
function setLogLevel(level) {
  config.level = level;
}
function getLogLevel() {
  return config.level;
}
function enableDebugMode() {
  config.level = 4 /* DEBUG */;
}
function disableDebugMode() {
  config.level = 1 /* ERROR */;
}
function isDebugEnabled() {
  return config.level >= 4 /* DEBUG */;
}
function logError(message, ...args) {
  if (config.level >= 1 /* ERROR */) {
    console.error(`${config.prefix} ${message}`, ...args);
  }
}
function logWarn(message, ...args) {
  if (config.level >= 2 /* WARN */) {
    console.warn(`${config.prefix} ${message}`, ...args);
  }
}
function logInfo(message, ...args) {
  if (config.level >= 3 /* INFO */) {
    console.log(`${config.prefix} ${message}`, ...args);
  }
}
function logDebug(message, ...args) {
  if (config.level >= 4 /* DEBUG */) {
    console.log(`${config.prefix} [DEBUG] ${message}`, ...args);
  }
}
var Logger = {
  error: logError,
  warn: logWarn,
  info: logInfo,
  debug: logDebug,
  setLevel: setLogLevel,
  getLevel: getLogLevel,
  enableDebug: enableDebugMode,
  disableDebug: disableDebugMode,
  isDebugEnabled
};

// src/utils/coordinates.ts
var MIN_WINDOW_SIZE = 100;
var MAX_WINDOW_SIZE = 1e4;
var MAX_COORDINATE = 2e4;
var MIN_COORDINATE = -1e4;
function isValidNumber(n) {
  return typeof n === "number" && Number.isFinite(n) && !Number.isNaN(n);
}
function sanitizeGeometry(geometry, defaults = { x: 100, y: 100, width: 800, height: 600 }) {
  if (!geometry)
    return defaults;
  let { x, y, width, height } = geometry;
  x = isValidNumber(x) ? x : defaults.x;
  y = isValidNumber(y) ? y : defaults.y;
  width = isValidNumber(width) ? width : defaults.width;
  height = isValidNumber(height) ? height : defaults.height;
  width = Math.max(MIN_WINDOW_SIZE, Math.min(MAX_WINDOW_SIZE, width));
  height = Math.max(MIN_WINDOW_SIZE, Math.min(MAX_WINDOW_SIZE, height));
  x = Math.max(MIN_COORDINATE, Math.min(MAX_COORDINATE, x));
  y = Math.max(MIN_COORDINATE, Math.min(MAX_COORDINATE, y));
  return { x, y, width, height };
}
var VIRTUAL_SCREEN = {
  width: 1728,
  height: 1117
};
var coordinateDebug = false;
function setCoordinateDebug(enabled) {
  coordinateDebug = enabled;
}
var CENTER_ZONE_MIN = 0.15;
var CENTER_ZONE_MAX = 0.35;
var CENTER_SLOPE_MIN = 0.5;
var CENTER_SLOPE_MAX = 1;
var AR_RATIO_MAX = 1;
function calculateTransformParams(arSource, arTarget) {
  const r = Math.max(arSource, arTarget) / Math.min(arSource, arTarget);
  const d = r - 1;
  const s = Math.min(d / AR_RATIO_MAX, 1);
  const c = CENTER_ZONE_MIN + (CENTER_ZONE_MAX - CENTER_ZONE_MIN) * s;
  const b = CENTER_SLOPE_MAX - (CENTER_SLOPE_MAX - CENTER_SLOPE_MIN) * s;
  const a = (0.5 - b * c) / (0.5 - c);
  return { c, b, a };
}
function phiForward(u, params) {
  const { c, b, a } = params;
  u = Math.max(0, Math.min(1, u));
  if (u <= 0.5) {
    if (u <= 0.5 - c) {
      return a * u;
    } else {
      return b * (u - 0.5) + 0.5;
    }
  } else {
    return 1 - phiForward(1 - u, params);
  }
}
function phiInverse(y, params) {
  const { c, b, a } = params;
  y = Math.max(0, Math.min(1, y));
  const yC = 0.5 - b * c;
  if (y <= 0.5) {
    if (y <= yC) {
      return y / a;
    } else {
      return (y - 0.5) / b + 0.5;
    }
  } else {
    return 1 - phiInverse(1 - y, params);
  }
}
function getPhysicalScreen() {
  var _a, _b;
  const screen = window.screen;
  return {
    width: screen.availWidth,
    height: screen.availHeight,
    x: (_a = screen.availLeft) != null ? _a : 0,
    y: (_b = screen.availTop) != null ? _b : 0
  };
}
function physicalToVirtual(physical) {
  const screen = getPhysicalScreen();
  const arPhys = screen.width / screen.height;
  const arVirt = VIRTUAL_SCREEN.width / VIRTUAL_SCREEN.height;
  const params = calculateTransformParams(arPhys, arVirt);
  const useForward = arVirt >= arPhys;
  const phi = useForward ? phiForward : phiInverse;
  const uL = (physical.x - screen.x) / screen.width;
  const uR = (physical.x + physical.width - screen.x) / screen.width;
  const vL = phi(uL, params);
  const vR = phi(uR, params);
  const virtualX = vL * VIRTUAL_SCREEN.width;
  const virtualWidth = (vR - vL) * VIRTUAL_SCREEN.width;
  const scaleY = VIRTUAL_SCREEN.height / screen.height;
  const virtualY = (physical.y - screen.y) * scaleY;
  const virtualHeight = physical.height * scaleY;
  const result = {
    x: Math.round(virtualX),
    y: Math.round(virtualY),
    width: Math.round(virtualWidth),
    height: Math.round(virtualHeight)
  };
  if (coordinateDebug) {
    console.log(`[Perspecta] physicalToVirtual (non-linear):`, {
      physical,
      screen,
      virtualRef: VIRTUAL_SCREEN,
      aspectRatios: { physical: arPhys.toFixed(3), virtual: arVirt.toFixed(3) },
      transformParams: { c: params.c.toFixed(3), b: params.b.toFixed(3), a: params.a.toFixed(3) },
      normalized: { uL: uL.toFixed(3), uR: uR.toFixed(3), vL: vL.toFixed(3), vR: vR.toFixed(3) },
      result
    });
  }
  return result;
}
function virtualToPhysical(virtual, sourceScreen) {
  const safeVirtual = sanitizeGeometry(virtual);
  const screen = getPhysicalScreen();
  if (screen.width <= 0 || screen.height <= 0) {
    console.warn("[Perspecta] Invalid screen dimensions, using defaults");
    return { x: 100, y: 100, width: 800, height: 600 };
  }
  const arVirt = VIRTUAL_SCREEN.width / VIRTUAL_SCREEN.height;
  const arPhys = screen.width / screen.height;
  const params = calculateTransformParams(arVirt, arPhys);
  const useForward = arPhys >= arVirt;
  const phi = useForward ? phiForward : phiInverse;
  const uL = safeVirtual.x / VIRTUAL_SCREEN.width;
  const uR = (safeVirtual.x + safeVirtual.width) / VIRTUAL_SCREEN.width;
  const pL = phi(uL, params);
  const pR = phi(uR, params);
  let x = Math.round(screen.x + pL * screen.width);
  let width = Math.round((pR - pL) * screen.width);
  const scaleY = screen.height / VIRTUAL_SCREEN.height;
  let y = Math.round(screen.y + safeVirtual.y * scaleY);
  let height = Math.round(safeVirtual.height * scaleY);
  width = Math.max(MIN_WINDOW_SIZE, width);
  height = Math.max(MIN_WINDOW_SIZE, height);
  width = Math.min(width, screen.width);
  height = Math.min(height, screen.height);
  x = Math.max(screen.x, Math.min(x, screen.x + screen.width - width));
  y = Math.max(screen.y, Math.min(y, screen.y + screen.height - height));
  const result = { x, y, width, height };
  if (coordinateDebug) {
    console.log(`[Perspecta] virtualToPhysical (non-linear):`, {
      virtual: safeVirtual,
      screen,
      virtualRef: VIRTUAL_SCREEN,
      sourceScreen,
      aspectRatios: { virtual: arVirt.toFixed(3), physical: arPhys.toFixed(3) },
      transformParams: { c: params.c.toFixed(3), b: params.b.toFixed(3), a: params.a.toFixed(3) },
      normalized: { uL: uL.toFixed(3), uR: uR.toFixed(3), pL: pL.toFixed(3), pR: pR.toFixed(3) },
      result
    });
  }
  return result;
}
function getAspectRatioDifference(sourceScreen) {
  if (!sourceScreen)
    return 0;
  const targetScreen = getPhysicalScreen();
  const targetAspectRatio = targetScreen.width / targetScreen.height;
  return Math.abs(sourceScreen.aspectRatio - targetAspectRatio);
}
function needsTiling(sourceScreen) {
  if (!sourceScreen)
    return false;
  const diff = getAspectRatioDifference(sourceScreen);
  return diff > 0.5;
}
function calculateTiledLayout(windowCount, _mainWindowState) {
  const screen = getPhysicalScreen();
  const results = [];
  if (windowCount === 0)
    return results;
  if (windowCount === 1) {
    results.push({
      x: screen.x,
      y: screen.y,
      width: screen.width,
      height: screen.height
    });
    return results;
  }
  if (windowCount === 2) {
    const halfWidth = Math.floor(screen.width / 2);
    results.push({
      x: screen.x,
      y: screen.y,
      width: halfWidth,
      height: screen.height
    });
    results.push({
      x: screen.x + halfWidth,
      y: screen.y,
      width: screen.width - halfWidth,
      height: screen.height
    });
    return results;
  }
  const mainWidth = Math.floor(screen.width / 2);
  results.push({
    x: screen.x,
    y: screen.y,
    width: mainWidth,
    height: screen.height
  });
  const popoutCount = windowCount - 1;
  const popoutWidth = screen.width - mainWidth;
  const popoutHeight = Math.floor(screen.height / popoutCount);
  for (let i = 0; i < popoutCount; i++) {
    const isLast = i === popoutCount - 1;
    results.push({
      x: screen.x + mainWidth,
      y: screen.y + i * popoutHeight,
      width: popoutWidth,
      height: isLast ? screen.height - i * popoutHeight : popoutHeight
    });
  }
  return results;
}

// src/utils/wallpaper.ts
var import_obsidian = require("obsidian");
var import_child_process = require("child_process");
var import_util = require("util");
var import_promises = require("fs/promises");
var import_fs = require("fs");
var import_path = require("path");
var import_crypto = require("crypto");
var execFileAsync = (0, import_util.promisify)(import_child_process.execFile);
var VALID_IMAGE_EXTENSIONS = /* @__PURE__ */ new Set([
  ".jpg",
  ".jpeg",
  ".png",
  ".gif",
  ".bmp",
  ".tiff",
  ".tif",
  ".webp",
  ".heic",
  ".heif",
  ".avif"
]);
var MAX_PATH_LENGTH = 4096;
var SHELL_METACHARACTERS = /[`$\\!"';&|<>(){}[\]*?~#]/;
var DANGEROUS_PATH_PATTERNS = [
  /\0/,
  // Null byte injection
  /\.\.[/\\]/,
  // Directory traversal (../ or ..\)
  // eslint-disable-next-line no-control-regex
  /[\x00-\x1F]/
  // Control characters (except in file path segments)
];
function validatePath(path) {
  if (!path || typeof path !== "string" || path.trim().length === 0) {
    return { isValid: false, error: "Path is empty or invalid" };
  }
  if (path.length > MAX_PATH_LENGTH) {
    return { isValid: false, error: `Path exceeds maximum length of ${MAX_PATH_LENGTH} characters` };
  }
  for (const pattern of DANGEROUS_PATH_PATTERNS) {
    if (pattern.test(path)) {
      return { isValid: false, error: "Path contains invalid characters or patterns" };
    }
  }
  if (SHELL_METACHARACTERS.test(path)) {
    return { isValid: false, error: "Path contains characters not allowed in wallpaper paths" };
  }
  return { isValid: true };
}
function validateImageExtension(path) {
  const dotIndex = path.lastIndexOf(".");
  if (dotIndex === -1) {
    return { isValid: false, error: "Path has no file extension" };
  }
  const ext = path.toLowerCase().substring(dotIndex);
  if (!VALID_IMAGE_EXTENSIONS.has(ext)) {
    return {
      isValid: false,
      error: `Invalid image extension '${ext}'. Supported: ${Array.from(VALID_IMAGE_EXTENSIONS).join(", ")}`
    };
  }
  return { isValid: true };
}
function escapeAppleScript(path) {
  return path.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
}
async function getWallpaperMacOS() {
  try {
    const script = 'tell application "System Events" to get picture of desktop 1';
    const { stdout } = await execFileAsync("osascript", ["-e", script]);
    const path = stdout.trim();
    return path || null;
  } catch (e) {
    return null;
  }
}
async function setWallpaperMacOS(path) {
  const escapedPath = escapeAppleScript(path);
  const script = `tell application "System Events" to set picture of desktop 1 to "${escapedPath}"`;
  await execFileAsync("osascript", ["-e", script]);
}
async function getWallpaperWindows() {
  try {
    const psCommand = "(Get-ItemProperty -Path 'HKCU:\\Control Panel\\Desktop' -Name Wallpaper).Wallpaper";
    const { stdout } = await execFileAsync("powershell", ["-Command", psCommand]);
    const path = stdout.trim();
    return path || null;
  } catch (e) {
    return null;
  }
}
async function setWallpaperWindows(path) {
  const psScript = `
Add-Type -TypeDefinition @"
using System;
using System.Runtime.InteropServices;
public class Wallpaper {
    [DllImport("user32.dll", CharSet = CharSet.Auto)]
    public static extern int SystemParametersInfo(int uAction, int uParam, string lpvParam, int fuWinIni);
}
"@
[Wallpaper]::SystemParametersInfo(0x0014, 0, '${path.replace(/'/g, "''")}', 0x0001 -bor 0x0002)
`;
  await execFileAsync("powershell", ["-Command", psScript]);
}
async function getWallpaperLinux() {
  try {
    const { stdout } = await execFileAsync("gsettings", ["get", "org.gnome.desktop.background", "picture-uri"]);
    let path = stdout.trim();
    path = path.replace(/^'|'$/g, "");
    if (path.startsWith("file://")) {
      path = decodeURIComponent(path.substring(7));
    }
    return path || null;
  } catch (e) {
    return null;
  }
}
async function setWallpaperLinux(path) {
  const fileUri = `file://${encodeURIComponent(path).replace(/%2F/g, "/")}`;
  await execFileAsync("gsettings", ["set", "org.gnome.desktop.background", "picture-uri", fileUri]);
  try {
    await execFileAsync("gsettings", ["set", "org.gnome.desktop.background", "picture-uri-dark", fileUri]);
  } catch (e) {
  }
}
async function getWallpaper() {
  if (import_obsidian.Platform.isMobile) {
    return { success: false, error: "Wallpaper operations not supported on mobile" };
  }
  try {
    let path = null;
    if (import_obsidian.Platform.isMacOS) {
      path = await getWallpaperMacOS();
    } else if (import_obsidian.Platform.isWin) {
      path = await getWallpaperWindows();
    } else if (import_obsidian.Platform.isLinux) {
      path = await getWallpaperLinux();
    } else {
      return { success: false, error: "Platform not supported" };
    }
    if (!path) {
      return { success: false, error: "Could not retrieve wallpaper path" };
    }
    return { success: true, path };
  } catch (e) {
    const errorMessage = e instanceof Error ? e.message : String(e);
    return { success: false, error: errorMessage };
  }
}
async function setWallpaper(path) {
  if (import_obsidian.Platform.isMobile) {
    return { success: false, error: "Wallpaper operations not supported on mobile" };
  }
  const pathValidation = validatePath(path);
  if (!pathValidation.isValid) {
    return { success: false, error: pathValidation.error };
  }
  const extValidation = validateImageExtension(path);
  if (!extValidation.isValid) {
    return { success: false, error: extValidation.error };
  }
  try {
    if (import_obsidian.Platform.isMacOS) {
      await setWallpaperMacOS(path);
    } else if (import_obsidian.Platform.isWin) {
      await setWallpaperWindows(path);
    } else if (import_obsidian.Platform.isLinux) {
      await setWallpaperLinux(path);
    } else {
      return { success: false, error: "Platform not supported" };
    }
    return { success: true, path };
  } catch (e) {
    const errorMessage = e instanceof Error ? e.message : String(e);
    return { success: false, error: errorMessage };
  }
}
function getWallpaperPlatformNotes() {
  if (import_obsidian.Platform.isMacOS) {
    return "macOS: Changes apply to active desktop space only.";
  } else if (import_obsidian.Platform.isWin) {
    return "Windows: Full support via SystemParametersInfo API.";
  } else if (import_obsidian.Platform.isLinux) {
    return "Linux: GNOME desktop environments only (uses gsettings).";
  }
  return "Platform not supported for wallpaper operations.";
}
function hashPath(path) {
  return (0, import_crypto.createHash)("sha256").update(path).digest("hex").substring(0, 8);
}
async function copyWallpaperToLocal(sourcePath, destDir) {
  const pathValidation = validatePath(sourcePath);
  if (!pathValidation.isValid) {
    return { success: false, error: `Invalid source path: ${pathValidation.error}` };
  }
  const extValidation = validateImageExtension(sourcePath);
  if (!extValidation.isValid) {
    return { success: false, error: extValidation.error };
  }
  try {
    const sourceStats = await (0, import_promises.stat)(sourcePath);
    if (!sourceStats.isFile()) {
      return { success: false, error: "Source path is not a file" };
    }
    if (!(0, import_fs.existsSync)(destDir)) {
      await (0, import_promises.mkdir)(destDir, { recursive: true });
    }
    const originalName = (0, import_path.basename)(sourcePath, (0, import_path.extname)(sourcePath));
    const ext = (0, import_path.extname)(sourcePath);
    const pathHash = hashPath(sourcePath);
    const destFilename = `${originalName}_${pathHash}${ext}`;
    const destPath = (0, import_path.join)(destDir, destFilename);
    if ((0, import_fs.existsSync)(destPath)) {
      return { success: true, path: destPath };
    }
    await (0, import_promises.copyFile)(sourcePath, destPath);
    return { success: true, path: destPath };
  } catch (e) {
    const errorMessage = e instanceof Error ? e.message : String(e);
    return { success: false, error: `Failed to copy wallpaper: ${errorMessage}` };
  }
}
function getWallpapersDir(vaultPath, perspectaFolder = "perspecta") {
  return (0, import_path.join)(vaultPath, perspectaFolder, "wallpapers");
}

// src/utils/uid.ts
function generateUid() {
  if (typeof crypto !== "undefined" && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
function getUidFromCache(app, file) {
  var _a;
  const cache = app.metadataCache.getFileCache(file);
  return (_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a[UID_FRONTMATTER_KEY];
}
async function addUidToFile(app, file, uid) {
  const content = await app.vault.read(file);
  const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
  const match = content.match(frontmatterRegex);
  let newContent;
  if (match) {
    let fm = match[1];
    if (fm.includes(`${UID_FRONTMATTER_KEY}:`)) {
      if (fm.match(/^uid:\s*["']?[^"'\n]+["']?\s*$/m)) {
        fm = fm.replace(/^uid:\s*["']?[^"'\n]+["']?\n?/gm, "").trim();
        newContent = content.replace(frontmatterRegex, `---
${fm}
---`);
        await app.vault.modify(file, newContent);
      }
      return;
    }
    fm = fm.replace(/^uid:\s*["']?[^"'\n]+["']?\n?/gm, "").trim();
    const newFm = `${UID_FRONTMATTER_KEY}: "${uid}"
${fm}`;
    newContent = content.replace(frontmatterRegex, `---
${newFm}
---`);
  } else {
    newContent = `---
${UID_FRONTMATTER_KEY}: "${uid}"
---
${content}`;
  }
  await app.vault.modify(file, newContent);
}
async function cleanupOldUid(app, file) {
  const content = await app.vault.read(file);
  const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
  const match = content.match(frontmatterRegex);
  if (!match)
    return false;
  const fm = match[1];
  if (!fm.includes(`${UID_FRONTMATTER_KEY}:`))
    return false;
  if (!fm.match(/^uid:\s*["']?[^"'\n]+["']?\s*$/m))
    return false;
  const newFm = fm.replace(/^uid:\s*["']?[^"'\n]+["']?\n?/gm, "").trim();
  const newContent = content.replace(frontmatterRegex, `---
${newFm}
---`);
  if (newContent !== content) {
    await app.vault.modify(file, newContent);
    return true;
  }
  return false;
}

// src/utils/file-resolver.ts
var import_obsidian2 = require("obsidian");
var uidCache = /* @__PURE__ */ new Map();
var UID_CACHE_TTL = 6e4;
var SUPPORTED_EXTENSIONS = /* @__PURE__ */ new Set(["md", "canvas", "base"]);
function isValidPath(path) {
  if (!path || typeof path !== "string") {
    return false;
  }
  if (path.trim().length === 0) {
    return false;
  }
  if (path.includes("..")) {
    return false;
  }
  if (path.startsWith("/") || /^[A-Za-z]:/.test(path)) {
    return false;
  }
  return true;
}
function getUidFromCache2(app, file) {
  var _a;
  const cache = app.metadataCache.getFileCache(file);
  const uid = (_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a[UID_FRONTMATTER_KEY];
  return typeof uid === "string" ? uid : void 0;
}
function refreshUidCache(app) {
  const now = Date.now();
  for (const [uid, entry] of uidCache.entries()) {
    if (now - entry.timestamp > UID_CACHE_TTL) {
      uidCache.delete(uid);
    }
  }
  const files = app.vault.getMarkdownFiles();
  for (const file of files) {
    const uid = getUidFromCache2(app, file);
    if (uid) {
      uidCache.set(uid, { file, timestamp: now });
    }
  }
}
function resolveByUid(app, uid) {
  var _a;
  const cached = uidCache.get(uid);
  if (cached && Date.now() - cached.timestamp < UID_CACHE_TTL) {
    const exists = app.vault.getAbstractFileByPath(cached.file.path);
    if (exists instanceof import_obsidian2.TFile) {
      return cached.file;
    }
    uidCache.delete(uid);
  }
  refreshUidCache(app);
  const entry = uidCache.get(uid);
  return (_a = entry == null ? void 0 : entry.file) != null ? _a : null;
}
function resolveByName(app, name, extension) {
  if (!name) {
    return null;
  }
  const allFiles = app.vault.getFiles();
  const matches = allFiles.filter(
    (f) => f.basename === name && f.extension === extension
  );
  if (matches.length === 1) {
    return matches[0];
  }
  return null;
}
function resolveFile(app, tab) {
  if (!isValidPath(tab.path)) {
    return { file: null, method: "not_found", error: "Invalid path" };
  }
  const fileByPath = app.vault.getAbstractFileByPath(tab.path);
  if (fileByPath instanceof import_obsidian2.TFile) {
    return { file: fileByPath, method: "path" };
  }
  if (tab.uid) {
    const fileByUid = resolveByUid(app, tab.uid);
    if (fileByUid) {
      return { file: fileByUid, method: "uid" };
    }
  }
  if (tab.name) {
    const ext = tab.path.split(".").pop() || "md";
    if (SUPPORTED_EXTENSIONS.has(ext)) {
      const fileByName = resolveByName(app, tab.name, ext);
      if (fileByName) {
        return { file: fileByName, method: "name" };
      }
    }
  }
  return { file: null, method: "not_found", error: `File not found: ${tab.path}` };
}

// src/utils/base64.ts
function encodeBase64(str) {
  const encoder = new TextEncoder();
  const bytes = encoder.encode(str);
  const binString = Array.from(bytes, (byte) => String.fromCodePoint(byte)).join("");
  return btoa(binString);
}
function decodeBase64(base64) {
  const binString = atob(base64);
  const bytes = Uint8Array.from(binString, (char) => char.codePointAt(0));
  const decoder = new TextDecoder();
  return decoder.decode(bytes);
}

// src/storage/markdown.ts
function markdownHasContext(app, file) {
  var _a;
  if (file.extension !== "md")
    return false;
  const cache = app.metadataCache.getFileCache(file);
  return ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a[FRONTMATTER_KEY]) !== null;
}

// src/storage/canvas.ts
async function getUidFromCanvas(app, file) {
  var _a;
  if (file.extension !== "canvas")
    return void 0;
  try {
    const content = await app.vault.read(file);
    const data = JSON.parse(content);
    return (_a = data.perspecta) == null ? void 0 : _a.uid;
  } catch (e) {
    return void 0;
  }
}
async function getContextFromCanvas(app, file) {
  var _a, _b;
  if (file.extension !== "canvas")
    return null;
  try {
    const content = await app.vault.read(file);
    const data = JSON.parse(content);
    return (_b = (_a = data.perspecta) == null ? void 0 : _a.context) != null ? _b : null;
  } catch (e) {
    return null;
  }
}
async function saveContextToCanvas(app, file, context) {
  if (file.extension !== "canvas")
    return;
  try {
    const content = await app.vault.read(file);
    const data = JSON.parse(content);
    if (!data.perspecta) {
      data.perspecta = {};
    }
    data.perspecta.context = context;
    await app.vault.modify(file, JSON.stringify(data, null, "	"));
  } catch (e) {
    console.error("[Perspecta] Failed to save context to canvas:", e);
    throw e;
  }
}
async function canvasHasContext(app, file) {
  var _a;
  if (file.extension !== "canvas")
    return false;
  try {
    const content = await app.vault.read(file);
    const data = JSON.parse(content);
    return !!((_a = data.perspecta) == null ? void 0 : _a.context);
  } catch (e) {
    return false;
  }
}

// src/storage/base.ts
var import_obsidian3 = require("obsidian");
async function getUidFromBase(app, file) {
  var _a;
  if (file.extension !== "base")
    return void 0;
  try {
    const content = await app.vault.read(file);
    const data = (0, import_obsidian3.parseYaml)(content);
    return (_a = data == null ? void 0 : data.perspecta) == null ? void 0 : _a.uid;
  } catch (e) {
    return void 0;
  }
}
async function getContextFromBase(app, file) {
  var _a;
  if (file.extension !== "base")
    return null;
  try {
    const content = await app.vault.read(file);
    const data = (0, import_obsidian3.parseYaml)(content);
    const encoded = (_a = data == null ? void 0 : data.perspecta) == null ? void 0 : _a.context;
    if (!encoded)
      return null;
    const json = decodeBase64(encoded);
    return JSON.parse(json);
  } catch (e) {
    return null;
  }
}
async function saveContextToBase(app, file, context) {
  if (file.extension !== "base")
    return;
  try {
    const content = await app.vault.read(file);
    const data = content.trim() ? (0, import_obsidian3.parseYaml)(content) : {};
    if (!data.perspecta) {
      data.perspecta = {};
    }
    const json = JSON.stringify(context);
    const base64 = encodeBase64(json);
    data.perspecta.context = base64;
    await app.vault.modify(file, (0, import_obsidian3.stringifyYaml)(data));
  } catch (e) {
    console.error("[Perspecta] Failed to save context to base file:", e);
    throw e;
  }
}
async function baseHasContext(app, file) {
  var _a;
  if (file.extension !== "base")
    return false;
  try {
    const content = await app.vault.read(file);
    const data = (0, import_obsidian3.parseYaml)(content);
    return !!((_a = data == null ? void 0 : data.perspecta) == null ? void 0 : _a.context);
  } catch (e) {
    return false;
  }
}

// src/storage/external-store.ts
var CONTEXTS_FOLDER = "contexts";
function isArrangementCollection(data) {
  return typeof data === "object" && data !== null && "arrangements" in data && Array.isArray(data.arrangements);
}
var ExternalContextStore = class {
  constructor(config2) {
    this.cache = /* @__PURE__ */ new Map();
    this.dirty = /* @__PURE__ */ new Set();
    this.saveTimeoutCleanup = null;
    this.initialized = false;
    this.app = config2.app;
    this.manifest = config2.manifest;
    this.debouncedFlush = debounceAsync(async () => {
      await this.flushDirty();
    }, TIMING.EXTERNAL_STORE_DEBOUNCE);
  }
  get adapter() {
    return this.app.vault.adapter;
  }
  getContextsPath() {
    return `${this.manifest.dir}/${CONTEXTS_FOLDER}`;
  }
  async initialize() {
    var _a;
    if (this.initialized)
      return;
    const contextsPath = this.getContextsPath();
    try {
      if (!await this.adapter.exists(contextsPath)) {
        await this.adapter.mkdir(contextsPath);
      }
      const files = await this.adapter.list(contextsPath);
      for (const file of files.files) {
        if (file.endsWith(".json")) {
          try {
            const content = await this.adapter.read(file);
            const data = JSON.parse(content);
            const uid = (_a = file.split("/").pop()) == null ? void 0 : _a.replace(".json", "");
            if (uid && data) {
              if (isArrangementCollection(data)) {
                this.cache.set(uid, data);
              } else {
                const arrangement = data;
                const collection = {
                  arrangements: [{
                    arrangement,
                    savedAt: arrangement.ts || Date.now()
                  }]
                };
                this.cache.set(uid, collection);
                this.dirty.add(uid);
              }
            }
          } catch (e) {
            console.warn(`[Perspecta] Failed to load context file: ${file}`, e);
          }
        }
      }
      this.initialized = true;
      if (PerfTimer.isEnabled()) {
        console.log(`[Perspecta] External store initialized with ${this.cache.size} contexts`);
      }
    } catch (e) {
      console.error("[Perspecta] Failed to initialize external store:", e);
    }
  }
  // Get the most recent arrangement (for backward compatibility)
  get(uid) {
    const collection = this.cache.get(uid);
    if (!collection || collection.arrangements.length === 0)
      return null;
    return [...collection.arrangements].sort((a, b) => b.savedAt - a.savedAt);
  }
  // Get the latest arrangement only
  getLatest(uid) {
    const collection = this.cache.get(uid);
    if (!collection || collection.arrangements.length === 0)
      return null;
    const sorted = [...collection.arrangements].sort((a, b) => b.savedAt - a.savedAt);
    return sorted[0].arrangement;
  }
  // Get all arrangements for a UID
  getAll(uid) {
    const collection = this.cache.get(uid);
    if (!collection)
      return [];
    return [...collection.arrangements].sort((a, b) => b.savedAt - a.savedAt);
  }
  // Get arrangement count for a UID
  getCount(uid) {
    var _a;
    const collection = this.cache.get(uid);
    return (_a = collection == null ? void 0 : collection.arrangements.length) != null ? _a : 0;
  }
  has(uid) {
    const collection = this.cache.get(uid);
    return collection !== void 0 && collection.arrangements.length > 0;
  }
  // Add a new arrangement, respecting the max limit
  set(uid, context, maxArrangements = 1) {
    let collection = this.cache.get(uid);
    if (!collection) {
      collection = { arrangements: [] };
    }
    const timestamped = {
      arrangement: context,
      savedAt: Date.now()
    };
    collection.arrangements.push(timestamped);
    collection.arrangements.sort((a, b) => a.savedAt - b.savedAt);
    while (collection.arrangements.length > maxArrangements) {
      collection.arrangements.shift();
    }
    this.cache.set(uid, collection);
    this.dirty.add(uid);
    this.scheduleSave();
  }
  // Delete a specific arrangement by timestamp
  deleteArrangement(uid, savedAt) {
    const collection = this.cache.get(uid);
    if (!collection)
      return;
    collection.arrangements = collection.arrangements.filter((a) => a.savedAt !== savedAt);
    if (collection.arrangements.length === 0) {
      this.cache.delete(uid);
    } else {
      this.cache.set(uid, collection);
    }
    this.dirty.add(uid);
    this.scheduleSave();
  }
  async delete(uid) {
    this.cache.delete(uid);
    this.dirty.delete(uid);
    const filePath = `${this.getContextsPath()}/${uid}.json`;
    try {
      if (await this.adapter.exists(filePath)) {
        await this.adapter.remove(filePath);
      }
    } catch (e) {
      console.warn(`[Perspecta] Failed to delete context file: ${filePath}`, e);
    }
  }
  // Clear all arrangements for a specific UID (without deleting the file yet)
  clearUid(uid) {
    const collection = this.cache.get(uid);
    if (collection) {
      collection.arrangements = [];
      this.cache.set(uid, collection);
      this.dirty.add(uid);
    }
  }
  // Clear all arrangements (for overwrite restore mode)
  async clearAll() {
    const uids = Array.from(this.cache.keys());
    for (const uid of uids) {
      await this.delete(uid);
    }
    this.cache.clear();
    this.dirty.clear();
  }
  getAllUids() {
    return Array.from(this.cache.keys());
  }
  scheduleSave() {
    if (this.saveTimeoutCleanup) {
      this.saveTimeoutCleanup();
      this.saveTimeoutCleanup = null;
    }
    this.debouncedFlush().catch((error) => {
      console.error("[Perspecta] Failed to flush dirty data:", error);
    });
  }
  async flushDirty() {
    if (this.dirty.size === 0)
      return;
    const contextsPath = this.getContextsPath();
    if (!await this.adapter.exists(contextsPath)) {
      await this.adapter.mkdir(contextsPath);
    }
    const toSave = Array.from(this.dirty);
    this.dirty.clear();
    for (const uid of toSave) {
      const collection = this.cache.get(uid);
      const filePath = `${contextsPath}/${uid}.json`;
      if (collection && collection.arrangements.length > 0) {
        try {
          const json = JSON.stringify(collection);
          await this.adapter.write(filePath, json);
        } catch (e) {
          console.error(`[Perspecta] Failed to save context: ${uid}`, e);
          this.dirty.add(uid);
        }
      } else {
        try {
          if (await this.adapter.exists(filePath)) {
            await this.adapter.remove(filePath);
          }
        } catch (e) {
          console.warn(`[Perspecta] Failed to delete empty context file: ${filePath}`, e);
        }
      }
    }
    if (PerfTimer.isEnabled()) {
      console.log(`[Perspecta] Saved ${toSave.length} context(s) to disk`);
    }
  }
  async cleanup() {
    if (this.saveTimeoutCleanup) {
      this.saveTimeoutCleanup();
      this.saveTimeoutCleanup = null;
    }
    await this.flushDirty();
  }
  /**
   * Check if the store has been initialized.
   */
  isInitialized() {
    return this.initialized;
  }
  /**
   * Ensure the store is initialized before use.
   * Safe to call multiple times - will only initialize once.
   */
  async ensureInitialized() {
    if (!this.initialized) {
      await this.initialize();
    }
  }
};

// src/ui/modals.ts
var import_obsidian4 = require("obsidian");
var SVG_NS = "http://www.w3.org/2000/svg";
function generateArrangementPreview(arrangement, width, height) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  const arr = arrangement.arrangement;
  const svg = document.createElementNS(SVG_NS, "svg");
  svg.setAttribute("width", String(width));
  svg.setAttribute("height", String(height));
  svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
  svg.classList.add("perspecta-arrangement-preview");
  const padding = 2;
  const cornerRadius = 2;
  const screenWidth = (_b = (_a = arr.sourceScreen) == null ? void 0 : _a.width) != null ? _b : 1920;
  const screenHeight = (_d = (_c = arr.sourceScreen) == null ? void 0 : _c.height) != null ? _d : 1080;
  const availableWidth = width - padding * 2;
  const availableHeight = height - padding * 2;
  const scale = Math.min(availableWidth / screenWidth, availableHeight / screenHeight);
  const scaledScreenWidth = screenWidth * scale;
  const scaledScreenHeight = screenHeight * scale;
  const screenX = padding + (availableWidth - scaledScreenWidth) / 2;
  const screenY = padding + (availableHeight - scaledScreenHeight) / 2;
  const screenRect = createRect({
    x: screenX,
    y: screenY,
    width: scaledScreenWidth,
    height: scaledScreenHeight
  }, "var(--background-modifier-border)", "none", cornerRadius);
  svg.appendChild(screenRect);
  const windows = [];
  if (arr.main) {
    windows.push({ state: arr.main, isMain: true });
  }
  if (arr.popouts) {
    arr.popouts.forEach((p) => windows.push({ state: p, isMain: false }));
  }
  windows.forEach(({ state, isMain }) => {
    var _a2, _b2, _c2, _d2;
    const x = (_a2 = state.x) != null ? _a2 : 0;
    const y = (_b2 = state.y) != null ? _b2 : 0;
    const w = (_c2 = state.width) != null ? _c2 : 800;
    const h = (_d2 = state.height) != null ? _d2 : 600;
    const winRect = {
      x: screenX + x * scale,
      y: screenY + y * scale,
      width: w * scale,
      height: h * scale
    };
    const windowEl = createRect(
      winRect,
      "var(--background-primary)",
      "var(--background-primary-alt)",
      cornerRadius
    );
    windowEl.setAttribute("stroke-width", "1");
    svg.appendChild(windowEl);
    if (isMain) {
      const sidebarWidth = Math.max(5, winRect.width * 0.18);
      const sidebarPadding = 2;
      if (arr.leftSidebar && !arr.leftSidebar.collapsed) {
        const leftSidebar = createRect({
          x: winRect.x + sidebarPadding,
          y: winRect.y + sidebarPadding,
          width: sidebarWidth,
          height: winRect.height - sidebarPadding * 2
        }, "var(--background-modifier-border)", "none", 1);
        svg.appendChild(leftSidebar);
      }
      if (arr.rightSidebar && !arr.rightSidebar.collapsed) {
        const rightSidebar = createRect({
          x: winRect.x + winRect.width - sidebarWidth - sidebarPadding,
          y: winRect.y + sidebarPadding,
          width: sidebarWidth,
          height: winRect.height - sidebarPadding * 2
        }, "var(--background-modifier-border)", "none", 1);
        svg.appendChild(rightSidebar);
      }
    }
    if (state.root) {
      drawSplitLines(svg, state.root, winRect);
      drawTabAreas(svg, state.root, winRect);
    }
  });
  const focusedWindowIndex = (_e = arr.focusedWindow) != null ? _e : -1;
  let focusedState = null;
  if (focusedWindowIndex === -1 && arr.main) {
    focusedState = arr.main;
  } else if (focusedWindowIndex >= 0 && arr.popouts && arr.popouts[focusedWindowIndex]) {
    focusedState = arr.popouts[focusedWindowIndex];
  }
  if (focusedState == null ? void 0 : focusedState.root) {
    const x = (_f = focusedState.x) != null ? _f : 0;
    const y = (_g = focusedState.y) != null ? _g : 0;
    const w = (_h = focusedState.width) != null ? _h : 800;
    const h = (_i = focusedState.height) != null ? _i : 600;
    const winRect = {
      x: screenX + x * scale,
      y: screenY + y * scale,
      width: w * scale,
      height: h * scale
    };
    drawFocusHighlight(svg, focusedState.root, winRect, cornerRadius);
  }
  return svg;
}
function drawSplitLines(svg, node, bounds) {
  if (!node || node.type !== "split")
    return;
  const children = node.children || [];
  if (children.length < 2)
    return;
  const sizes = node.sizes || children.map(() => 1 / children.length);
  const direction = node.direction;
  const totalSize = sizes.reduce((a, b) => a + b, 0);
  const normalizedSizes = sizes.map((s) => s / totalSize);
  let offset = 0;
  children.forEach((child, i) => {
    const size = normalizedSizes[i] || 1 / children.length;
    if (i > 0) {
      const line = document.createElementNS(SVG_NS, "line");
      if (direction === "vertical") {
        const lineX = bounds.x + offset * bounds.width;
        line.setAttribute("x1", String(lineX));
        line.setAttribute("y1", String(bounds.y + 2));
        line.setAttribute("x2", String(lineX));
        line.setAttribute("y2", String(bounds.y + bounds.height - 2));
      } else {
        const lineY = bounds.y + offset * bounds.height;
        line.setAttribute("x1", String(bounds.x + 2));
        line.setAttribute("y1", String(lineY));
        line.setAttribute("x2", String(bounds.x + bounds.width - 2));
        line.setAttribute("y2", String(lineY));
      }
      line.setAttribute("stroke", "var(--text-muted)");
      line.setAttribute("stroke-width", "1");
      line.setAttribute("stroke-dasharray", "2,2");
      line.setAttribute("opacity", "0.6");
      svg.appendChild(line);
    }
    let childBounds;
    if (direction === "vertical") {
      childBounds = {
        x: bounds.x + offset * bounds.width,
        y: bounds.y,
        width: size * bounds.width,
        height: bounds.height
      };
    } else {
      childBounds = {
        x: bounds.x,
        y: bounds.y + offset * bounds.height,
        width: bounds.width,
        height: size * bounds.height
      };
    }
    drawSplitLines(svg, child, childBounds);
    offset += size;
  });
}
function drawFocusHighlight(svg, node, bounds, cornerRadius) {
  var _a;
  if (!node)
    return false;
  if (node.type === "tabs") {
    const hasActive = (_a = node.tabs) == null ? void 0 : _a.some((t) => t.active);
    if (hasActive) {
      const highlight = createRect(bounds, "none", "var(--interactive-accent)", cornerRadius);
      highlight.setAttribute("stroke-width", "1.5");
      svg.appendChild(highlight);
      return true;
    }
    return false;
  }
  if (node.type === "split") {
    const children = node.children || [];
    if (children.length === 0)
      return false;
    const sizes = node.sizes || children.map(() => 1 / children.length);
    const direction = node.direction;
    const totalSize = sizes.reduce((a, b) => a + b, 0);
    const normalizedSizes = sizes.map((s) => s / totalSize);
    let offset = 0;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      const size = normalizedSizes[i] || 1 / children.length;
      let childBounds;
      if (direction === "vertical") {
        childBounds = {
          x: bounds.x + offset * bounds.width,
          y: bounds.y,
          width: size * bounds.width,
          height: bounds.height
        };
      } else {
        childBounds = {
          x: bounds.x,
          y: bounds.y + offset * bounds.height,
          width: bounds.width,
          height: size * bounds.height
        };
      }
      if (drawFocusHighlight(svg, child, childBounds, cornerRadius)) {
        return true;
      }
      offset += size;
    }
  }
  return false;
}
function drawTabAreas(svg, node, bounds) {
  if (!node)
    return;
  if (node.type === "tabs") {
    const tabs = node.tabs || [];
    if (tabs.length === 0)
      return;
    const noteNames = tabs.map((tab) => {
      if (tab.name)
        return tab.name;
      const path = tab.path || "";
      const fileName = path.split("/").pop() || path;
      return fileName.replace(/\.md$/, "");
    });
    const activeIndex = tabs.findIndex((t) => t.active);
    let tooltipText;
    if (tabs.length === 1) {
      tooltipText = noteNames[0];
    } else {
      tooltipText = noteNames.map(
        (name, i) => i === activeIndex ? `\u25B8 ${name}` : `  ${name}`
      ).join("\n");
    }
    const area = document.createElementNS(SVG_NS, "rect");
    area.setAttribute("x", String(bounds.x));
    area.setAttribute("y", String(bounds.y));
    area.setAttribute("width", String(Math.max(0, bounds.width)));
    area.setAttribute("height", String(Math.max(0, bounds.height)));
    area.setAttribute("fill", "transparent");
    area.setAttribute("class", "perspecta-preview-tab-area");
    area.setAttribute("data-tooltip", tooltipText);
    svg.appendChild(area);
    return;
  }
  if (node.type === "split") {
    const children = node.children || [];
    if (children.length === 0)
      return;
    const sizes = node.sizes || children.map(() => 1 / children.length);
    const direction = node.direction;
    const totalSize = sizes.reduce((a, b) => a + b, 0);
    const normalizedSizes = sizes.map((s) => s / totalSize);
    let offset = 0;
    children.forEach((child, i) => {
      const size = normalizedSizes[i] || 1 / children.length;
      let childBounds;
      if (direction === "vertical") {
        childBounds = {
          x: bounds.x + offset * bounds.width,
          y: bounds.y,
          width: size * bounds.width,
          height: bounds.height
        };
      } else {
        childBounds = {
          x: bounds.x,
          y: bounds.y + offset * bounds.height,
          width: bounds.width,
          height: size * bounds.height
        };
      }
      drawTabAreas(svg, child, childBounds);
      offset += size;
    });
  }
}
function setupPreviewTooltips(container, doc) {
  let tooltip = null;
  const showTooltip = (e) => {
    const target = e.target;
    const text = target.getAttribute("data-tooltip");
    if (!text)
      return;
    if (tooltip)
      tooltip.remove();
    tooltip = doc.createElement("div");
    tooltip.className = "perspecta-preview-tooltip";
    tooltip.textContent = text;
    doc.body.appendChild(tooltip);
    const rect = target.getBoundingClientRect();
    tooltip.style.left = `${rect.right + 8}px`;
    tooltip.style.top = `${rect.top}px`;
    const tooltipRect = tooltip.getBoundingClientRect();
    if (tooltipRect.right > doc.documentElement.clientWidth) {
      tooltip.style.left = `${rect.left - tooltipRect.width - 8}px`;
    }
    if (tooltipRect.bottom > doc.documentElement.clientHeight) {
      tooltip.style.top = `${doc.documentElement.clientHeight - tooltipRect.height - 8}px`;
    }
  };
  const hideTooltip = () => {
    if (tooltip) {
      tooltip.remove();
      tooltip = null;
    }
  };
  container.addEventListener("mouseover", (e) => {
    if (e.target.classList.contains("perspecta-preview-tab-area")) {
      showTooltip(e);
    }
  });
  container.addEventListener("mouseout", (e) => {
    if (e.target.classList.contains("perspecta-preview-tab-area")) {
      hideTooltip();
    }
  });
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      mutation.removedNodes.forEach((node) => {
        var _a;
        if (node === container || ((_a = node.contains) == null ? void 0 : _a.call(node, container))) {
          hideTooltip();
          observer.disconnect();
        }
      });
    });
  });
  observer.observe(doc.body, { childList: true, subtree: true });
}
function createRect(rect, fill, stroke, rx) {
  const rectEl = document.createElementNS(SVG_NS, "rect");
  rectEl.setAttribute("x", String(rect.x));
  rectEl.setAttribute("y", String(rect.y));
  rectEl.setAttribute("width", String(Math.max(0, rect.width)));
  rectEl.setAttribute("height", String(Math.max(0, rect.height)));
  rectEl.setAttribute("fill", fill);
  rectEl.setAttribute("stroke", stroke);
  rectEl.setAttribute("rx", String(rx));
  return rectEl;
}
function formatTimestamp(ts) {
  const date = new Date(ts);
  const now = new Date();
  const isToday = date.toDateString() === now.toDateString();
  const yesterday = new Date(now);
  yesterday.setDate(yesterday.getDate() - 1);
  const isYesterday = date.toDateString() === yesterday.toDateString();
  const timeStr = date.toLocaleTimeString(void 0, {
    hour: "2-digit",
    minute: "2-digit"
  });
  if (isToday) {
    return `Today at ${timeStr}`;
  } else if (isYesterday) {
    return `Yesterday at ${timeStr}`;
  } else {
    const dateStr = date.toLocaleDateString(void 0, {
      month: "short",
      day: "numeric",
      year: date.getFullYear() !== now.getFullYear() ? "numeric" : void 0
    });
    return `${dateStr} at ${timeStr}`;
  }
}
function getArrangementSummary(arrangement) {
  var _a, _b, _c, _d;
  const arr = arrangement.arrangement;
  const windowCount = 1 + ((_b = (_a = arr.popouts) == null ? void 0 : _a.length) != null ? _b : 0);
  let tabCount = 0;
  const countTabs = (node) => {
    if (!node || typeof node !== "object")
      return;
    const n = node;
    if (n.type === "tabs" && Array.isArray(n.tabs)) {
      tabCount += n.tabs.length;
    } else if (n.type === "split" && Array.isArray(n.children)) {
      n.children.forEach(countTabs);
    }
  };
  countTabs((_c = arr.main) == null ? void 0 : _c.root);
  (_d = arr.popouts) == null ? void 0 : _d.forEach((p) => countTabs(p.root));
  const windowText = windowCount === 1 ? "1 window" : `${windowCount} windows`;
  const tabText = tabCount === 1 ? "1 tab" : `${tabCount} tabs`;
  return `${windowText}, ${tabText}`;
}
function showArrangementSelector(arrangements, fileName, onDelete, targetWindow = window) {
  return new Promise((resolve) => {
    const doc = targetWindow.document;
    const overlay = doc.createElement("div");
    overlay.className = "perspecta-debug-overlay";
    const modal = doc.createElement("div");
    modal.className = "perspecta-arrangement-selector";
    const title = modal.createDiv({ cls: "perspecta-modal-title" });
    title.setText(`Select Arrangement - ${fileName}`);
    const subtitle = modal.createDiv({ cls: "perspecta-modal-subtitle" });
    const updateSubtitle = (count) => {
      subtitle.setText(`${count} saved arrangement${count > 1 ? "s" : ""}`);
    };
    updateSubtitle(arrangements.length);
    const list = modal.createDiv({ cls: "perspecta-arrangement-list" });
    const sorted = [...arrangements].sort((a, b) => b.savedAt - a.savedAt);
    const cleanup = () => {
      modal.remove();
      overlay.remove();
    };
    const renderList = () => {
      list.empty();
      const remaining = sorted.filter((a) => !deletedTimestamps.has(a.savedAt));
      updateSubtitle(remaining.length);
      if (remaining.length === 0) {
        cleanup();
        resolve({ arrangement: sorted[0], cancelled: true });
        return;
      }
      remaining.forEach((arr, index) => {
        const item = list.createDiv({ cls: "perspecta-arrangement-item" });
        const previewContainer = item.createDiv({ cls: "perspecta-arrangement-preview-container" });
        const preview = generateArrangementPreview(arr, 80, 50);
        previewContainer.appendChild(preview);
        setupPreviewTooltips(previewContainer, doc);
        const info = item.createDiv({ cls: "perspecta-arrangement-info" });
        const timeLabel = info.createDiv({ cls: "perspecta-arrangement-time" });
        timeLabel.setText(formatTimestamp(arr.savedAt));
        if (index === 0) {
          const badge = timeLabel.createSpan({ cls: "perspecta-arrangement-badge" });
          badge.setText("Latest");
        }
        const summary = info.createDiv({ cls: "perspecta-arrangement-summary" });
        summary.setText(getArrangementSummary(arr));
        const deleteBtn = item.createDiv({ cls: "perspecta-arrangement-delete" });
        (0, import_obsidian4.setIcon)(deleteBtn, "x-circle");
        deleteBtn.setAttribute("aria-label", "Delete arrangement");
        deleteBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          deletedTimestamps.add(arr.savedAt);
          if (onDelete) {
            onDelete(arr.savedAt);
          }
          renderList();
        });
        item.addEventListener("click", () => {
          cleanup();
          resolve({ arrangement: arr, cancelled: false });
        });
      });
    };
    const deletedTimestamps = /* @__PURE__ */ new Set();
    renderList();
    const buttonRow = modal.createDiv({ cls: "perspecta-modal-buttons" });
    const cancelBtn = buttonRow.createEl("button", {
      cls: "perspecta-modal-button perspecta-modal-button-secondary",
      text: "Cancel"
    });
    overlay.onclick = () => {
      cleanup();
      resolve({ arrangement: sorted[0], cancelled: true });
    };
    cancelBtn.addEventListener("click", () => {
      cleanup();
      resolve({ arrangement: sorted[0], cancelled: true });
    });
    doc.body.appendChild(overlay);
    doc.body.appendChild(modal);
  });
}
function showRestoreModeSelector(backupName, targetWindow = window) {
  return new Promise((resolve) => {
    const doc = targetWindow.document;
    const overlay = doc.createElement("div");
    overlay.className = "perspecta-debug-overlay";
    const modal = doc.createElement("div");
    modal.className = "perspecta-restore-modal";
    const title = modal.createDiv({ cls: "perspecta-modal-title" });
    title.setText("Restore from Backup");
    const subtitle = modal.createDiv({ cls: "perspecta-modal-subtitle" });
    subtitle.setText(`Restoring: ${backupName}`);
    const options = modal.createDiv({ cls: "perspecta-restore-options" });
    let selectedMode = "merge";
    const mergeOption = options.createDiv({ cls: "perspecta-restore-option is-selected" });
    const mergeRadio = mergeOption.createEl("input", { type: "radio", attr: { name: "restore-mode", checked: true } });
    const mergeContent = mergeOption.createDiv({ cls: "perspecta-restore-option-content" });
    mergeContent.createDiv({ cls: "perspecta-restore-option-title", text: "Merge with existing" });
    mergeContent.createDiv({
      cls: "perspecta-restore-option-desc",
      text: "Combine backup data with existing arrangements. When conflicts occur (same note, exceeds max arrangements), only the newest arrangements are kept."
    });
    const overwriteOption = options.createDiv({ cls: "perspecta-restore-option" });
    const overwriteRadio = overwriteOption.createEl("input", { type: "radio", attr: { name: "restore-mode" } });
    const overwriteContent = overwriteOption.createDiv({ cls: "perspecta-restore-option-content" });
    overwriteContent.createDiv({ cls: "perspecta-restore-option-title", text: "Overwrite existing" });
    overwriteContent.createDiv({
      cls: "perspecta-restore-option-desc",
      text: "Replace all existing arrangements with backup data. Any arrangements not in the backup will be deleted."
    });
    const updateSelection = (mode) => {
      selectedMode = mode;
      mergeOption.classList.toggle("is-selected", mode === "merge");
      overwriteOption.classList.toggle("is-selected", mode === "overwrite");
      mergeRadio.checked = mode === "merge";
      overwriteRadio.checked = mode === "overwrite";
    };
    mergeOption.addEventListener("click", () => updateSelection("merge"));
    overwriteOption.addEventListener("click", () => updateSelection("overwrite"));
    const buttonRow = modal.createDiv({ cls: "perspecta-modal-buttons" });
    const cancelBtn = buttonRow.createEl("button", {
      cls: "perspecta-modal-button perspecta-modal-button-secondary",
      text: "Cancel"
    });
    const restoreBtn = buttonRow.createEl("button", {
      cls: "perspecta-modal-button perspecta-modal-button-primary",
      text: "Restore"
    });
    const cleanup = () => {
      modal.remove();
      overlay.remove();
    };
    overlay.onclick = () => {
      cleanup();
      resolve({ mode: "merge", cancelled: true });
    };
    cancelBtn.addEventListener("click", () => {
      cleanup();
      resolve({ mode: "merge", cancelled: true });
    });
    restoreBtn.addEventListener("click", () => {
      cleanup();
      resolve({ mode: selectedMode, cancelled: false });
    });
    doc.body.appendChild(overlay);
    doc.body.appendChild(modal);
    restoreBtn.focus();
  });
}
function showConfirmOverwrite(existingArrangement, fileName, targetWindow = window) {
  return new Promise((resolve) => {
    const doc = targetWindow.document;
    const overlay = doc.createElement("div");
    overlay.className = "perspecta-debug-overlay";
    const modal = doc.createElement("div");
    modal.className = "perspecta-confirm-modal";
    const title = modal.createDiv({ cls: "perspecta-modal-title" });
    title.setText("Overwrite Arrangement?");
    const content = modal.createDiv({ cls: "perspecta-confirm-content" });
    content.createDiv({ text: `"${fileName}" already has a saved arrangement:` });
    const existingInfo = content.createDiv({ cls: "perspecta-existing-info" });
    const previewContainer = existingInfo.createDiv({ cls: "perspecta-arrangement-preview-container" });
    const preview = generateArrangementPreview(existingArrangement, 80, 50);
    previewContainer.appendChild(preview);
    setupPreviewTooltips(previewContainer, doc);
    const infoText = existingInfo.createDiv({ cls: "perspecta-existing-info-text" });
    infoText.createDiv({
      cls: "perspecta-arrangement-time",
      text: formatTimestamp(existingArrangement.savedAt)
    });
    infoText.createDiv({
      cls: "perspecta-arrangement-summary",
      text: getArrangementSummary(existingArrangement)
    });
    content.createDiv({
      cls: "perspecta-confirm-warning",
      text: "This will replace the existing arrangement."
    });
    const buttonRow = modal.createDiv({ cls: "perspecta-modal-buttons" });
    const cancelBtn = buttonRow.createEl("button", {
      cls: "perspecta-modal-button perspecta-modal-button-secondary",
      text: "Cancel"
    });
    const confirmBtn = buttonRow.createEl("button", {
      cls: "perspecta-modal-button perspecta-modal-button-primary",
      text: "Overwrite"
    });
    const cleanup = () => {
      modal.remove();
      overlay.remove();
    };
    overlay.onclick = () => {
      cleanup();
      resolve({ confirmed: false });
    };
    cancelBtn.addEventListener("click", () => {
      cleanup();
      resolve({ confirmed: false });
    });
    confirmBtn.addEventListener("click", () => {
      cleanup();
      resolve({ confirmed: true });
    });
    doc.body.appendChild(overlay);
    doc.body.appendChild(modal);
    confirmBtn.focus();
  });
}

// src/ui/proxy-view.ts
var import_obsidian5 = require("obsidian");

// src/utils/event-manager.ts
var EventManager = class {
  /**
   * Add an event listener with automatic cleanup tracking
   */
  static addTrackedListener(element, event, handler, options) {
    element.addEventListener(event, handler, options);
    const cleanup = () => {
      element.removeEventListener(event, handler, options);
    };
    this.cleanupFunctions.push(cleanup);
    return cleanup;
  }
  /**
   * Add an event listener to a window with automatic cleanup tracking
   */
  static addTrackedWindowListener(window2, event, handler, options) {
    window2.addEventListener(event, handler, options);
    const cleanup = () => {
      window2.removeEventListener(event, handler, options);
    };
    this.cleanupFunctions.push(cleanup);
    return cleanup;
  }
  /**
   * Add an event listener to a document with automatic cleanup tracking
   */
  static addTrackedDocumentListener(document2, event, handler, options) {
    document2.addEventListener(event, handler, options);
    const cleanup = () => {
      document2.removeEventListener(event, handler, options);
    };
    this.cleanupFunctions.push(cleanup);
    return cleanup;
  }
  /**
   * Clean up all tracked event listeners
   */
  static cleanupAll() {
    this.cleanupFunctions.forEach((cleanup) => {
      try {
        cleanup();
      } catch (error) {
        console.warn("[Perspecta] Error during event cleanup:", error);
      }
    });
    this.cleanupFunctions = [];
  }
  /**
   * Remove a specific cleanup function from tracking
   */
  static removeCleanup(cleanup) {
    const index = this.cleanupFunctions.indexOf(cleanup);
    if (index > -1) {
      this.cleanupFunctions.splice(index, 1);
    }
  }
};
EventManager.cleanupFunctions = [];
var ComponentEventManager = class {
  constructor() {
    this.cleanupFunctions = [];
  }
  /**
   * Add an event listener to this component's cleanup list
   */
  addListener(element, event, handler, options) {
    element.addEventListener(event, handler, options);
    const cleanup = () => {
      element.removeEventListener(event, handler, options);
    };
    this.cleanupFunctions.push(cleanup);
  }
  /**
   * Add an event listener to a window for this component
   */
  addWindowListener(window2, event, handler, options) {
    window2.addEventListener(event, handler, options);
    const cleanup = () => {
      window2.removeEventListener(event, handler, options);
    };
    this.cleanupFunctions.push(cleanup);
  }
  /**
   * Clean up all event listeners for this component
   */
  cleanup() {
    this.cleanupFunctions.forEach((cleanup) => {
      try {
        cleanup();
      } catch (error) {
        console.warn("[Perspecta] Error during component event cleanup:", error);
      }
    });
    this.cleanupFunctions = [];
  }
  /**
   * Get the number of tracked listeners
   */
  get listenerCount() {
    return this.cleanupFunctions.length;
  }
};

// src/ui/proxy-view.ts
var PROXY_VIEW_TYPE = "perspecta-proxy-view";
var ProxyNoteView = class extends import_obsidian5.ItemView {
  constructor(leaf) {
    super(leaf);
    this.state = { filePath: "" };
    this.file = null;
    this.renderComponent = null;
    this.eventManager = new ComponentEventManager();
  }
  getViewType() {
    return PROXY_VIEW_TYPE;
  }
  getDisplayText() {
    var _a;
    return ((_a = this.file) == null ? void 0 : _a.basename) || "Proxy";
  }
  getIcon() {
    return "minimize-2";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("perspecta-proxy-container");
    this.applyProxyWindowClass();
    await this.renderContent(container);
    await this.configureWindowChromeWithRetry();
  }
  /**
   * Configure window chrome with retry logic for reliability
   */
  async configureWindowChromeWithRetry() {
    const attempts = [
      0,
      TIMING.CHROME_RETRY_DELAY_1,
      TIMING.CHROME_RETRY_DELAY_2,
      TIMING.CHROME_RETRY_DELAY_3
    ];
    for (const delay2 of attempts) {
      if (delay2 > 0) {
        await new Promise((resolve) => setTimeout(resolve, delay2));
      }
      this.configureWindowChrome();
    }
  }
  /**
   * Applies CSS classes to the popout window for styling.
   * This enables CSS-only window chrome hiding.
   */
  applyProxyWindowClass() {
    var _a;
    const win = this.getPopoutWindow();
    if ((_a = win == null ? void 0 : win.document) == null ? void 0 : _a.body) {
      win.document.body.classList.add(CSS_CLASSES.PROXY_WINDOW);
    }
    const workspaceEl = this.containerEl.closest(".workspace");
    if (workspaceEl) {
      workspaceEl.classList.add(CSS_CLASSES.PROXY_WORKSPACE);
    }
  }
  /**
   * Gets the popout window for this view, if any.
   * Returns null if this is the main window.
   */
  getPopoutWindow() {
    var _a, _b;
    const win = this.containerEl.win || ((_b = (_a = this.leaf.view) == null ? void 0 : _a.containerEl) == null ? void 0 : _b.win);
    if (win && win !== window) {
      return win;
    }
    return null;
  }
  /**
   * Configures window chrome (tabs, titlebar, etc.) via CSS and DOM.
   * Does NOT use Electron remote module - uses CSS-only approach.
   */
  configureWindowChrome() {
    const win = this.getPopoutWindow();
    if (!win)
      return;
    const doc = win.document;
    if (!doc)
      return;
    const headerEl = doc.querySelector(".workspace-tab-header-container");
    if (headerEl) {
      headerEl.remove();
    }
    const titlebarEl = doc.querySelector(".titlebar");
    if (titlebarEl) {
      while (titlebarEl.firstChild) {
        titlebarEl.removeChild(titlebarEl.firstChild);
      }
      titlebarEl.style.height = "0";
      titlebarEl.style.minHeight = "0";
    }
    const viewHeader = doc.querySelector(".view-header");
    if (viewHeader) {
      viewHeader.style.display = "none";
    }
  }
  async renderContent(container) {
    var _a, _b, _c, _d;
    const headerRow = container.createDiv({ cls: CSS_CLASSES.PROXY_HEADER });
    headerRow.style.cssText += "-webkit-app-region: drag; cursor: move;";
    headerRow.createDiv({
      cls: CSS_CLASSES.PROXY_TITLE,
      text: ((_a = this.file) == null ? void 0 : _a.basename) || "No file"
    });
    const expandBtn = headerRow.createDiv({ cls: CSS_CLASSES.PROXY_EXPAND });
    expandBtn.style.cssText += "-webkit-app-region: no-drag; cursor: pointer;";
    (0, import_obsidian5.setIcon)(expandBtn, "maximize-2");
    this.eventManager.addListener(expandBtn, EVENTS.CLICK, (e) => {
      e.stopPropagation();
      this.expandToFullWindow();
    });
    const previewWrapper = container.createDiv({ cls: "perspecta-proxy-preview-wrapper" });
    const previewContent = previewWrapper.createDiv({ cls: "perspecta-proxy-preview-content" });
    const ext = ((_b = this.file) == null ? void 0 : _b.extension.toLowerCase()) || "";
    const needsScaling = !this.isImageFile(ext) && !this.isPdfFile(ext) && !this.isNonRenderableFile(ext);
    if (needsScaling) {
      const plugin = this.getPlugin();
      const scale = (_d = (_c = plugin == null ? void 0 : plugin.settings) == null ? void 0 : _c.proxyPreviewScale) != null ? _d : 0.35;
      const inverseScale = 100 / (scale * 100);
      previewContent.style.width = `${inverseScale * 100}%`;
      previewContent.style.height = `${inverseScale * 100}%`;
      previewContent.style.transform = `scale(${scale})`;
    } else {
      previewContent.style.width = "100%";
      previewContent.style.height = "100%";
      previewContent.style.position = "relative";
    }
    await this.renderMarkdownPreview(previewContent);
    previewWrapper.style.overflow = "auto";
    previewWrapper.style.cursor = "pointer";
    previewContent.style.pointerEvents = "auto";
    this.eventManager.addListener(previewWrapper, EVENTS.CLICK, (e) => {
      if (this.state.arrangementUid) {
        const forceLatest = !e.shiftKey;
        this.restoreArrangement(forceLatest);
      } else {
        this.expandToFullWindow();
      }
    });
    container.tabIndex = 0;
    this.eventManager.addListener(container, EVENTS.KEY_DOWN, (e) => {
      const scrollAmount = 50;
      if (e.key === "ArrowDown" || e.key === "j") {
        previewWrapper.scrollTop += scrollAmount;
        e.preventDefault();
      } else if (e.key === "ArrowUp" || e.key === "k") {
        previewWrapper.scrollTop -= scrollAmount;
        e.preventDefault();
      } else if (e.key === "PageDown") {
        previewWrapper.scrollTop += previewWrapper.clientHeight;
        e.preventDefault();
      } else if (e.key === "PageUp") {
        previewWrapper.scrollTop -= previewWrapper.clientHeight;
        e.preventDefault();
      } else if (e.key === "Home") {
        previewWrapper.scrollTop = 0;
        e.preventDefault();
      } else if (e.key === "End") {
        previewWrapper.scrollTop = previewWrapper.scrollHeight;
        e.preventDefault();
      } else if (e.key === "Enter" || e.key === " ") {
        if (this.state.arrangementUid) {
          this.restoreArrangement(true);
        } else {
          this.expandToFullWindow();
        }
        e.preventDefault();
      }
    });
    this.eventManager.addListener(container, EVENTS.MOUSE_DOWN, () => {
      container.focus();
    });
    this.eventManager.addListener(previewWrapper, EVENTS.MOUSE_ENTER, () => {
      previewWrapper.style.backgroundColor = "var(--background-secondary)";
    });
    this.eventManager.addListener(previewWrapper, EVENTS.MOUSE_LEAVE, () => {
      previewWrapper.style.backgroundColor = "";
    });
  }
  async renderMarkdownPreview(container) {
    if (!this.file)
      return;
    const ext = this.file.extension.toLowerCase();
    if (this.isImageFile(ext)) {
      this.renderImagePreview(container);
      return;
    }
    if (this.isPdfFile(ext)) {
      this.renderFileTypeIcon(container, "file-text", "PDF");
      return;
    }
    if (this.isNonRenderableFile(ext)) {
      this.renderFileTypeIcon(container, "file", ext.toUpperCase());
      return;
    }
    try {
      const content = await this.app.vault.cachedRead(this.file);
      if (this.renderComponent) {
        this.renderComponent.unload();
      }
      this.renderComponent = new import_obsidian5.Component();
      this.renderComponent.load();
      await import_obsidian5.MarkdownRenderer.render(
        this.app,
        content,
        container,
        this.file.path,
        this.renderComponent
      );
    } catch (e) {
      container.setText("Preview unavailable");
    }
  }
  isImageFile(ext) {
    return ["png", "jpg", "jpeg", "gif", "bmp", "svg", "webp", "ico", "avif"].includes(ext);
  }
  isPdfFile(ext) {
    return ext === "pdf";
  }
  isNonRenderableFile(ext) {
    return [
      "pdf",
      "doc",
      "docx",
      "xls",
      "xlsx",
      "ppt",
      "pptx",
      "zip",
      "rar",
      "7z",
      "tar",
      "gz",
      "mp3",
      "wav",
      "ogg",
      "flac",
      "m4a",
      "mp4",
      "mov",
      "avi",
      "mkv",
      "webm",
      "exe",
      "dmg",
      "app",
      "bin"
    ].includes(ext);
  }
  renderImagePreview(container) {
    if (!this.file)
      return;
    const imgContainer = container.createDiv({ cls: "perspecta-proxy-image-preview" });
    const resourcePath = this.app.vault.getResourcePath(this.file);
    const img = imgContainer.createEl("img", {
      attr: {
        src: resourcePath,
        alt: this.file.basename
      }
    });
    img.style.maxWidth = "100%";
    img.style.maxHeight = "100%";
    img.style.objectFit = "contain";
    imgContainer.style.display = "flex";
    imgContainer.style.alignItems = "center";
    imgContainer.style.justifyContent = "center";
    imgContainer.style.height = "100%";
    imgContainer.style.padding = "8px";
    imgContainer.style.boxSizing = "border-box";
  }
  renderFileTypeIcon(container, iconName, fileType) {
    const iconContainer = container.createDiv({ cls: "perspecta-proxy-file-icon" });
    const iconEl = iconContainer.createDiv({ cls: "perspecta-proxy-file-icon-svg" });
    (0, import_obsidian5.setIcon)(iconEl, iconName);
    iconContainer.createDiv({
      cls: "perspecta-proxy-file-type-label",
      text: fileType
    });
    iconContainer.style.display = "flex";
    iconContainer.style.flexDirection = "column";
    iconContainer.style.alignItems = "center";
    iconContainer.style.justifyContent = "center";
    iconContainer.style.height = "100%";
    iconContainer.style.gap = "8px";
    iconContainer.style.color = "var(--text-muted)";
    iconEl.style.width = "48px";
    iconEl.style.height = "48px";
    const svg = iconEl.querySelector("svg");
    if (svg) {
      svg.style.width = "100%";
      svg.style.height = "100%";
    }
  }
  async setState(state, result) {
    const proxyState = state;
    if (proxyState && typeof proxyState === "object" && "filePath" in proxyState) {
      this.state = proxyState;
      if (proxyState.filePath) {
        this.file = this.app.vault.getAbstractFileByPath(proxyState.filePath);
      }
      const container = this.containerEl.children[1];
      if (container) {
        container.empty();
        await this.renderContent(container);
      }
    }
    return super.setState(state, result);
  }
  async onClose() {
    this.eventManager.cleanup();
    if (this.renderComponent) {
      this.renderComponent.unload();
      this.renderComponent = null;
    }
  }
  getState() {
    return this.state;
  }
  /**
   * Gets the Perspecta plugin instance.
   * Uses typed accessor instead of (this.app as any).
   */
  getPlugin() {
    var _a, _b, _c;
    const app = this.app;
    return (_c = (_b = (_a = app.plugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["perspecta-obsidian"]) != null ? _c : null;
  }
  async restoreArrangement(forceLatest = true) {
    if (!this.state.arrangementUid || !this.file)
      return;
    const file = this.file;
    const plugin = this.getPlugin();
    this.leaf.detach();
    if (plugin && typeof plugin.restoreContext === "function") {
      await plugin.restoreContext(file, forceLatest);
    }
  }
  async expandToFullWindow() {
    if (!this.file)
      return;
    const win = this.getPopoutWindow();
    const x = (win == null ? void 0 : win.screenX) || 100;
    const y = (win == null ? void 0 : win.screenY) || 100;
    this.leaf.detach();
    const newLeaf = this.app.workspace.openPopoutLeaf({
      size: { width: 800, height: 600 }
    });
    await newLeaf.openFile(this.file);
    const newWin = newLeaf.view.containerEl.win;
    if (newWin && newWin !== window) {
      try {
        newWin.moveTo(x, y);
      } catch (e) {
      }
    }
  }
};

// src/ui/settings-tab.ts
var import_obsidian6 = require("obsidian");

// src/changelog.ts
var CHANGELOG = [
  {
    version: "0.1.29",
    date: "2025-12-30",
    changes: [
      "Performance: Wallpaper restore now runs concurrently (non-blocking) for faster context switching",
      "Fix: DevTools window now stays open during context restore for debugging",
      "Fix: DevTools automatically re-opens if it was open before restore"
    ]
  },
  {
    version: "0.1.28",
    date: "2025-12-29",
    changes: [
      "Fix: Version sync and release automation"
    ]
  },
  {
    version: "0.1.26",
    date: "2025-12-29",
    changes: [
      "New: Optional parallel popout window creation for 30-50% faster context restoration",
      "New: Performance section in Experimental settings tab",
      "Settings: Added toggle for parallel popout creation (disabled by default)",
      "Note: Enable in Settings \u2192 Experimental \u2192 Performance to try the new parallel mode"
    ]
  },
  {
    version: "0.1.25",
    date: "2025-12-29",
    changes: [
      "Updated CHANGELOG.md with comprehensive v0.1.24 release notes",
      "Documented Settings Tab refactoring details",
      "Clarified code organization improvements",
      "Note: This is a documentation-only release, no code changes"
    ]
  },
  {
    version: "0.1.24",
    date: "2025-12-29",
    changes: [
      "Refactor: Extracted Settings Tab to separate module (ui/settings-tab.ts)",
      "Refactor: Reduced main.ts from 4,320 to 3,873 lines (10.3% reduction)",
      "Improved: Better code organization and separation of concerns",
      "Improved: Settings UI now independently testable and maintainable",
      "Fixed: Build errors from incomplete refactoring attempts",
      "Internal: No user-facing changes, all functionality maintained"
    ]
  },
  {
    version: "0.1.21",
    date: "2025-12-29",
    changes: [
      "Performance: Comprehensive event listener management with automatic cleanup prevents memory leaks",
      "Performance: Replaced all hardcoded setTimeout calls with centralized timing constants",
      "Performance: Added debounced operations for file saving and UI updates",
      "Performance: Implemented retry logic with exponential backoff for unreliable operations",
      "Performance: Added timeout protection against hanging operations",
      "Reliability: Component-level event management with proper cleanup on component destruction",
      "Reliability: Safe timeout utilities prevent orphaned timeout callbacks",
      "Reliability: Better error handling and recovery in async operations",
      "Reliability: Improved window chrome configuration with retry logic",
      "Refactor: Created utility modules for constants, event management, and async operations",
      "Refactor: Eliminated magic numbers throughout codebase with centralized constants",
      "Refactor: Consistent async patterns across all services"
    ]
  },
  {
    version: "0.1.20",
    date: "2025-12-29",
    changes: [
      "Changed: Cmd+Shift+Click now auto-restores most recent arrangement (skips selector modal)"
    ]
  },
  {
    version: "0.1.19",
    date: "2025-12-28",
    changes: [
      "New: Cmd+Shift+Click (macOS) or Ctrl+Shift+Click (Windows/Linux) on links restores target note context",
      "Fixed: File context scanning now waits for Obsidian layout to be ready",
      "Fixed: Modifier key tracking works in both main window and popout windows"
    ]
  },
  {
    version: "0.1.18",
    date: "2025-12-28",
    changes: [
      "New: Non-linear center-preserving window scaling across different screen aspect ratios",
      "Improved: Windows in the center of the screen maintain proportions when switching displays",
      "Improved: Left/right edge windows absorb aspect ratio differences (stretching/compression)",
      "Fixed: Windows no longer get excessively stretched on ultrawide or compressed on narrow displays"
    ]
  },
  {
    version: "0.1.17",
    date: "2025-12-27",
    changes: [
      "New: Backup restore modal with Merge or Overwrite options",
      "New: Merge mode combines backup with existing, keeping newest arrangements on conflict",
      "New: Info box in Storage settings about Obsidian Sync configuration",
      "Improved: Documentation for syncing arrangements across devices"
    ]
  },
  {
    version: "0.1.16",
    date: "2025-12-27",
    changes: [
      "Fixed: Add defensive geometry validation to prevent freezes on Windows",
      "Fixed: Validate all geometry before window.moveTo/resizeTo operations",
      "Fixed: Guard against NaN, negative, zero, and extremely large coordinate values",
      "Fixed: Limit maximum popouts to 20 to prevent runaway window creation",
      "Fixed: Add try/catch around openPopoutLeaf and openFile calls",
      "Improved: Log warnings for invalid data to aid debugging"
    ]
  },
  {
    version: "0.1.15",
    date: "2025-12-26",
    changes: [
      "Performance: Incremental file explorer indicator updates via metadata events",
      "Refactor: New base64 utility replacing deprecated escape/unescape functions",
      "Refactor: Added ensureInitialized() API to external context store",
      "Refactor: Extracted IndicatorsService for better code organization",
      "Fixed: All 19 lint errors resolved, reduced warnings from 91 to 77",
      "Fixed: Backup restore now handles malformed files gracefully",
      "Fixed: File context menu now works for canvas and base files",
      "Improved: Better type safety with unknown instead of any in event handlers",
      "Improved: Consistent use of helper functions for internal API access"
    ]
  },
  {
    version: "0.1.14",
    date: "2025-12-20",
    changes: [
      "Internal improvements and bug fixes"
    ]
  },
  {
    version: "0.1.13",
    date: "2025-12-06",
    changes: [
      "Experimental: Save and restore desktop wallpaper with context",
      "Wallpaper support for macOS (AppleScript), Windows (PowerShell), Linux (GNOME)",
      "New settings to enable wallpaper capture and restore independently"
    ]
  },
  {
    version: "0.1.12",
    date: "2025-12-06",
    changes: [
      "Save and restore active sidebar panel (File Explorer, Search, Bookmarks, etc.)",
      "Improved sidebar state capture with multiple fallback methods"
    ]
  },
  {
    version: "0.1.11",
    date: "2025-12-06",
    changes: [
      "Proxy windows now show image thumbnails for image files",
      "Proxy windows show file type icon for PDFs and other binary files",
      "Fixed broken display when converting image/PDF windows to proxy"
    ]
  },
  {
    version: "0.1.10",
    date: "2025-12-06",
    changes: [
      "Hide perspecta-uid property from Properties view (still visible in source mode)"
    ]
  },
  {
    version: "0.1.9",
    date: "2025-12-06",
    changes: [
      "Removed excess padding from proxy window preview content",
      "Fixed bottom margin in proxy windows"
    ]
  },
  {
    version: "0.1.8",
    date: "2025-12-06",
    changes: [
      "Unified changelog system - single source of truth for all changelogs",
      "Added CHANGELOG.md file auto-generated from changelog data",
      "Reorganized README features to match settings pane structure",
      "Added Convert to proxy window command documentation",
      "Added backup reminder to external storage warning"
    ]
  },
  {
    version: "0.1.7",
    date: "2025-12-06",
    changes: [
      "Proxy windows now show scaled markdown preview of note content",
      "Draggable title bar - drag header to move proxy window",
      "Scrollable content - use mouse wheel or arrow keys to scroll preview",
      "Keyboard navigation: \u2191/\u2193, j/k, Page Up/Down, Home/End, Enter/Space",
      "Configurable preview scale factor in Experimental settings (default 35%)",
      "Canvas viewport and zoom level now saved and restored",
      "Context indicator (target icon) now appears correctly in popout windows",
      "Fixed duplicate proxy windows when restoring contexts",
      "Fixed concurrent restore guard to prevent window duplication"
    ]
  },
  {
    version: "0.1.6",
    date: "2025-12-05",
    changes: [
      "Experimental: Proxy windows - minimalist window showing only note title",
      "Click proxy to restore latest arrangement, Shift+click for selector",
      "Click proxy without arrangement to expand to full window",
      "Proxy window positions and sizes saved/restored with arrangements",
      "Added Experimental settings tab to enable/disable proxy windows",
      "Fixed notifications not auto-dismissing (4 second timeout)",
      "Notifications and focus tints no longer appear in proxy windows"
    ]
  },
  {
    version: "0.1.3",
    date: "2025-12-04",
    changes: [
      "Multi-arrangement storage: store up to 5 arrangements per note",
      "Arrangement selector modal with visual SVG previews",
      "Delete button to remove specific arrangements from history",
      "Confirmation dialog when overwriting single arrangement",
      "Backup & restore functionality to perspecta folder",
      "SVG previews show windows, splits, sidebars, and focus highlight",
      "Instant tooltips on SVG areas showing note names",
      'Renamed "Focus tint duration" setting for clarity',
      "Fixed notification toast not disappearing"
    ]
  },
  {
    version: "0.1.2",
    changes: [
      "Improved plugin compliance with Obsidian guidelines"
    ]
  },
  {
    version: "0.1.1",
    changes: [
      "Save and restore scroll position for all tabs",
      "Save and restore split sizes (pane proportions)"
    ]
  },
  {
    version: "0.1.0",
    changes: [
      "Initial release",
      "Save and restore window arrangements (tabs, splits, popouts)",
      "External storage mode for cleaner notes",
      "Frontmatter storage mode for portability",
      "Auto-generate UIDs for file tracking",
      "Context indicators in file explorer",
      "Focus tint animation on restore"
    ]
  }
];
function renderChangelogToContainer(containerEl) {
  containerEl.createEl("h2", { text: "Changelog" });
  for (const entry of CHANGELOG) {
    const versionDiv = containerEl.createDiv({ cls: "perspecta-changelog-version" });
    versionDiv.createEl("h3", { text: `v${entry.version}` });
    const list = versionDiv.createEl("ul");
    for (const change of entry.changes) {
      list.createEl("li", { text: change });
    }
  }
}

// src/ui/settings-tab.ts
var PerspectaSettingTab = class extends import_obsidian6.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.currentTab = "changelog";
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Perspecta", cls: "perspecta-settings-title" });
    const buildInfo = containerEl.createDiv({ cls: "setting-item-description" });
    buildInfo.style.marginTop = "6px";
    buildInfo.style.marginBottom = "18px";
    buildInfo.setText(`Version: v${this.plugin.manifest.version}`);
    this.app.vault.adapter.stat(`${this.plugin.manifest.dir}/main.js`).then((stat2) => {
      if (!(stat2 == null ? void 0 : stat2.mtime))
        return;
      buildInfo.setText(`Version: v${this.plugin.manifest.version} (main.js: ${new Date(stat2.mtime).toLocaleString()})`);
    }).catch(() => {
    });
    const tabNav = containerEl.createDiv({ cls: "perspecta-settings-tabs" });
    const tabs = [
      { id: "changelog", label: "Changelog" },
      { id: "context", label: "Context" },
      { id: "storage", label: "Storage" },
      { id: "backup", label: "Backup" },
      { id: "experimental", label: "Experimental" },
      { id: "debug", label: "Debug" }
    ];
    tabs.forEach((tab) => {
      const tabEl = tabNav.createEl("button", {
        cls: `perspecta-settings-tab ${this.currentTab === tab.id ? "is-active" : ""}`,
        text: tab.label
      });
      tabEl.addEventListener("click", () => {
        this.currentTab = tab.id;
        this.display();
      });
    });
    switch (this.currentTab) {
      case "changelog":
        this.displayChangelog(containerEl);
        break;
      case "context":
        this.displayContextSettings(containerEl);
        break;
      case "storage":
        this.displayStorageSettings(containerEl);
        break;
      case "backup":
        this.displayBackupSettings(containerEl);
        break;
      case "experimental":
        this.displayExperimentalSettings(containerEl);
        break;
      case "debug":
        this.displayDebugSettings(containerEl);
        break;
    }
  }
  displayChangelog(containerEl) {
    renderChangelogToContainer(containerEl);
  }
  displayContextSettings(containerEl) {
    const saveHotkey = this.getHotkeyDisplay("perspecta-obsidian:save-context");
    const restoreHotkey = this.getHotkeyDisplay("perspecta-obsidian:restore-context");
    new import_obsidian6.Setting(containerEl).setName("Hotkeys").setDesc("Customize in Settings \u2192 Hotkeys").addButton((btn) => btn.setButtonText(`Save: ${saveHotkey}`).setDisabled(true)).addButton((btn) => btn.setButtonText(`Restore: ${restoreHotkey}`).setDisabled(true));
    new import_obsidian6.Setting(containerEl).setName("Seconds for focus note highlight").setDesc("0 = disabled").addText((t) => t.setValue(String(this.plugin.settings.focusTintDuration)).onChange(async (v) => {
      const n = parseFloat(v);
      if (!isNaN(n) && n >= 0) {
        this.plugin.settings.focusTintDuration = n;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian6.Setting(containerEl).setName("Auto-generate file UIDs").setDesc("Automatically add unique IDs to files in saved contexts. This allows files to be found even after moving or renaming.").addToggle((t) => t.setValue(this.plugin.settings.autoGenerateUids).onChange(async (v) => {
      this.plugin.settings.autoGenerateUids = v;
      await this.plugin.saveSettings();
    }));
  }
  displayStorageSettings(containerEl) {
    new import_obsidian6.Setting(containerEl).setName("Perspecta folder").setDesc("Folder in your vault for Perspecta data (backups, scripts). Created if it doesn't exist.").addText((t) => t.setPlaceholder("perspecta").setValue(this.plugin.settings.perspectaFolderPath).onChange(async (v) => {
      this.plugin.settings.perspectaFolderPath = v.trim() || "perspecta";
      await this.plugin.saveSettings();
    }));
    const syncInfoBox = containerEl.createDiv({ cls: "perspecta-info-box" });
    const syncInfoIcon = syncInfoBox.createSpan({ cls: "perspecta-info-box-icon" });
    (0, import_obsidian6.setIcon)(syncInfoIcon, "info");
    const syncInfoContent = syncInfoBox.createDiv({ cls: "perspecta-info-box-content" });
    syncInfoContent.createEl("strong", { text: "Obsidian Sync Users" });
    syncInfoContent.createEl("p", {
      text: 'To sync window arrangements across devices, enable "Sync all other types" in Settings \u2192 Sync \u2192 Selective sync. This allows JSON context files to sync between your devices.'
    });
    new import_obsidian6.Setting(containerEl).setName("Store window arrangements in frontmatter").setDesc("When enabled, context data is stored in note frontmatter (syncs with note). When disabled, context is stored externally in the plugin folder (keeps notes cleaner, requires perspecta-uid in frontmatter).").addToggle((t) => t.setValue(this.plugin.settings.storageMode === "frontmatter").onChange(async (v) => {
      this.plugin.settings.storageMode = v ? "frontmatter" : "external";
      await this.plugin.saveSettings();
      if (!v) {
        await this.plugin.externalStore.initialize();
      }
      this.display();
    }));
    if (this.plugin.settings.storageMode === "external") {
      new import_obsidian6.Setting(containerEl).setName("Maximum arrangements per note").setDesc("How many window arrangements to store per note. Older arrangements are automatically removed when the limit is reached.").addDropdown((d) => d.addOptions({
        "1": "1",
        "2": "2",
        "3": "3",
        "4": "4",
        "5": "5"
      }).setValue(String(this.plugin.settings.maxArrangementsPerNote)).onChange(async (v) => {
        this.plugin.settings.maxArrangementsPerNote = parseInt(v);
        await this.plugin.saveSettings();
        this.display();
      }));
      if (this.plugin.settings.maxArrangementsPerNote === 1) {
        new import_obsidian6.Setting(containerEl).setName("Auto-confirm overwrite").setDesc("Skip confirmation when overwriting an existing arrangement. Only applies when storing a single arrangement per note.").addToggle((t) => t.setValue(this.plugin.settings.autoConfirmOverwrite).onChange(async (v) => {
          this.plugin.settings.autoConfirmOverwrite = v;
          await this.plugin.saveSettings();
        }));
      }
    }
    if (this.plugin.settings.storageMode === "frontmatter") {
      new import_obsidian6.Setting(containerEl).setName("Migrate to external storage").setDesc("Move all context data from note frontmatter to the plugin folder. This cleans up your notes by removing perspecta-arrangement properties.").addButton((btn) => btn.setButtonText("Migrate to external").setCta().onClick(async () => {
        btn.setDisabled(true);
        btn.setButtonText("Migrating...");
        try {
          const result = await this.plugin.migrateToExternalStorage();
          new import_obsidian6.Notice(`Migration complete: ${result.migrated} contexts moved${result.errors > 0 ? `, ${result.errors} errors` : ""}`, 4e3);
          this.display();
        } catch (e) {
          new import_obsidian6.Notice("Migration failed: " + e.message, 4e3);
          btn.setDisabled(false);
          btn.setButtonText("Migrate to external");
        }
      }));
    } else {
      new import_obsidian6.Setting(containerEl).setName("Migrate to frontmatter").setDesc("Move all context data from the plugin folder into note frontmatter. This makes contexts portable with your notes.").addButton((btn) => btn.setButtonText("Migrate to frontmatter").setCta().onClick(async () => {
        btn.setDisabled(true);
        btn.setButtonText("Migrating...");
        try {
          const result = await this.plugin.migrateToFrontmatter();
          new import_obsidian6.Notice(`Migration complete: ${result.migrated} contexts moved${result.errors > 0 ? `, ${result.errors} errors` : ""}`, 4e3);
          this.display();
        } catch (e) {
          new import_obsidian6.Notice("Migration failed: " + e.message, 4e3);
          btn.setDisabled(false);
          btn.setButtonText("Migrate to frontmatter");
        }
      }));
    }
    new import_obsidian6.Setting(containerEl).setName("Clean up old uid properties").setDesc('Remove obsolete "uid" properties from notes that already have "perspecta-uid". This cleans up leftover data from earlier versions.').addButton((btn) => btn.setButtonText("Clean up").onClick(async () => {
      btn.setDisabled(true);
      btn.setButtonText("Cleaning...");
      try {
        const count = await this.plugin.cleanupOldUidProperties();
        new import_obsidian6.Notice(count > 0 ? `Cleaned up ${count} file${count > 1 ? "s" : ""}` : "No old uid properties found", 4e3);
      } catch (e) {
        new import_obsidian6.Notice("Cleanup failed: " + e.message, 4e3);
      }
      btn.setDisabled(false);
      btn.setButtonText("Clean up");
    }));
  }
  displayBackupSettings(containerEl) {
    new import_obsidian6.Setting(containerEl).setName("Backup arrangements").setDesc(`Create a backup of all stored arrangements to the ${this.plugin.settings.perspectaFolderPath}/backups folder.`).addButton((btn) => btn.setButtonText("Create backup").onClick(async () => {
      btn.setDisabled(true);
      btn.setButtonText("Backing up...");
      try {
        const result = await this.plugin.backupArrangements();
        new import_obsidian6.Notice(`Backup created: ${result.count} arrangements saved to ${result.path}`, 4e3);
        this.display();
      } catch (e) {
        new import_obsidian6.Notice("Backup failed: " + e.message, 4e3);
      }
      btn.setDisabled(false);
      btn.setButtonText("Create backup");
    }));
    new import_obsidian6.Setting(containerEl).setName("Restore from backup").setDesc("Restore arrangements from a previous backup. This will overwrite existing arrangements with the same UIDs.");
    const backupListContainer = containerEl.createDiv({ cls: "perspecta-backup-list-container" });
    this.plugin.listBackups().then((backups) => {
      if (backups.length === 0) {
        backupListContainer.createDiv({
          cls: "perspecta-backup-empty",
          text: "No backups available"
        });
      } else {
        backups.forEach((backup) => {
          const item = backupListContainer.createDiv({ cls: "perspecta-backup-item" });
          const info = item.createDiv({ cls: "perspecta-backup-info" });
          info.createDiv({ cls: "perspecta-backup-name", text: backup.name });
          info.createDiv({
            cls: "perspecta-backup-date",
            text: backup.date.toLocaleString()
          });
          const restoreBtn = item.createEl("button", {
            cls: "perspecta-backup-restore-btn",
            text: "Restore"
          });
          restoreBtn.addEventListener("click", async () => {
            restoreBtn.disabled = true;
            restoreBtn.textContent = "Restoring...";
            try {
              const result = await this.plugin.restoreFromBackup(backup.path);
              if (result.cancelled) {
              } else {
                new import_obsidian6.Notice(`Restore complete: ${result.restored} arrangements restored${result.errors > 0 ? `, ${result.errors} errors` : ""}`, 4e3);
              }
            } catch (e) {
              new import_obsidian6.Notice("Restore failed: " + e.message, 4e3);
            }
            restoreBtn.disabled = false;
            restoreBtn.textContent = "Restore";
          });
        });
      }
    });
  }
  displayExperimentalSettings(containerEl) {
    const warning = containerEl.createDiv({ cls: "perspecta-experimental-warning" });
    warning.createSpan({ cls: "perspecta-experimental-warning-icon", text: "\u26A0\uFE0F" });
    warning.createSpan({ text: "These features are experimental and may change or break in future updates." });
    containerEl.createEl("h4", { text: "Performance" });
    new import_obsidian6.Setting(containerEl).setName("Parallel popout window creation").setDesc("Create popout windows in parallel instead of sequentially. Can improve restoration speed by 30-50% when restoring multiple popout windows.").addToggle((t) => t.setValue(this.plugin.settings.enableParallelPopoutCreation).onChange(async (v) => {
      this.plugin.settings.enableParallelPopoutCreation = v;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h4", { text: "Proxy windows" });
    new import_obsidian6.Setting(containerEl).setName("Enable proxy windows").setDesc('Allows converting popout windows to minimalist "proxy" windows that show only the note title. Click the title to restore its arrangement.').addToggle((t) => t.setValue(this.plugin.settings.enableProxyWindows).onChange(async (v) => {
      this.plugin.settings.enableProxyWindows = v;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.enableProxyWindows) {
      new import_obsidian6.Setting(containerEl).setName("Preview scale").setDesc("Scale factor for the note preview in proxy windows (10% to 100%)").addSlider((slider) => slider.setLimits(10, 100, 5).setValue(this.plugin.settings.proxyPreviewScale * 100).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.proxyPreviewScale = value / 100;
        await this.plugin.saveSettings();
      }));
      const infoDiv = containerEl.createDiv({ cls: "setting-item-description" });
      infoDiv.style.marginTop = "12px";
      infoDiv.style.marginBottom = "12px";
      const strongEl = infoDiv.createEl("strong");
      strongEl.textContent = "How to use:";
      infoDiv.createEl("br");
      infoDiv.appendText('\u2022 Use command "Convert to proxy window" on any popout window');
      infoDiv.createEl("br");
      infoDiv.appendText("\u2022 The proxy shows a scaled preview of the note content");
      infoDiv.createEl("br");
      infoDiv.appendText("\u2022 Click the expand icon (\u2197) to restore the full window");
      infoDiv.createEl("br");
      infoDiv.appendText("\u2022 If the note has a saved arrangement, click anywhere to restore it");
    }
    containerEl.createEl("h4", { text: "Desktop wallpaper" });
    new import_obsidian6.Setting(containerEl).setName("Save wallpaper with context").setDesc("Capture the current desktop wallpaper when saving a context. The wallpaper can be restored when switching between projects.").addToggle((t) => t.setValue(this.plugin.settings.enableWallpaperCapture).onChange(async (v) => {
      this.plugin.settings.enableWallpaperCapture = v;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.enableWallpaperCapture) {
      new import_obsidian6.Setting(containerEl).setName("Restore wallpaper with context").setDesc("Automatically change the desktop wallpaper to match the saved context when restoring.").addToggle((t) => t.setValue(this.plugin.settings.enableWallpaperRestore).onChange(async (v) => {
        this.plugin.settings.enableWallpaperRestore = v;
        await this.plugin.saveSettings();
      }));
      new import_obsidian6.Setting(containerEl).setName("Store wallpapers in vault").setDesc(`Copy wallpapers to ${this.plugin.settings.perspectaFolderPath}/wallpapers/ for portability. When disabled, the original system path is stored.`).addToggle((t) => t.setValue(this.plugin.settings.storeWallpapersLocally).onChange(async (v) => {
        this.plugin.settings.storeWallpapersLocally = v;
        await this.plugin.saveSettings();
      }));
    }
    const wallpaperInfoDiv = containerEl.createDiv({ cls: "setting-item-description" });
    wallpaperInfoDiv.style.marginTop = "12px";
    wallpaperInfoDiv.style.marginBottom = "12px";
    const platformStrong = wallpaperInfoDiv.createEl("strong");
    platformStrong.textContent = "Platform support:";
    wallpaperInfoDiv.appendText(" " + getWallpaperPlatformNotes());
  }
  displayDebugSettings(containerEl) {
    new import_obsidian6.Setting(containerEl).setName("Show debug modal on save").setDesc("Show a modal with context details when saving").addToggle((t) => t.setValue(this.plugin.settings.showDebugModal).onChange(async (v) => {
      this.plugin.settings.showDebugModal = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Show debug modal on restore").setDesc("Show a modal comparing stored vs actual state after restoring").addToggle((t) => t.setValue(this.plugin.settings.showDebugModalOnRestore).onChange(async (v) => {
      this.plugin.settings.showDebugModalOnRestore = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Enable debug logging").setDesc("Log performance timing to the developer console (Cmd+Shift+I)").addToggle((t) => t.setValue(this.plugin.settings.enableDebugLogging).onChange(async (v) => {
      this.plugin.settings.enableDebugLogging = v;
      await this.plugin.saveSettings();
    }));
  }
  getHotkeyDisplay(commandId) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const extApp = this.app;
    const hotkeyManager = extApp.hotkeyManager;
    if (!hotkeyManager)
      return "Not set";
    const customHotkeys = (_a = hotkeyManager.customKeys) == null ? void 0 : _a[commandId];
    const defaultHotkeys = (_b = hotkeyManager.defaultKeys) == null ? void 0 : _b[commandId];
    const hotkeys = (customHotkeys == null ? void 0 : customHotkeys.length) ? customHotkeys : defaultHotkeys;
    if (!hotkeys || hotkeys.length === 0)
      return "Not set";
    const hotkey = hotkeys[0];
    const parts = [];
    const isMac = import_obsidian6.Platform.isMacOS;
    if ((_c = hotkey.modifiers) == null ? void 0 : _c.includes("Mod")) {
      parts.push(isMac ? "\u2318" : "Ctrl");
    }
    if ((_d = hotkey.modifiers) == null ? void 0 : _d.includes("Ctrl")) {
      parts.push(isMac ? "\u2303" : "Ctrl");
    }
    if ((_e = hotkey.modifiers) == null ? void 0 : _e.includes("Alt")) {
      parts.push(isMac ? "\u2325" : "Alt");
    }
    if ((_f = hotkey.modifiers) == null ? void 0 : _f.includes("Shift")) {
      parts.push(isMac ? "\u21E7" : "Shift");
    }
    if ((_g = hotkey.modifiers) == null ? void 0 : _g.includes("Meta")) {
      parts.push(isMac ? "\u2318" : "Win");
    }
    parts.push(((_h = hotkey.key) == null ? void 0 : _h.toUpperCase()) || "?");
    return parts.join(isMac ? "" : "+");
  }
};

// src/main.ts
async function getUidFromFile(app, file) {
  if (file.extension === "canvas") {
    return getUidFromCanvas(app, file);
  }
  if (file.extension === "base") {
    return getUidFromBase(app, file);
  }
  return getUidFromCache(app, file);
}
function resolveFile2(app, tab) {
  const result = resolveFile(app, tab);
  return { file: result.file, method: result.method };
}
var COORDINATE_DEBUG = false;
function getPropertiesCollapsed(view) {
  const containerEl = view == null ? void 0 : view.containerEl;
  if (!containerEl)
    return void 0;
  const metadataEl = containerEl.querySelector(".metadata-container");
  if (!metadataEl)
    return void 0;
  if (metadataEl.classList.contains("is-collapsed") || metadataEl.classList.contains("collapsed")) {
    return true;
  }
  const metadataContent = metadataEl.querySelector(".metadata-content");
  if (metadataContent && metadataContent.style.display === "none") {
    return true;
  }
  return false;
}
var PerspectaPlugin = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    this.focusedWindowIndex = -1;
    this.windowFocusListeners = /* @__PURE__ */ new Map();
    this.filesWithContext = /* @__PURE__ */ new Set();
    this.refreshIndicatorsTimeout = null;
    this.isClosingWindow = false;
    // Guard against operations during window close
    this.isUnloading = false;
    // Guard against operations during plugin unload
    this.pendingTimeouts = /* @__PURE__ */ new Set();
    // External context storage
    this.shiftCmdHeld = false;
    // ============================================================================
    // Context Restore (Optimized)
    // ============================================================================
    // Track path corrections during restore (populated by restoreTabGroup and helpers)
    this.pathCorrections = /* @__PURE__ */ new Map();
    this.isRestoring = false;
    // Queue of pending tab activations to process after restore
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    this.pendingTabActivations = [];
  }
  // Track Cmd+Shift for context restore on link click
  async onload() {
    await this.loadSettings();
    try {
      const stat2 = await this.app.vault.adapter.stat(`${this.manifest.dir}/main.js`);
      const ts = (stat2 == null ? void 0 : stat2.mtime) ? new Date(stat2.mtime).toLocaleString() : "unknown";
      console.log(`[Perspecta] Loaded v${this.manifest.version} (main.js: ${ts})`);
    } catch (e) {
      console.log(`[Perspecta] Loaded v${this.manifest.version}`);
    }
    this.checkVersionCompatibility();
    this.externalStore = new ExternalContextStore({ app: this.app, manifest: this.manifest });
    if (this.settings.storageMode === "external") {
      await this.externalStore.initialize();
    }
    this.hideInternalProperties();
    this.registerView(PROXY_VIEW_TYPE, (leaf) => new ProxyNoteView(leaf));
    this.addRibbonIcon("layout-grid", "Perspecta", () => {
    });
    this.addCommand({
      id: "save-context",
      name: "Save context",
      callback: () => this.saveContext()
    });
    this.addCommand({
      id: "restore-context",
      name: "Restore context",
      callback: () => this.restoreContext()
    });
    this.addCommand({
      id: "show-context-details",
      name: "Show context details",
      callback: () => this.showContextDetails()
    });
    this.addCommand({
      id: "convert-to-proxy",
      name: "Convert to proxy window",
      checkCallback: (checking) => {
        if (!this.settings.enableProxyWindows)
          return false;
        const activeLeaf = this.app.workspace.activeLeaf;
        if (!activeLeaf)
          return false;
        const win = activeLeaf.view.containerEl.win;
        if (!win || win === window)
          return false;
        if (!hasFile(activeLeaf.view))
          return false;
        const file = this.app.vault.getAbstractFileByPath(activeLeaf.view.file.path);
        if (!file)
          return false;
        if (!checking) {
          this.convertToProxyWindow(activeLeaf, file);
        }
        return true;
      }
    });
    this.setupFocusTracking();
    this.setupContextIndicator();
    this.app.workspace.onLayoutReady(() => {
      this.setupFileExplorerIndicators();
    });
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        if (file instanceof import_obsidian7.TFile && ["md", "canvas", "base"].includes(file.extension)) {
          menu.addItem((item) => {
            item.setTitle("Remember note context").setIcon("target").onClick(() => this.saveContext(file));
          });
        }
      })
    );
    this.registerDomEvent(document, "auxclick", (evt) => {
      if (evt.button === 1) {
        const link = evt.target.closest("a.internal-link");
        if (link) {
          evt.preventDefault();
          const href = link.getAttribute("data-href");
          if (href) {
            const file = this.app.metadataCache.getFirstLinkpathDest(href, "");
            if (file instanceof import_obsidian7.TFile)
              this.openInNewWindow(file);
          }
        }
      }
    });
    this.registerModifierKeyTracking(window);
    this.registerEvent(
      this.app.workspace.on("window-open", (_, win) => {
        this.registerModifierKeyTracking(win);
      })
    );
    this.registerEvent(this.app.workspace.on("file-open", (file) => {
      if (!file || !this.shiftCmdHeld)
        return;
      if (this.filesWithContext.has(file.path)) {
        setTimeout(() => {
          this.restoreContext(file, true);
        }, 50);
      }
      this.shiftCmdHeld = false;
    }));
    this.registerDomEvent(document, "click", (evt) => {
      const link = evt.target.closest("a.internal-link");
      if (!link || evt.button !== 0)
        return;
      const href = link.getAttribute("data-href");
      if (!href)
        return;
      const file = this.app.metadataCache.getFirstLinkpathDest(href, "");
      if (!(file instanceof import_obsidian7.TFile))
        return;
      if (evt.altKey) {
        evt.preventDefault();
        evt.stopPropagation();
        this.openInNewWindow(file);
      }
    }, true);
    this.addSettingTab(new PerspectaSettingTab(this.app, this));
  }
  async onunload() {
    this.isUnloading = true;
    if (this.refreshIndicatorsTimeout) {
      clearTimeout(this.refreshIndicatorsTimeout);
      this.refreshIndicatorsTimeout = null;
    }
    this.pendingTimeouts.forEach((timeout) => clearTimeout(timeout));
    this.pendingTimeouts.clear();
    await this.externalStore.cleanup();
    this.windowFocusListeners.forEach((listener, win) => {
      win.removeEventListener("focus", listener);
    });
    this.windowFocusListeners.clear();
    this.filesWithContext.clear();
  }
  /**
   * Creates a tracked timeout that will be automatically cleared on unload.
   * Use this instead of raw setTimeout for operations that might outlive the plugin.
   */
  safeTimeout(callback, delay2) {
    const timeout = setTimeout(() => {
      this.pendingTimeouts.delete(timeout);
      if (!this.isUnloading) {
        callback();
      }
    }, delay2);
    this.pendingTimeouts.add(timeout);
    return timeout;
  }
  // ============================================================================
  // Focus Tracking
  // ============================================================================
  setupFocusTracking() {
    this.registerDomEvent(window, "focus", () => this.focusedWindowIndex = -1);
    this.registerEvent(
      this.app.workspace.on("window-open", (_, win) => {
        this.trackPopoutWindowFocus(win);
      })
    );
    this.registerEvent(
      this.app.workspace.on("window-close", (_, win) => {
        this.isClosingWindow = true;
        const listener = this.windowFocusListeners.get(win);
        if (listener) {
          win.removeEventListener("focus", listener);
          this.windowFocusListeners.delete(win);
        }
        this.safeTimeout(() => {
          this.isClosingWindow = false;
        }, 100);
      })
    );
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        if (this.isClosingWindow) {
          return;
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", (_leaf) => {
        if (this.isClosingWindow)
          return;
      })
    );
  }
  /**
   * Register keydown/keyup listeners on a window to track Cmd+Shift for context restore.
   * Called for main window and each popout window.
   */
  registerModifierKeyTracking(win) {
    const doc = win.document;
    const keydownHandler = (evt) => {
      if (evt.shiftKey && (evt.metaKey || evt.ctrlKey)) {
        this.shiftCmdHeld = true;
      }
    };
    const keyupHandler = () => {
      this.shiftCmdHeld = false;
    };
    doc.addEventListener("keydown", keydownHandler);
    doc.addEventListener("keyup", keyupHandler);
  }
  trackPopoutWindowFocus(win) {
    if (this.windowFocusListeners.has(win))
      return;
    const listener = () => {
      if (this.isClosingWindow) {
        return;
      }
      PerfTimer.begin("popoutFocusHandler");
      const popouts = this.getPopoutWindowObjects();
      PerfTimer.mark("getPopoutWindowObjects");
      this.focusedWindowIndex = popouts.indexOf(win);
      PerfTimer.end("popoutFocusHandler");
    };
    win.addEventListener("focus", listener);
    this.windowFocusListeners.set(win, listener);
  }
  // ============================================================================
  // Window Arrangement Capture (Optimized)
  // ============================================================================
  captureWindowArrangement() {
    PerfTimer.mark("captureWindowArrangement:start");
    const workspace = asExtendedWorkspace(this.app.workspace);
    const main = this.captureWindowState(workspace.rootSplit, window);
    PerfTimer.mark("captureMainWindow");
    const popouts = this.capturePopoutStates();
    PerfTimer.mark("capturePopouts");
    const leftSidebar = this.captureSidebarState("left");
    const rightSidebar = this.captureSidebarState("right");
    PerfTimer.mark("captureSidebars");
    const screen = getPhysicalScreen();
    const sourceScreen = {
      width: screen.width,
      height: screen.height,
      aspectRatio: screen.width / screen.height
    };
    return {
      v: 2,
      ts: Date.now(),
      main,
      popouts,
      focusedWindow: this.focusedWindowIndex,
      leftSidebar,
      rightSidebar,
      sourceScreen
    };
  }
  captureWindowState(rootSplit, win) {
    const physical = {
      x: win.screenX,
      y: win.screenY,
      width: win.outerWidth,
      height: win.outerHeight
    };
    const virtual = physicalToVirtual(physical);
    if (COORDINATE_DEBUG) {
      console.log(`[Perspecta] captureWindowState:`, { physical, virtual });
    }
    return {
      root: rootSplit ? this.captureSplitOrTabs(rootSplit) : { type: "tabs", tabs: [] },
      x: virtual.x,
      y: virtual.y,
      width: virtual.width,
      height: virtual.height
    };
  }
  capturePopoutStates() {
    var _a, _b, _c, _d;
    const states = [];
    const containers = getFloatingWindowContainers(this.app.workspace);
    const seenWindows = /* @__PURE__ */ new Set();
    for (const container of containers) {
      const win = container == null ? void 0 : container.win;
      if (!win || win === window)
        continue;
      if (seenWindows.has(win)) {
        console.log("[Perspecta] Skipping duplicate window in capturePopoutStates");
        continue;
      }
      seenWindows.add(win);
      if (COORDINATE_DEBUG) {
        const firstChild = (_a = container == null ? void 0 : container.children) == null ? void 0 : _a[0];
        console.log(`[Perspecta] capturePopoutStates container:`, {
          containerType: (_b = container == null ? void 0 : container.constructor) == null ? void 0 : _b.name,
          containerDirection: container == null ? void 0 : container.direction,
          containerChildren: (_c = container == null ? void 0 : container.children) == null ? void 0 : _c.length,
          firstChildType: (_d = firstChild == null ? void 0 : firstChild.constructor) == null ? void 0 : _d.name,
          firstChildDirection: isSplit(firstChild) ? firstChild.direction : void 0
        });
      }
      if ((container == null ? void 0 : container.children) && container.children.length > 0) {
        const virtual = physicalToVirtual({
          x: win.screenX,
          y: win.screenY,
          width: win.outerWidth,
          height: win.outerHeight
        });
        const isProxy = this.isProxyWindow(container);
        states.push({
          root: this.captureSplitOrTabs(container),
          x: virtual.x,
          y: virtual.y,
          width: virtual.width,
          height: virtual.height,
          isProxy
        });
      }
    }
    return states;
  }
  /**
   * Check if a popout container contains a proxy view
   */
  isProxyWindow(container) {
    var _a, _b, _c, _d;
    if (!(container == null ? void 0 : container.children))
      return false;
    for (const child of container.children) {
      if (((_b = (_a = child == null ? void 0 : child.view) == null ? void 0 : _a.getViewType) == null ? void 0 : _b.call(_a)) === PROXY_VIEW_TYPE) {
        return true;
      }
      if (child == null ? void 0 : child.children) {
        for (const leaf of child.children) {
          if (((_d = (_c = leaf == null ? void 0 : leaf.view) == null ? void 0 : _c.getViewType) == null ? void 0 : _d.call(_c)) === PROXY_VIEW_TYPE) {
            return true;
          }
        }
      }
    }
    return false;
  }
  /**
   * Captures split or tab group state recursively.
   * Uses isSplit type guard for safe type narrowing.
   */
  captureSplitOrTabs(node) {
    var _a, _b;
    if (!node)
      return { type: "tabs", tabs: [] };
    if (isSplit(node)) {
      const children = [];
      const sizes = [];
      for (const child of node.children) {
        const childState = this.captureSplitOrTabs(child);
        if (childState.type === "split" || childState.tabs.length > 0) {
          children.push(childState);
          const tabContainer = child;
          const size = (_b = (_a = tabContainer.dimension) != null ? _a : tabContainer.size) != null ? _b : 50;
          sizes.push(size);
        }
      }
      if (children.length === 1)
        return children[0];
      if (children.length === 0)
        return { type: "tabs", tabs: [] };
      if (COORDINATE_DEBUG) {
        console.log(`[Perspecta] captureSplitOrTabs: direction=${node.direction}, children=${children.length}, sizes=${JSON.stringify(sizes)}`);
      }
      return { type: "split", direction: node.direction, children, sizes };
    }
    return this.captureTabGroup(node);
  }
  /**
   * Captures the state of a tab group.
   * Uses type-safe accessors for internal API access.
   */
  captureTabGroup(tabContainer) {
    const tabs = [];
    const children = (tabContainer == null ? void 0 : tabContainer.children) || [];
    const currentTabIndex = getCurrentTabIndex(tabContainer);
    if (PerfTimer.isEnabled()) {
      console.log(`[Perspecta] captureTabGroup: ${children.length} children, currentTab=${currentTabIndex}`);
    }
    for (let i = 0; i < children.length; i++) {
      const leaf = children[i];
      const view = leaf == null ? void 0 : leaf.view;
      if (hasFile(view)) {
        const file = view.file;
        const tFile = this.app.vault.getAbstractFileByPath(file.path);
        const uid = tFile instanceof import_obsidian7.TFile ? getUidFromCache(this.app, tFile) : void 0;
        const name = file.basename;
        const scroll = getScrollPosition(view);
        let canvasViewport;
        const viewport = getCanvasViewport(view);
        if (viewport) {
          canvasViewport = {
            tx: viewport.tx,
            ty: viewport.ty,
            zoom: viewport.tZoom
          };
        }
        const isActive = i === currentTabIndex;
        if (PerfTimer.isEnabled()) {
          console.log(`[Perspecta]   tab[${i}]: ${file.basename}, active=${isActive}, scroll=${scroll}${canvasViewport ? `, canvas: tx=${canvasViewport.tx.toFixed(0)}, ty=${canvasViewport.ty.toFixed(0)}, zoom=${canvasViewport.zoom.toFixed(2)}` : ""}`);
        }
        tabs.push({
          path: file.path,
          active: isActive,
          uid,
          name,
          scroll: typeof scroll === "number" ? scroll : void 0,
          propertiesCollapsed: getPropertiesCollapsed(view),
          canvasViewport
        });
      }
    }
    return { type: "tabs", tabs };
  }
  /**
   * Captures sidebar state including collapse state and active tab.
   * Uses multiple fallback methods for compatibility across Obsidian versions.
   *
   * @internal Uses internal Obsidian APIs: leftSplit, rightSplit, activeTabGroup
   */
  captureSidebarState(side) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const workspace = this.app.workspace;
    const sidebar = side === "left" ? workspace.leftSplit : workspace.rightSplit;
    if (!sidebar)
      return { collapsed: true };
    let activeTab;
    try {
      const sidebarWithGroup = sidebar;
      if ((_a = sidebarWithGroup.activeTabGroup) == null ? void 0 : _a.currentTab) {
        activeTab = (_d = (_c = (_b = sidebarWithGroup.activeTabGroup.currentTab) == null ? void 0 : _b.view) == null ? void 0 : _c.getViewType) == null ? void 0 : _d.call(_c);
      }
      if (!activeTab && sidebar.children) {
        for (const child of sidebar.children) {
          const container = child;
          if (container.children) {
            const currentIdx = getCurrentTabIndex(container);
            const currentLeaf = container.children[currentIdx];
            if (((_e = currentLeaf == null ? void 0 : currentLeaf.view) == null ? void 0 : _e.getViewType) && typeof currentLeaf.view.getViewType === "function") {
              activeTab = currentLeaf.view.getViewType();
              break;
            }
          }
        }
      }
      if (!activeTab) {
        const leaf = side === "left" ? workspace.leftLeaf : workspace.rightLeaf;
        activeTab = (_g = (_f = leaf == null ? void 0 : leaf.view) == null ? void 0 : _f.getViewType) == null ? void 0 : _g.call(_f);
      }
    } catch (e) {
    }
    return { collapsed: (_h = sidebar.collapsed) != null ? _h : false, activeTab };
  }
  getPopoutWindowObjects() {
    const start = performance.now();
    const windows = [];
    const seen = /* @__PURE__ */ new Set([window]);
    this.app.workspace.iterateAllLeaves((leaf) => {
      var _a, _b;
      const win = (_b = (_a = leaf.view) == null ? void 0 : _a.containerEl) == null ? void 0 : _b.win;
      if (win && !seen.has(win)) {
        if (this.isDevToolsWindow(win)) {
          seen.add(win);
          return;
        }
        seen.add(win);
        windows.push(win);
      }
    });
    const elapsed = performance.now() - start;
    if (elapsed > 20) {
      console.warn(`[Perspecta] \u26A0 SLOW getPopoutWindowObjects: ${elapsed.toFixed(1)}ms`);
    }
    return windows;
  }
  isDevToolsWindow(win) {
    var _a, _b;
    try {
      const url = ((_a = win.location) == null ? void 0 : _a.href) || "";
      const title = ((_b = win.document) == null ? void 0 : _b.title) || "";
      return url.includes("devtools://") || url.includes("chrome-devtools://") || title.includes("DevTools") || title.includes("Developer Tools");
    } catch (e) {
      return true;
    }
  }
  isDevToolsOpen() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    try {
      const remote = (_a = window.require) == null ? void 0 : _a.call(window, "@electron/remote");
      if (remote) {
        const win = remote.getCurrentWindow();
        return (_d = (_c = (_b = win == null ? void 0 : win.webContents) == null ? void 0 : _b.isDevToolsOpened) == null ? void 0 : _c.call(_b)) != null ? _d : false;
      }
      const legacyRemote = (_f = (_e = window.require) == null ? void 0 : _e.call(window, "electron")) == null ? void 0 : _f.remote;
      if (legacyRemote) {
        const win = legacyRemote.getCurrentWindow();
        return (_i = (_h = (_g = win == null ? void 0 : win.webContents) == null ? void 0 : _g.isDevToolsOpened) == null ? void 0 : _h.call(_g)) != null ? _i : false;
      }
    } catch (e) {
    }
    return false;
  }
  openDevTools() {
    var _a, _b, _c, _d, _e, _f, _g;
    try {
      const remote = (_a = window.require) == null ? void 0 : _a.call(window, "@electron/remote");
      if (remote) {
        const win = remote.getCurrentWindow();
        (_c = (_b = win == null ? void 0 : win.webContents) == null ? void 0 : _b.openDevTools) == null ? void 0 : _c.call(_b);
        return;
      }
      const legacyRemote = (_e = (_d = window.require) == null ? void 0 : _d.call(window, "electron")) == null ? void 0 : _e.remote;
      if (legacyRemote) {
        const win = legacyRemote.getCurrentWindow();
        (_g = (_f = win == null ? void 0 : win.webContents) == null ? void 0 : _f.openDevTools) == null ? void 0 : _g.call(_f);
        return;
      }
    } catch (e) {
    }
    if (this.settings.enableDebugLogging) {
      console.log("[Perspecta] Could not re-open DevTools - Electron remote not available");
    }
  }
  // ============================================================================
  // Context Save (Optimized)
  // ============================================================================
  async saveContext(file) {
    PerfTimer.begin("saveContext");
    const targetFile = file != null ? file : this.app.workspace.getActiveFile();
    PerfTimer.mark("getActiveFile");
    if (!targetFile) {
      new import_obsidian7.Notice("No active file to save context to", 4e3);
      return;
    }
    const isMarkdown = targetFile.extension === "md";
    const isCanvas = targetFile.extension === "canvas";
    const isBase = targetFile.extension === "base";
    if (!isMarkdown && !isCanvas && !isBase) {
      new import_obsidian7.Notice(`Cannot save context to ${targetFile.extension} files. Please use a markdown, canvas, or base file.`, 4e3);
      PerfTimer.end("saveContext");
      return;
    }
    let context = this.captureWindowArrangement();
    PerfTimer.mark("captureWindowArrangement");
    if (this.settings.enableWallpaperCapture) {
      try {
        const wallpaperResult = await getWallpaper();
        if (wallpaperResult.success && wallpaperResult.path) {
          let wallpaperPath = wallpaperResult.path;
          if (this.settings.storeWallpapersLocally) {
            const adapter = this.app.vault.adapter;
            if (adapter instanceof import_obsidian7.FileSystemAdapter) {
              const vaultPath = adapter.getBasePath();
              const wallpapersDir = getWallpapersDir(vaultPath, this.settings.perspectaFolderPath);
              const copyResult = await copyWallpaperToLocal(wallpaperPath, wallpapersDir);
              if (copyResult.success && copyResult.path) {
                wallpaperPath = copyResult.path;
                PerfTimer.mark("copyWallpaperToLocal");
              }
            }
          }
          context.wallpaper = wallpaperPath;
          PerfTimer.mark("captureWallpaper");
        }
      } catch (e) {
        console.log("[Perspecta] Could not capture wallpaper:", e);
      }
    }
    if (this.settings.autoGenerateUids || this.settings.storageMode === "external") {
      context = await this.ensureUidsForContext(context);
      PerfTimer.mark("ensureUidsForContext");
    }
    let saved = true;
    if (isCanvas) {
      await saveContextToCanvas(this.app, targetFile, context);
      this.filesWithContext.add(targetFile.path);
      this.debouncedRefreshIndicators();
      PerfTimer.mark("saveContextToCanvas");
    } else if (isBase) {
      await saveContextToBase(this.app, targetFile, context);
      this.filesWithContext.add(targetFile.path);
      this.debouncedRefreshIndicators();
      PerfTimer.mark("saveContextToBase");
    } else if (this.settings.storageMode === "external") {
      saved = await this.saveContextExternal(targetFile, context);
      PerfTimer.mark("saveContextExternal");
    } else {
      await this.saveArrangementToNote(targetFile, context);
      PerfTimer.mark("saveArrangementToNote");
    }
    if (saved) {
      if (this.settings.showDebugModal) {
        this.showContextDebugModal(context, targetFile.name);
        PerfTimer.mark("showContextDebugModal");
      } else {
        new import_obsidian7.Notice(`Context saved to ${targetFile.name}`, 4e3);
      }
    }
    PerfTimer.end("saveContext");
  }
  // Save context to external store (using file's UID as key)
  // Returns true if save was successful, false if cancelled
  async saveContextExternal(file, context) {
    let uid = getUidFromCache(this.app, file);
    if (!uid) {
      uid = generateUid();
      await addUidToFile(this.app, file, uid);
      await delay(TIMING.TAB_ACTIVATION_DELAY);
    }
    await this.externalStore.ensureInitialized();
    const maxArrangements = this.settings.maxArrangementsPerNote;
    const existingCount = this.externalStore.getCount(uid);
    if (maxArrangements === 1 && existingCount > 0 && !this.settings.autoConfirmOverwrite) {
      const existingArrangements = this.externalStore.getAll(uid);
      if (existingArrangements.length > 0) {
        const result = await showConfirmOverwrite(existingArrangements[0], file.name);
        if (!result.confirmed) {
          return false;
        }
      }
    }
    this.externalStore.set(uid, context, maxArrangements);
    await this.removeArrangementFromFrontmatter(file);
    this.filesWithContext.add(file.path);
    this.debouncedRefreshIndicators();
    return true;
  }
  // Remove perspecta-arrangement property from a file's frontmatter
  async removeArrangementFromFrontmatter(file) {
    const content = await this.app.vault.read(file);
    const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
    const match = content.match(frontmatterRegex);
    if (!match)
      return false;
    const fm = match[1];
    if (!fm.includes(`${FRONTMATTER_KEY}:`))
      return false;
    const newFm = fm.replace(/perspecta-arrangement:[\s\S]*?(?=\n[^\s]|\n$|$)/g, "").replace(/perspecta-arrangement: ".*"\n?/g, "").trim();
    const newContent = content.replace(frontmatterRegex, `---
${newFm}
---`);
    if (newContent !== content) {
      await this.app.vault.modify(file, newContent);
      return true;
    }
    return false;
  }
  // ============================================================================
  // Storage Migration & Cleanup
  // ============================================================================
  // Hide internal properties (perspecta-uid) from the Properties view
  // They remain visible in source mode for transparency
  hideInternalProperties() {
    try {
      if (!hasMetadataTypeManager(this.app))
        return;
      const metadataTypeManager = this.app.metadataTypeManager;
      if (metadataTypeManager.properties) {
        const props = metadataTypeManager.properties;
        if (props[UID_FRONTMATTER_KEY]) {
          props[UID_FRONTMATTER_KEY].hidden = true;
        } else {
          props[UID_FRONTMATTER_KEY] = { name: UID_FRONTMATTER_KEY, type: "text", hidden: true };
        }
      }
      if (typeof metadataTypeManager.setType === "function") {
        metadataTypeManager.setType(UID_FRONTMATTER_KEY, "text");
      }
      if (metadataTypeManager.types) {
        if (!metadataTypeManager.types[UID_FRONTMATTER_KEY]) {
          metadataTypeManager.types[UID_FRONTMATTER_KEY] = { type: "text" };
        }
        metadataTypeManager.types[UID_FRONTMATTER_KEY].hidden = true;
      }
      if (typeof metadataTypeManager.save === "function") {
        metadataTypeManager.save();
      }
    } catch (e) {
      console.log("[Perspecta] Could not hide internal properties:", e);
    }
  }
  // Clean up old 'uid' properties from all files that have perspecta-uid
  async cleanupOldUidProperties() {
    const files = this.app.vault.getMarkdownFiles();
    let cleaned = 0;
    for (const file of files) {
      try {
        if (await cleanupOldUid(this.app, file)) {
          cleaned++;
        }
      } catch (e) {
        console.warn(`[Perspecta] Failed to cleanup ${file.path}:`, e);
      }
    }
    return cleaned;
  }
  // Migrate all contexts from frontmatter to external storage
  async migrateToExternalStorage() {
    const files = this.app.vault.getMarkdownFiles();
    let migrated = 0;
    let errors = 0;
    await this.externalStore.ensureInitialized();
    for (const file of files) {
      try {
        const context = this.getContextFromNote(file);
        if (!context)
          continue;
        let uid = getUidFromCache(this.app, file);
        if (!uid) {
          uid = generateUid();
          await addUidToFile(this.app, file, uid);
          await briefPause();
        }
        const v2 = this.normalizeToV2(context);
        this.externalStore.set(uid, v2);
        await this.removeArrangementFromFrontmatter(file);
        migrated++;
      } catch (e) {
        console.error(`[Perspecta] Failed to migrate ${file.path}:`, e);
        errors++;
      }
    }
    await this.externalStore.flushDirty();
    this.settings.storageMode = "external";
    await this.saveSettings();
    this.filesWithContext.clear();
    await this.setupFileExplorerIndicators();
    return { migrated, errors };
  }
  // Migrate all contexts from external storage to frontmatter
  async migrateToFrontmatter() {
    const files = this.app.vault.getMarkdownFiles();
    let migrated = 0;
    let errors = 0;
    await this.externalStore.ensureInitialized();
    for (const file of files) {
      try {
        const uid = getUidFromCache(this.app, file);
        if (!uid)
          continue;
        const context = this.externalStore.getLatest(uid);
        if (!context)
          continue;
        await this.saveArrangementToNote(file, context);
        await this.externalStore.delete(uid);
        migrated++;
      } catch (e) {
        console.error(`[Perspecta] Failed to migrate ${file.path}:`, e);
        errors++;
      }
    }
    this.settings.storageMode = "frontmatter";
    await this.saveSettings();
    this.filesWithContext.clear();
    await this.setupFileExplorerIndicators();
    return { migrated, errors };
  }
  // Get the backup folder path
  getBackupFolderPath() {
    const basePath = this.settings.perspectaFolderPath.replace(/\/+$/, "");
    return `${basePath}/backups`;
  }
  // Backup all arrangements to the perspecta folder
  async backupArrangements() {
    await this.externalStore.ensureInitialized();
    const allArrangements = {};
    const uids = this.externalStore.getAllUids();
    for (const uid of uids) {
      const arrangements = this.externalStore.getAll(uid);
      if (arrangements.length > 0) {
        allArrangements[uid] = arrangements;
      }
    }
    const backupFolder = this.getBackupFolderPath();
    if (!await this.app.vault.adapter.exists(backupFolder)) {
      await this.app.vault.createFolder(backupFolder);
    }
    const now = new Date();
    const timestamp = now.toISOString().replace(/[:.]/g, "-").slice(0, 19);
    const backupFileName = `arrangements-backup-${timestamp}.json`;
    const backupPath = `${backupFolder}/${backupFileName}`;
    const backupData = {
      version: 1,
      createdAt: now.toISOString(),
      arrangementCount: Object.keys(allArrangements).length,
      arrangements: allArrangements
    };
    await this.app.vault.create(backupPath, JSON.stringify(backupData, null, 2));
    return { count: Object.keys(allArrangements).length, path: backupPath };
  }
  // List available backups
  async listBackups() {
    const backupFolder = this.getBackupFolderPath();
    if (!await this.app.vault.adapter.exists(backupFolder)) {
      return [];
    }
    const files = await this.app.vault.adapter.list(backupFolder);
    const backups = [];
    for (const filePath of files.files) {
      if (filePath.endsWith(".json")) {
        const fileName = filePath.split("/").pop() || "";
        const match = fileName.match(/arrangements-backup-(\d{4}-\d{2}-\d{2}T\d{2}-\d{2}-\d{2})\.json/);
        if (match) {
          const dateStr = match[1].replace(/-/g, (m, offset) => offset > 9 ? ":" : "-").replace("T", "T");
          const date = new Date(dateStr.slice(0, 10) + "T" + dateStr.slice(11).replace(/-/g, ":"));
          backups.push({ name: fileName, path: filePath, date });
        }
      }
    }
    backups.sort((a, b) => b.date.getTime() - a.date.getTime());
    return backups;
  }
  // Restore arrangements from a backup file
  async restoreFromBackup(backupPath, mode) {
    const backupName = backupPath.split("/").pop() || "backup";
    if (!mode) {
      const result = await showRestoreModeSelector(backupName);
      if (result.cancelled) {
        return { restored: 0, errors: 0, cancelled: true };
      }
      mode = result.mode;
    }
    let backupData;
    try {
      const content = await this.app.vault.adapter.read(backupPath);
      backupData = JSON.parse(content);
    } catch (e) {
      Logger.error("Failed to parse backup file:", e);
      new import_obsidian7.Notice("Failed to parse backup file. The file may be corrupted.");
      return { restored: 0, errors: 1 };
    }
    if (!backupData.arrangements || typeof backupData.arrangements !== "object") {
      new import_obsidian7.Notice("Invalid backup file format");
      return { restored: 0, errors: 1 };
    }
    await this.externalStore.ensureInitialized();
    let restored = 0;
    let errors = 0;
    if (mode === "overwrite") {
      await this.externalStore.clearAll();
    }
    for (const [uid, arrangements] of Object.entries(backupData.arrangements)) {
      try {
        const backupArrangements = arrangements;
        if (mode === "merge") {
          const existing = this.externalStore.get(uid) || [];
          const combined = [...existing];
          for (const backupItem of backupArrangements) {
            const alreadyExists = combined.some((e) => e.savedAt === backupItem.savedAt);
            if (!alreadyExists) {
              combined.push(backupItem);
            }
          }
          combined.sort((a, b) => b.savedAt - a.savedAt);
          const trimmed = combined.slice(0, this.settings.maxArrangementsPerNote);
          this.externalStore.clearUid(uid);
          for (const item of trimmed) {
            this.externalStore.set(uid, item.arrangement, this.settings.maxArrangementsPerNote);
          }
        } else {
          for (const item of backupArrangements) {
            this.externalStore.set(uid, item.arrangement, this.settings.maxArrangementsPerNote);
          }
        }
        restored++;
      } catch (e) {
        Logger.error(`Failed to restore arrangements for UID ${uid}:`, e);
        errors++;
      }
    }
    await this.externalStore.flushDirty();
    this.filesWithContext.clear();
    await this.setupFileExplorerIndicators();
    return { restored, errors };
  }
  // Generate UIDs for any files in the context that don't have them
  async ensureUidsForContext(context) {
    const filesToUpdate = [];
    this.collectFilesNeedingUids(context.main.root, filesToUpdate);
    for (const popout of context.popouts) {
      this.collectFilesNeedingUids(popout.root, filesToUpdate);
    }
    for (const { file, uid } of filesToUpdate) {
      try {
        await addUidToFile(this.app, file, uid);
        if (PerfTimer.isEnabled()) {
          console.log(`[Perspecta] Added UID to ${file.path}: ${uid}`);
        }
      } catch (e) {
        console.warn(`[Perspecta] Failed to add UID to ${file.path}:`, e);
      }
    }
    if (filesToUpdate.length > 0) {
      await delay(TIMING.TAB_ACTIVATION_DELAY);
    }
    if (filesToUpdate.length > 0) {
      return this.captureWindowArrangement();
    }
    return context;
  }
  // Helper to collect files that need UIDs from a workspace node
  collectFilesNeedingUids(node, result) {
    if (node.type === "tabs") {
      for (const tab of node.tabs) {
        if (!tab.uid) {
          const file = this.app.vault.getAbstractFileByPath(tab.path);
          if (file instanceof import_obsidian7.TFile && file.extension === "md") {
            const existingUid = getUidFromCache(this.app, file);
            if (!existingUid) {
              result.push({ file, uid: generateUid() });
            }
          }
        }
      }
    } else if (node.type === "split") {
      for (const child of node.children) {
        this.collectFilesNeedingUids(child, result);
      }
    }
  }
  async saveArrangementToNote(file, arrangement) {
    const readStart = performance.now();
    const content = await this.app.vault.read(file);
    if (PerfTimer.isEnabled()) {
      console.log(`[Perspecta]   \u2713 vault.read: ${(performance.now() - readStart).toFixed(1)}ms`);
    }
    const fmStart = performance.now();
    const newContent = this.updateFrontmatter(content, arrangement);
    if (PerfTimer.isEnabled()) {
      console.log(`[Perspecta]   \u2713 updateFrontmatter: ${(performance.now() - fmStart).toFixed(1)}ms`);
    }
    const writeStart = performance.now();
    await this.app.vault.modify(file, newContent);
    if (PerfTimer.isEnabled()) {
      console.log(`[Perspecta]   \u2713 vault.modify: ${(performance.now() - writeStart).toFixed(1)}ms`);
    }
  }
  updateFrontmatter(content, arrangement) {
    const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
    const match = content.match(frontmatterRegex);
    const encoded = this.encodeArrangement(arrangement);
    if (match) {
      let fm = match[1].replace(/perspecta-arrangement:[\s\S]*?(?=\n[^\s]|\n$|$)/g, "").replace(/perspecta-arrangement: ".*"/g, "").trim();
      fm = fm ? fm + "\n" + encoded : encoded;
      return content.replace(frontmatterRegex, `---
${fm}
---`);
    }
    return `---
${encoded}
---
${content}`;
  }
  // Encode arrangement as compact base64 JSON blob
  encodeArrangement(arr) {
    const compact = this.createCompactArrangement(arr);
    const json = JSON.stringify(compact);
    const base64 = encodeBase64(json);
    return `${FRONTMATTER_KEY}: "${base64}"`;
  }
  // Create compact arrangement with minimal data
  createCompactArrangement(arr) {
    const compact = {
      v: arr.v,
      ts: arr.ts,
      f: arr.focusedWindow,
      // short key: focusedWindow
      m: this.compactWindow(arr.main)
      // short key: main
    };
    if (arr.popouts.length > 0) {
      compact.p = arr.popouts.map((p) => this.compactWindow(p));
    }
    if (arr.leftSidebar) {
      compact.ls = { c: arr.leftSidebar.collapsed };
      if (arr.leftSidebar.activeTab)
        compact.ls.t = arr.leftSidebar.activeTab;
    }
    if (arr.rightSidebar) {
      compact.rs = { c: arr.rightSidebar.collapsed };
      if (arr.rightSidebar.activeTab)
        compact.rs.t = arr.rightSidebar.activeTab;
    }
    if (arr.sourceScreen) {
      compact.ar = Math.round(arr.sourceScreen.aspectRatio * 100) / 100;
    }
    if (arr.wallpaper) {
      compact.wp = arr.wallpaper;
    }
    return compact;
  }
  compactWindow(win) {
    const compact = {
      r: this.compactNode(win.root)
      // short key: root
    };
    if (win.x !== void 0 && win.y !== void 0 && win.width !== void 0 && win.height !== void 0) {
      compact.g = [win.x, win.y, win.width, win.height];
    }
    return compact;
  }
  compactNode(node) {
    if (node.type === "tabs") {
      return node.tabs.map((tab) => {
        const arr = [tab.path];
        if (tab.uid)
          arr.push(tab.uid);
        else if (tab.active)
          arr.push(null);
        if (tab.active)
          arr.push(1);
        return arr.length === 1 ? tab.path : arr;
      });
    } else {
      return {
        d: node.direction === "horizontal" ? "h" : "v",
        c: node.children.map((child) => this.compactNode(child))
      };
    }
  }
  // Decode base64 JSON blob back to WindowArrangementV2
  decodeArrangement(encoded) {
    try {
      const json = decodeBase64(encoded);
      const compact = JSON.parse(json);
      return this.expandCompactArrangement(compact);
    } catch (e) {
      console.error("[Perspecta] Failed to decode arrangement:", e);
      return null;
    }
  }
  expandCompactArrangement(compact) {
    var _a;
    const arr = {
      v: compact.v || 2,
      ts: compact.ts || Date.now(),
      focusedWindow: (_a = compact.f) != null ? _a : -1,
      main: this.expandWindow(compact.m),
      popouts: (compact.p || []).map((p) => this.expandWindow(p))
    };
    if (compact.ls) {
      arr.leftSidebar = { collapsed: compact.ls.c, activeTab: compact.ls.t };
    }
    if (compact.rs) {
      arr.rightSidebar = { collapsed: compact.rs.c, activeTab: compact.rs.t };
    }
    if (compact.ar) {
      arr.sourceScreen = {
        width: Math.round(1117 * compact.ar),
        // Use reference height
        height: 1117,
        aspectRatio: compact.ar
      };
    }
    if (compact.wp) {
      arr.wallpaper = compact.wp;
    }
    return arr;
  }
  expandWindow(compact) {
    const win = {
      root: this.expandNode(compact.r)
    };
    if (compact.g) {
      win.x = compact.g[0];
      win.y = compact.g[1];
      win.width = compact.g[2];
      win.height = compact.g[3];
    }
    return win;
  }
  expandNode(compact) {
    if (Array.isArray(compact)) {
      const tabs = compact.map((item) => {
        var _a, _b;
        if (typeof item === "string") {
          return { path: item, active: false, name: (_a = item.split("/").pop()) == null ? void 0 : _a.replace(/\.md$/, "") };
        } else {
          const path = item[0];
          const uid = item[1] || void 0;
          const active = item[2] === 1;
          return { path, uid, active, name: (_b = path.split("/").pop()) == null ? void 0 : _b.replace(/\.md$/, "") };
        }
      });
      return { type: "tabs", tabs };
    } else {
      return {
        type: "split",
        direction: compact.d === "h" ? "horizontal" : "vertical",
        children: compact.c.map((child) => this.expandNode(child))
      };
    }
  }
  // Guard against concurrent restores
  async restoreContext(file, forceLatest = false) {
    if (this.isRestoring) {
      console.log("[Perspecta] Skipping restoreContext - already restoring");
      return;
    }
    this.isRestoring = true;
    const fullStart = performance.now();
    PerfTimer.begin("restoreContext");
    this.pathCorrections.clear();
    const targetFile = file != null ? file : this.app.workspace.getActiveFile();
    PerfTimer.mark("getActiveFile");
    if (!targetFile) {
      new import_obsidian7.Notice("No active file", 4e3);
      this.isRestoring = false;
      return;
    }
    try {
      const contextResult = await this.getContextForFileWithSelection(targetFile, forceLatest);
      PerfTimer.mark("getContextForFileWithSelection");
      if (!contextResult || contextResult.cancelled) {
        PerfTimer.end("restoreContext");
        return;
      }
      const context = contextResult.context;
      if (!context) {
        new import_obsidian7.Notice("No context found in this note", 4e3);
        return;
      }
      const _focusedWin = await this.applyArrangement(context, targetFile.path);
      PerfTimer.mark("applyArrangement");
      if (this.settings.showDebugModalOnRestore) {
        setTimeout(() => {
          const v2Context = this.normalizeToV2(context);
          this.showRestoreDebugModal(v2Context, targetFile.name);
        }, 1e3);
      }
      if (this.pathCorrections.size > 0) {
        await this.updateContextWithCorrectedPaths(targetFile, context);
        PerfTimer.mark("updateContextWithCorrectedPaths");
      }
      PerfTimer.end("restoreContext");
      if (PerfTimer.isEnabled()) {
        requestIdleCallback(() => {
          const totalTime = performance.now() - fullStart;
          console.log(`[Perspecta] \u{1F3C1} Full restore (including render): ${totalTime.toFixed(0)}ms`);
        }, { timeout: 5e3 });
      }
    } finally {
      this.isRestoring = false;
    }
  }
  // Get context with potential user selection for multiple arrangements
  // If forceLatest is true, always use the most recent arrangement without showing selector
  async getContextForFileWithSelection(file, forceLatest = false) {
    if (file.extension === "canvas") {
      return { context: await getContextFromCanvas(this.app, file), cancelled: false };
    }
    if (file.extension === "base") {
      return { context: await getContextFromBase(this.app, file), cancelled: false };
    }
    if (this.settings.storageMode === "external") {
      const uid = getUidFromCache(this.app, file);
      if (uid) {
        await this.externalStore.ensureInitialized();
        const arrangements = this.externalStore.getAll(uid);
        if (arrangements.length === 0) {
          return { context: this.getContextFromNote(file), cancelled: false };
        }
        if (arrangements.length === 1 || forceLatest) {
          return { context: arrangements[0].arrangement, cancelled: false };
        }
        const result = await showArrangementSelector(
          arrangements,
          file.name,
          (savedAt) => {
            this.externalStore.deleteArrangement(uid, savedAt);
          }
        );
        if (result.cancelled) {
          return { context: null, cancelled: true };
        }
        return { context: result.arrangement.arrangement, cancelled: false };
      }
    }
    return { context: this.getContextFromNote(file), cancelled: false };
  }
  // Get context for file - handles markdown, canvas, base, and external storage
  async getContextForFile(file) {
    if (file.extension === "canvas") {
      return getContextFromCanvas(this.app, file);
    }
    if (file.extension === "base") {
      return getContextFromBase(this.app, file);
    }
    if (this.settings.storageMode === "external") {
      const uid = getUidFromCache(this.app, file);
      if (uid) {
        await this.externalStore.ensureInitialized();
        const context = this.externalStore.getLatest(uid);
        if (context)
          return context;
      }
    }
    return this.getContextFromNote(file);
  }
  getContextFromNote(file) {
    var _a;
    const cache = this.app.metadataCache.getFileCache(file);
    const rawValue = (_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a[FRONTMATTER_KEY];
    if (!rawValue)
      return null;
    if (typeof rawValue === "string") {
      return this.decodeArrangement(rawValue);
    } else {
      return rawValue;
    }
  }
  // Update saved context with corrected file paths after fallback resolution
  async updateContextWithCorrectedPaths(contextFile, originalContext) {
    if (this.pathCorrections.size === 0)
      return;
    const correctedContext = this.captureWindowArrangement();
    correctedContext.ts = originalContext.ts;
    correctedContext.focusedWindow = originalContext.focusedWindow;
    const v2Original = this.normalizeToV2(originalContext);
    if (v2Original.sourceScreen) {
      correctedContext.sourceScreen = v2Original.sourceScreen;
    }
    if (contextFile.extension === "canvas") {
      await saveContextToCanvas(this.app, contextFile, correctedContext);
    } else if (contextFile.extension === "base") {
      await saveContextToBase(this.app, contextFile, correctedContext);
    } else if (this.settings.storageMode === "external") {
      const uid = getUidFromCache(this.app, contextFile);
      if (uid) {
        this.externalStore.set(uid, correctedContext);
      }
    } else {
      await this.saveArrangementToNote(contextFile, correctedContext);
    }
    if (PerfTimer.isEnabled()) {
      console.log(`[Perspecta] Updated context with ${this.pathCorrections.size} corrected paths:`);
      this.pathCorrections.forEach((correction, oldPath) => {
        console.log(`  ${oldPath} \u2192 ${correction.newPath}`);
      });
    }
  }
  async applyArrangement(arrangement, contextNotePath) {
    var _a, _b;
    try {
      PerfTimer.mark("applyArrangement:start");
      const devToolsWasOpen = this.isDevToolsOpen();
      if (devToolsWasOpen && this.settings.enableDebugLogging) {
        console.log("[Perspecta] DevTools detected as open, will re-open after restore");
      }
      const v2 = this.normalizeToV2(arrangement);
      PerfTimer.mark("normalizeToV2");
      const useTiling = needsTiling(v2.sourceScreen);
      let tiledPositions = [];
      if (useTiling) {
        const windowCount = 1 + v2.popouts.length;
        tiledPositions = calculateTiledLayout(windowCount, v2.main);
        if (COORDINATE_DEBUG) {
          console.log(`[Perspecta] Using tiled layout due to aspect ratio mismatch:`, {
            sourceAspect: (_b = (_a = v2.sourceScreen) == null ? void 0 : _a.aspectRatio) == null ? void 0 : _b.toFixed(2),
            targetAspect: (getPhysicalScreen().width / getPhysicalScreen().height).toFixed(2),
            windowCount,
            tiledPositions
          });
        }
        new import_obsidian7.Notice(`Screen shape changed - tiling ${windowCount} windows`, 4e3);
      }
      PerfTimer.mark("checkTilingNeeded");
      const popoutWindows = this.getPopoutWindowObjects();
      PerfTimer.mark("getPopoutWindowObjects");
      if (this.settings.enableDebugLogging) {
        console.log(`[Perspecta] Found ${popoutWindows.length} popout windows to close`);
      }
      for (const win of popoutWindows) {
        this.closePopoutWindow(win);
      }
      PerfTimer.mark("closePopoutWindows");
      if (devToolsWasOpen) {
        this.openDevTools();
      }
      const mainLeaves = this.getMainWindowLeaves();
      PerfTimer.mark("getMainWindowLeaves");
      for (let i = 1; i < mainLeaves.length; i++)
        mainLeaves[i].detach();
      PerfTimer.mark("detachExtraLeaves");
      if (useTiling && tiledPositions.length > 0) {
        this.restoreWindowGeometryDirect(window, tiledPositions[0]);
      } else {
        this.restoreWindowGeometry(window, v2.main, v2.sourceScreen);
      }
      PerfTimer.mark("restoreWindowGeometry");
      const workspace = asExtendedWorkspace(this.app.workspace);
      await this.restoreWorkspaceNode(workspace.rootSplit, v2.main.root, mainLeaves[0]);
      PerfTimer.mark("restoreMainWorkspace");
      const restoredPaths = /* @__PURE__ */ new Set();
      const popoutsToRestore = [];
      for (let i = 0; i < v2.popouts.length; i++) {
        const firstTab = this.getFirstTab(v2.popouts[i].root);
        const popoutPath = firstTab == null ? void 0 : firstTab.path;
        if (popoutPath && restoredPaths.has(popoutPath)) {
          continue;
        }
        if (popoutPath) {
          restoredPaths.add(popoutPath);
        }
        const tiledPosition = useTiling && tiledPositions.length > i + 1 ? tiledPositions[i + 1] : void 0;
        popoutsToRestore.push({ index: i, state: v2.popouts[i], tiledPosition });
      }
      if (this.settings.enableParallelPopoutCreation && popoutsToRestore.length > 1) {
        await Promise.all(
          popoutsToRestore.map(async ({ index, state, tiledPosition }) => {
            await this.restorePopoutWindow(state, v2.sourceScreen, tiledPosition);
            PerfTimer.mark(`restorePopout[${index}]`);
          })
        );
        PerfTimer.mark("restorePopoutsParallel");
      } else {
        for (const { index, state, tiledPosition } of popoutsToRestore) {
          await this.restorePopoutWindow(state, v2.sourceScreen, tiledPosition);
          PerfTimer.mark(`restorePopout[${index}]`);
        }
      }
      if (this.pendingTabActivations.length > 0) {
        requestAnimationFrame(() => {
          setTimeout(() => {
            this.processPendingTabActivations();
          }, 100);
        });
      }
      if (v2.leftSidebar)
        this.restoreSidebarState("left", v2.leftSidebar);
      if (v2.rightSidebar)
        this.restoreSidebarState("right", v2.rightSidebar);
      PerfTimer.mark("restoreSidebars");
      if (this.settings.enableWallpaperRestore && v2.wallpaper) {
        setWallpaper(v2.wallpaper).then((result) => {
          if (result.success) {
            PerfTimer.mark("restoreWallpaper");
          } else {
            console.log("[Perspecta] Could not restore wallpaper:", result.error);
          }
        }).catch((e) => {
          console.log("[Perspecta] Wallpaper restoration failed:", e);
        });
      }
      this.scheduleScrollRestoration(v2.main.root);
      for (const popout of v2.popouts) {
        this.scheduleScrollRestoration(popout.root);
      }
      PerfTimer.mark("scheduleScrollRestoration");
      if (this.settings.enableDebugLogging) {
        console.log("[Perspecta] Scheduling properties restoration");
      }
      this.schedulePropertiesRestoration(v2.main.root);
      for (const popout of v2.popouts) {
        this.schedulePropertiesRestoration(popout.root);
      }
      PerfTimer.mark("schedulePropertiesRestoration");
      let contextNoteWin = null;
      if (contextNotePath) {
        contextNoteWin = this.findWindowContainingFile(contextNotePath);
      }
      const focusedWin = contextNoteWin != null ? contextNoteWin : this.getFocusedWindow(v2);
      if (focusedWin) {
        if (contextNotePath && contextNoteWin) {
          this.activateLeafByPath(contextNoteWin, contextNotePath);
        } else {
          this.activateWindowLeaf(focusedWin, v2);
        }
        focusedWin.focus();
        this.showFocusTint(focusedWin);
      }
      PerfTimer.mark("activateFocusedWindow");
      return focusedWin;
    } catch (e) {
      new import_obsidian7.Notice("Error restoring context: " + e.message, 4e3);
      return null;
    }
  }
  getMainWindowLeaves() {
    const leaves = [];
    this.app.workspace.iterateAllLeaves((leaf) => {
      var _a, _b;
      const win = (_b = (_a = leaf.view) == null ? void 0 : _a.containerEl) == null ? void 0 : _b.win;
      if ((!win || win === window) && this.isInRootSplit(leaf)) {
        leaves.push(leaf);
      }
    });
    return leaves;
  }
  normalizeToV2(arr) {
    if (arr.v === 2)
      return arr;
    const v1 = arr;
    return {
      v: 2,
      ts: v1.ts,
      focusedWindow: v1.focusedWindow,
      main: { root: { type: "tabs", tabs: v1.main.tabs }, x: v1.main.x, y: v1.main.y, width: v1.main.width, height: v1.main.height },
      popouts: v1.popouts.map((p) => ({ root: { type: "tabs", tabs: p.tabs }, x: p.x, y: p.y, width: p.width, height: p.height })),
      leftSidebar: v1.leftSidebar,
      rightSidebar: v1.rightSidebar
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async restoreWorkspaceNode(parent, state, existingLeaf) {
    if (!(state == null ? void 0 : state.type)) {
      const legacyState = state;
      if (Array.isArray(legacyState.tabs)) {
        return this.restoreTabGroup(parent, { type: "tabs", tabs: legacyState.tabs }, existingLeaf);
      }
      return existingLeaf;
    }
    return state.type === "tabs" ? this.restoreTabGroup(parent, state, existingLeaf) : this.restoreSplit(parent, state, existingLeaf);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async restoreTabGroup(_parent, state, existingLeaf) {
    var _a, _b, _c;
    if (!((_a = state.tabs) == null ? void 0 : _a.length))
      return existingLeaf;
    let activeTabIdx = state.tabs.findIndex((t) => t.active);
    if (activeTabIdx < 0)
      activeTabIdx = 0;
    const reorderedTabs = [];
    for (let i = 0; i < state.tabs.length; i++) {
      reorderedTabs.push({ tab: state.tabs[i], originalIndex: i });
    }
    reorderedTabs.sort((a, b) => {
      if (a.tab.active && !b.tab.active)
        return 1;
      if (!a.tab.active && b.tab.active)
        return -1;
      return a.originalIndex - b.originalIndex;
    });
    if (PerfTimer.isEnabled()) {
      console.log(`[Perspecta] restoreTabGroup: ${state.tabs.length} tabs, active at index ${activeTabIdx}`);
      console.log(`[Perspecta]   Opening order: ${reorderedTabs.map((r) => r.tab.name || r.tab.path).join(" \u2192 ")}`);
    }
    let firstLeaf;
    let container = null;
    let isFirstTabOpened = false;
    for (let i = 0; i < reorderedTabs.length; i++) {
      const { tab, originalIndex } = reorderedTabs[i];
      const tabStart = performance.now();
      const { file, method } = resolveFile2(this.app, tab);
      if (!file) {
        if (PerfTimer.isEnabled()) {
          console.log(`[Perspecta]   \u2717 File not found: ${tab.path} (tried path, uid: ${tab.uid || "none"}, name: ${tab.name || "none"})`);
        }
        continue;
      }
      if (method !== "path") {
        this.pathCorrections.set(tab.path, {
          newPath: file.path,
          newName: file.basename
        });
        if (PerfTimer.isEnabled()) {
          console.log(`[Perspecta]   \u21AA Resolved ${tab.path} \u2192 ${file.path} (via ${method})`);
        }
      }
      let leaf;
      if (!isFirstTabOpened && existingLeaf) {
        await existingLeaf.openFile(file);
        leaf = existingLeaf;
        container = existingLeaf.parent;
        firstLeaf = leaf;
        isFirstTabOpened = true;
      } else if (!isFirstTabOpened) {
        leaf = this.app.workspace.createLeafInParent(_parent, 0);
        await leaf.openFile(file);
        container = leaf.parent;
        firstLeaf = leaf;
        isFirstTabOpened = true;
      } else {
        if (!container)
          continue;
        leaf = this.app.workspace.createLeafInParent(container, (_c = (_b = container.children) == null ? void 0 : _b.length) != null ? _c : 0);
        await leaf.openFile(file);
      }
      const elapsed = performance.now() - tabStart;
      if (PerfTimer.isEnabled()) {
        const flag = elapsed > 50 ? "\u26A0 SLOW" : "\u2713";
        const methodSuffix = method !== "path" ? ` [${method}]` : "";
        console.log(`[Perspecta]   ${flag} openFile[${originalIndex}]: ${file.basename} - ${elapsed.toFixed(1)}ms${methodSuffix}${tab.active ? " [ACTIVE]" : ""}`);
      }
    }
    return firstLeaf;
  }
  /**
   * Restore a split structure.
   *
   * The challenge: Obsidian's getLeaf('split') creates splits at the LEAF level,
   * not at the container level. So if we have a horizontal container [A, B] and
   * split vertically from B, we get [A, vertical[B, C]] instead of vertical[[A,B], C].
   *
   * Solution: Use createLeafBySplit with the FIRST leaf of a nested structure.
   * When we split from the first leaf in a different direction, Obsidian properly
   * wraps the entire sibling group.
   *
   * For:
   *   vertical split
   *    horizontal split (A | B)
   *    C
   *
   * Order:
   * 1. Start with leaf (A)
   * 2. Build horizontal: split from A  B (now [A, B] in horizontal)
   * 3. Split vertically from A (FIRST leaf)  C
   *    This should wrap [A, B] as a unit
   */
  async restoreSplit(parent, state, existingLeaf) {
    var _a;
    if (!state.children.length)
      return existingLeaf;
    if (COORDINATE_DEBUG) {
      console.log(`[Perspecta] restoreSplit START: direction=${state.direction}, children=${state.children.length}, parent:`, {
        type: (_a = parent == null ? void 0 : parent.constructor) == null ? void 0 : _a.name,
        direction: parent == null ? void 0 : parent.direction
      });
    }
    if (parent && parent.direction !== state.direction) {
      parent.direction = state.direction;
      if (COORDINATE_DEBUG) {
        console.log(`[Perspecta] restoreSplit: changed parent direction to ${state.direction}`);
      }
    }
    let firstLeaf = existingLeaf;
    const firstChild = state.children[0];
    if (firstChild.type === "tabs") {
      const firstTab = firstChild.tabs[0];
      if (firstTab && existingLeaf) {
        const { file: f, method } = resolveFile2(this.app, firstTab);
        if (f) {
          if (method !== "path") {
            this.pathCorrections.set(firstTab.path, { newPath: f.path, newName: f.basename });
          }
          await existingLeaf.openFile(f);
        }
      }
      if (firstChild.tabs.length > 1 && existingLeaf) {
        await this.restoreRemainingTabs(existingLeaf, firstChild.tabs, 1);
      }
      firstLeaf = existingLeaf;
    } else {
      firstLeaf = await this.buildNestedSplit(existingLeaf, firstChild);
    }
    for (let i = 1; i < state.children.length; i++) {
      const child = state.children[i];
      await briefPause();
      const newLeaf = this.app.workspace.createLeafBySplit(firstLeaf, state.direction);
      await briefPause();
      if (child.type === "tabs") {
        const firstTab = child.tabs[0];
        if (firstTab) {
          const { file: f, method } = resolveFile2(this.app, firstTab);
          if (f) {
            if (method !== "path") {
              this.pathCorrections.set(firstTab.path, { newPath: f.path, newName: f.basename });
            }
            await newLeaf.openFile(f);
          }
        }
        if (child.tabs.length > 1) {
          await this.restoreRemainingTabs(newLeaf, child.tabs, 1);
        }
      } else {
        const firstTab = this.getFirstTabFromNode(child);
        if (firstTab) {
          const { file: f, method } = resolveFile2(this.app, firstTab);
          if (f) {
            if (method !== "path") {
              this.pathCorrections.set(firstTab.path, { newPath: f.path, newName: f.basename });
            }
            await newLeaf.openFile(f);
          }
        }
        await this.buildNestedSplit(newLeaf, child);
      }
    }
    if (state.sizes && state.sizes.length > 0 && firstLeaf) {
      await this.applySplitSizes(firstLeaf, state.sizes);
    }
    if (COORDINATE_DEBUG) {
      console.log(`[Perspecta] restoreSplit END: direction=${state.direction}`);
    }
    return firstLeaf;
  }
  /**
   * Apply saved sizes to a split container.
   * Gets the parent container from any leaf and sets dimension on its children.
   */
  async applySplitSizes(anyLeaf, sizes) {
    var _a, _b;
    await delay(TIMING.SCROLL_RESTORATION_DELAY);
    const extLeaf = asExtendedLeaf(anyLeaf);
    let parent = hasParent(extLeaf) && isSplit(extLeaf.parent) ? extLeaf.parent : null;
    let attempts = 0;
    const maxAttempts = 5;
    while (parent && attempts < maxAttempts) {
      if (((_a = parent.children) == null ? void 0 : _a.length) === sizes.length && parent.direction) {
        break;
      }
      parent = (_b = parent.parent) != null ? _b : null;
      attempts++;
    }
    if (!(parent == null ? void 0 : parent.children) || parent.children.length !== sizes.length) {
      Logger.debug(`applySplitSizes: could not find matching parent - expected ${sizes.length} children`);
      return;
    }
    const total = sizes.reduce((a, b) => a + b, 0);
    const normalizedSizes = sizes.map((s) => s / total * 100);
    Logger.debug(`applySplitSizes: found parent with ${parent.children.length} children, direction=${parent.direction}, applying sizes:`, normalizedSizes);
    for (let i = 0; i < normalizedSizes.length; i++) {
      const child = parent.children[i];
      if (child && normalizedSizes[i] !== void 0) {
        setContainerDimension(child, normalizedSizes[i]);
        Logger.debug(`applySplitSizes: set child[${i}].dimension = ${normalizedSizes[i]}`);
      }
    }
    const workspace = asExtendedWorkspace(this.app.workspace);
    triggerWorkspaceResize(workspace, workspace.rootSplit);
    Logger.debug(`applySplitSizes: triggered workspace resize`);
  }
  /**
   * Apply scroll position to a leaf's view.
   * Must be called after the file is fully loaded.
   */
  applyScrollToLeaf(leaf, scroll) {
    if (scroll === void 0 || scroll === 0)
      return;
    setTimeout(() => {
      if (applyScrollPosition(leaf.view, scroll)) {
        Logger.debug(`applyScrollToLeaf: scrolled to ${scroll}`);
      }
    }, 100);
  }
  /**
   * Collect scroll/viewport positions from a workspace node state and apply them to matching leaves.
   */
  scheduleScrollRestoration(state) {
    const scrollMap = /* @__PURE__ */ new Map();
    const canvasViewportMap = /* @__PURE__ */ new Map();
    this.collectViewPositions(state, scrollMap, canvasViewportMap);
    if (scrollMap.size === 0 && canvasViewportMap.size === 0)
      return;
    Logger.debug(`scheduleScrollRestoration: ${scrollMap.size} scroll, ${canvasViewportMap.size} canvas viewports`);
    setTimeout(() => {
      this.app.workspace.iterateAllLeaves((leaf) => {
        if (!hasFile(leaf.view))
          return;
        const file = leaf.view.file;
        if (scrollMap.has(file.path)) {
          const scroll = scrollMap.get(file.path);
          if (scroll !== void 0 && scroll > 0) {
            if (applyScrollPosition(leaf.view, scroll)) {
              Logger.debug(`scheduleScrollRestoration: ${file.basename} -> scroll ${scroll}`);
            }
          }
        }
        if (canvasViewportMap.has(file.path)) {
          const viewport = canvasViewportMap.get(file.path);
          if (viewport) {
            this.restoreCanvasViewport(leaf, viewport);
          }
        }
      });
    }, 500);
  }
  /**
   * Schedule properties collapse/expand restoration for all leaves.
   */
  schedulePropertiesRestoration(state) {
    const propsMap = /* @__PURE__ */ new Map();
    this.collectPropertiesState(state, propsMap);
    if (propsMap.size === 0) {
      return;
    }
    if (this.settings.enableDebugLogging) {
      console.log(`[Perspecta] Restoring properties for ${propsMap.size} files:`, Array.from(propsMap.entries()));
    }
    setTimeout(() => {
      this.app.workspace.iterateAllLeaves((leaf) => {
        if (!hasFile(leaf.view))
          return;
        const file = leaf.view.file;
        if (propsMap.has(file.path)) {
          const collapsed = propsMap.get(file.path);
          if (collapsed !== void 0) {
            if (this.settings.enableDebugLogging) {
              console.log(`[Perspecta] Restoring properties for ${file.path}: ${collapsed ? "collapsed" : "expanded"}`);
            }
            this.setPropertiesCollapsed(leaf.view, collapsed);
          }
        }
      });
    }, 1e3);
  }
  /**
   * Collect properties collapse/expand state from workspace node state.
   */
  collectPropertiesState(state, map) {
    if (state.type === "tabs") {
      for (const tab of state.tabs) {
        if (tab.propertiesCollapsed !== void 0) {
          map.set(tab.path, tab.propertiesCollapsed);
        }
      }
      return;
    }
    for (const child of state.children) {
      this.collectPropertiesState(child, map);
    }
  }
  /**
   * Set properties collapse/expand state for a view.
   */
  setPropertiesCollapsed(view, collapsed) {
    var _a;
    const containerEl = view == null ? void 0 : view.containerEl;
    if (!containerEl) {
      if (this.settings.enableDebugLogging) {
        console.log("[Perspecta] Properties restoration: no container element found");
      }
      return;
    }
    const metadataEl = containerEl.querySelector(".metadata-container");
    if (metadataEl) {
      const isCollapsed = metadataEl.classList.contains("is-collapsed") || metadataEl.classList.contains("collapsed");
      if (isCollapsed === collapsed) {
        return;
      }
      const toggle = metadataEl.querySelector(".metadata-properties-heading");
      if (toggle) {
        try {
          toggle.click();
          if (this.settings.enableDebugLogging) {
            const filePath = ((_a = view.file) == null ? void 0 : _a.path) || "unknown";
            console.log(`[Perspecta] Properties ${collapsed ? "collapsed" : "expanded"} for ${filePath}`);
          }
          return;
        } catch (e) {
          if (this.settings.enableDebugLogging) {
            console.log("[Perspecta] Properties restoration: click failed", e);
          }
        }
      }
    }
  }
  collectViewPositions(node, scrollMap, canvasViewportMap) {
    if (node.type === "tabs") {
      for (const tab of node.tabs) {
        if (tab.scroll !== void 0 && tab.scroll > 0) {
          scrollMap.set(tab.path, tab.scroll);
        }
        if (tab.canvasViewport) {
          canvasViewportMap.set(tab.path, tab.canvasViewport);
        }
      }
    } else {
      for (const child of node.children) {
        this.collectViewPositions(child, scrollMap, canvasViewportMap);
      }
    }
  }
  /**
   * Restore canvas viewport (pan and zoom)
   */
  restoreCanvasViewport(leaf, viewport) {
    if (!isCanvasView(leaf.view))
      return;
    const canvas = leaf.view.canvas;
    try {
      const currentZoom = canvas.tZoom || 1;
      const zoomDelta = viewport.zoom / currentZoom;
      if (typeof canvas.zoomBy === "function") {
        canvas.zoomBy(zoomDelta);
      }
      if (typeof canvas.panTo === "function") {
        canvas.panTo(viewport.tx, viewport.ty);
      }
      if (typeof canvas.markViewportChanged === "function") {
        canvas.markViewportChanged();
      }
      if (typeof canvas.requestFrame === "function") {
        canvas.requestFrame();
      }
      Logger.debug(`restoreCanvasViewport: ${hasFile(leaf.view) ? leaf.view.file.basename : "unknown"} -> tx=${viewport.tx.toFixed(0)}, ty=${viewport.ty.toFixed(0)}, zoom=${viewport.zoom.toFixed(2)}`);
    } catch (e) {
      Logger.debug("Could not restore canvas viewport:", e);
    }
  }
  /**
   * Build a nested split structure starting from a leaf.
   * Returns the first leaf in the created structure.
   */
  async buildNestedSplit(startLeaf, state) {
    if (!state.children.length || !startLeaf) {
      return startLeaf;
    }
    if (COORDINATE_DEBUG) {
      console.log(`[Perspecta] buildNestedSplit: direction=${state.direction}, children=${state.children.length}`);
    }
    let firstLeaf = startLeaf;
    const firstChild = state.children[0];
    if (firstChild.type === "tabs") {
      const firstTab = firstChild.tabs[0];
      if (firstTab) {
        const { file: f, method } = resolveFile2(this.app, firstTab);
        if (f) {
          if (method !== "path") {
            this.pathCorrections.set(firstTab.path, { newPath: f.path, newName: f.basename });
          }
          await startLeaf.openFile(f);
        }
      }
      if (firstChild.tabs.length > 1) {
        await this.restoreRemainingTabs(startLeaf, firstChild.tabs, 1);
      }
      firstLeaf = startLeaf;
    } else {
      const result = await this.buildNestedSplit(startLeaf, firstChild);
      if (result)
        firstLeaf = result;
    }
    for (let i = 1; i < state.children.length; i++) {
      const child = state.children[i];
      await briefPause();
      const newLeaf = this.app.workspace.createLeafBySplit(firstLeaf, state.direction);
      await briefPause();
      if (child.type === "tabs") {
        const firstTab = child.tabs[0];
        if (firstTab) {
          const { file: f, method } = resolveFile2(this.app, firstTab);
          if (f) {
            if (method !== "path") {
              this.pathCorrections.set(firstTab.path, { newPath: f.path, newName: f.basename });
            }
            await newLeaf.openFile(f);
          }
        }
        if (child.tabs.length > 1) {
          await this.restoreRemainingTabs(newLeaf, child.tabs, 1);
        }
      } else {
        const firstTab = this.getFirstTabFromNode(child);
        if (firstTab) {
          const { file: f, method } = resolveFile2(this.app, firstTab);
          if (f) {
            if (method !== "path") {
              this.pathCorrections.set(firstTab.path, { newPath: f.path, newName: f.basename });
            }
            await newLeaf.openFile(f);
          }
        }
        await this.buildNestedSplit(newLeaf, child);
      }
    }
    if (state.sizes && state.sizes.length > 0 && firstLeaf) {
      await this.applySplitSizes(firstLeaf, state.sizes);
    }
    return firstLeaf;
  }
  async restorePopoutWindow(state, sourceScreen, tiledPosition) {
    var _a, _b;
    const _popoutStart = performance.now();
    if (state.isProxy && this.settings.enableProxyWindows) {
      await this.restoreProxyWindow(state, sourceScreen, tiledPosition);
      return;
    }
    const firstTab = this.getFirstTab(state.root);
    if (!firstTab)
      return;
    const { file, method } = resolveFile2(this.app, firstTab);
    if (!file)
      return;
    if (method !== "path") {
      this.pathCorrections.set(firstTab.path, {
        newPath: file.path,
        newName: file.basename
      });
    }
    const openPopoutStart = performance.now();
    const popoutLeaf = this.app.workspace.openPopoutLeaf();
    if (PerfTimer.isEnabled()) {
      console.log(`[Perspecta]     \u2713 openPopoutLeaf: ${(performance.now() - openPopoutStart).toFixed(1)}ms`);
    }
    const openFileStart = performance.now();
    await popoutLeaf.openFile(file);
    if (PerfTimer.isEnabled()) {
      console.log(`[Perspecta]     \u2713 openFile (popout first): ${(performance.now() - openFileStart).toFixed(1)}ms`);
    }
    const win = (_b = (_a = popoutLeaf.view) == null ? void 0 : _a.containerEl) == null ? void 0 : _b.win;
    if (win) {
      if (tiledPosition) {
        this.restoreWindowGeometryDirect(win, tiledPosition);
      } else {
        this.restoreWindowGeometry(win, state, sourceScreen);
      }
    }
    if (state.root.type === "tabs") {
      await this.restorePopoutTabs(popoutLeaf, state.root.tabs);
    } else if (state.root.type === "split") {
      await this.restoreSplitOuterFirst(popoutLeaf, state.root);
    }
  }
  /**
   * Restore a proxy window (minimalist window showing just the note title)
   */
  async restoreProxyWindow(state, sourceScreen, tiledPosition) {
    var _a, _b;
    const firstTab = this.getFirstTab(state.root);
    if (!firstTab)
      return;
    const { file } = resolveFile2(this.app, firstTab);
    if (!file)
      return;
    let arrangementUid;
    const uid = await getUidFromFile(this.app, file);
    if (uid) {
      arrangementUid = uid;
    }
    let initialWidth = 250;
    let initialHeight = 80;
    if (tiledPosition) {
      initialWidth = tiledPosition.width;
      initialHeight = tiledPosition.height;
    } else if (state.width !== void 0 && state.height !== void 0) {
      const physical = virtualToPhysical({
        x: state.x || 0,
        y: state.y || 0,
        width: state.width,
        height: state.height
      });
      initialWidth = physical.width;
      initialHeight = physical.height;
    }
    const proxyLeaf = this.app.workspace.openPopoutLeaf({
      size: { width: initialWidth, height: initialHeight }
    });
    await proxyLeaf.setViewState({
      type: PROXY_VIEW_TYPE,
      state: {
        filePath: file.path,
        arrangementUid
      }
    });
    await delay(TIMING.TAB_ACTIVATION_DELAY);
    const win = (_b = (_a = proxyLeaf.view) == null ? void 0 : _a.containerEl) == null ? void 0 : _b.win;
    if (win) {
      if (tiledPosition) {
        this.restoreWindowGeometryDirect(win, tiledPosition);
      } else {
        this.restoreWindowGeometry(win, state, sourceScreen);
      }
    }
    if (PerfTimer.isEnabled()) {
      console.log(`[Perspecta]     \u2713 restoreProxyWindow: ${file.basename}`);
    }
  }
  // Restore split using "outer-first" approach:
  // 1. First create all siblings at the current level
  // 2. Then recursively fill in any nested splits
  async restoreSplitOuterFirst(existingLeaf, state) {
    var _a;
    if (!state.children.length)
      return;
    if (COORDINATE_DEBUG) {
      console.log(`[Perspecta] restoreSplitOuterFirst: direction=${state.direction}, children=${state.children.length}`);
    }
    const leafSlots = [];
    leafSlots.push(existingLeaf);
    let lastLeaf = existingLeaf;
    for (let i = 1; i < state.children.length; i++) {
      this.app.workspace.setActiveLeaf(lastLeaf, { focus: false });
      const newLeaf = this.app.workspace.getLeaf("split", state.direction);
      const childFirstTab = this.getFirstTabFromNode(state.children[i]);
      if (childFirstTab) {
        const { file: f, method } = resolveFile2(this.app, childFirstTab);
        if (f) {
          if (method !== "path") {
            this.pathCorrections.set(childFirstTab.path, {
              newPath: f.path,
              newName: f.basename
            });
          }
          await newLeaf.openFile(f);
        }
      }
      leafSlots.push(newLeaf);
      lastLeaf = newLeaf;
    }
    const firstTab = this.getFirstTabFromNode(state.children[0]);
    if (firstTab) {
      const { file: f, method } = resolveFile2(this.app, firstTab);
      if (f) {
        if (method !== "path") {
          this.pathCorrections.set(firstTab.path, {
            newPath: f.path,
            newName: f.basename
          });
        }
        await existingLeaf.openFile(f);
      }
    }
    if (COORDINATE_DEBUG) {
      Logger.debug(`restoreSplitOuterFirst: created ${leafSlots.length} leaf slots`);
      leafSlots.forEach((leaf, idx) => {
        const path = leaf && hasFile(leaf.view) ? leaf.view.file.path : "unknown";
        Logger.debug(`  slot[${idx}]: ${path}`);
      });
    }
    for (let i = 0; i < state.children.length; i++) {
      const child = state.children[i];
      const leafSlot = leafSlots[i];
      if (child.type === "tabs") {
        if (child.tabs.length > 1) {
          await this.restoreRemainingTabs(leafSlot, child.tabs, 1);
        }
      } else if (child.type === "split") {
        await this.restoreNestedSplitInPlace(leafSlot, child);
      }
    }
    if (((_a = state.sizes) == null ? void 0 : _a.length) && leafSlots.length > 0) {
      await this.applySplitSizes(leafSlots[0], state.sizes);
    }
  }
  // Restore a nested split within an existing leaf's position
  async restoreNestedSplitInPlace(leafSlot, state) {
    var _a, _b;
    if (state.children.length <= 1) {
      if (((_a = state.children[0]) == null ? void 0 : _a.type) === "tabs" && state.children[0].tabs.length > 1) {
        await this.restoreRemainingTabs(leafSlot, state.children[0].tabs, 1);
      }
      return;
    }
    if (COORDINATE_DEBUG) {
      console.log(`[Perspecta] restoreNestedSplitInPlace: direction=${state.direction}, children=${state.children.length}`);
    }
    const firstChild = state.children[0];
    if (firstChild.type === "tabs" && firstChild.tabs.length > 1) {
      await this.restoreRemainingTabs(leafSlot, firstChild.tabs, 1);
    } else if (firstChild.type === "split") {
      await this.restoreNestedSplitInPlace(leafSlot, firstChild);
    }
    let lastLeaf = leafSlot;
    for (let i = 1; i < state.children.length; i++) {
      const child = state.children[i];
      this.app.workspace.setActiveLeaf(lastLeaf, { focus: false });
      const newLeaf = this.app.workspace.getLeaf("split", state.direction);
      lastLeaf = newLeaf;
      const childFirstTab = this.getFirstTabFromNode(child);
      if (childFirstTab) {
        const { file: f, method } = resolveFile2(this.app, childFirstTab);
        if (f) {
          if (method !== "path") {
            this.pathCorrections.set(childFirstTab.path, {
              newPath: f.path,
              newName: f.basename
            });
          }
          await newLeaf.openFile(f);
        }
      }
      if (child.type === "tabs" && child.tabs.length > 1) {
        await this.restoreRemainingTabs(newLeaf, child.tabs, 1);
      } else if (child.type === "split") {
        await this.restoreNestedSplitInPlace(newLeaf, child);
      }
    }
    if ((_b = state.sizes) == null ? void 0 : _b.length) {
      await this.applySplitSizes(leafSlot, state.sizes);
    }
  }
  // Get the first tab from any node (tabs or split) - returns full TabState for fallback resolution
  getFirstTabFromNode(node) {
    if (node.type === "tabs") {
      return node.tabs[0] || null;
    } else if (node.type === "split" && node.children.length > 0) {
      return this.getFirstTabFromNode(node.children[0]);
    }
    return null;
  }
  /**
   * Restore tabs in a popout window, preserving both tab ORDER and active state.
   *
   * Strategy:
   * 1. Open all tabs in the correct order (preserving visual tab order)
   * 2. Track which leaf corresponds to the active tab
   * 3. Schedule the active tab to be selected after the window is fully ready
   */
  async restorePopoutTabs(existingLeaf, tabs) {
    var _a, _b;
    if (tabs.length <= 1)
      return;
    let activeTabIndex = tabs.findIndex((t) => t.active);
    if (activeTabIndex < 0)
      activeTabIndex = 0;
    const container = existingLeaf.parent;
    if (!container)
      return;
    Logger.debug(`restorePopoutTabs: ${tabs.length} tabs, active at index ${activeTabIndex}`);
    const openedLeaves = [];
    openedLeaves.push(existingLeaf);
    for (let i = 1; i < tabs.length; i++) {
      const tab = tabs[i];
      const { file, method } = resolveFile2(this.app, tab);
      if (!file) {
        Logger.debug(`  \u2717 File not found: ${tab.path}`);
        continue;
      }
      if (method !== "path") {
        this.pathCorrections.set(tab.path, {
          newPath: file.path,
          newName: file.basename
        });
      }
      const leaf = this.app.workspace.createLeafInParent(container, (_b = (_a = container.children) == null ? void 0 : _a.length) != null ? _b : 0);
      await leaf.openFile(file);
      openedLeaves.push(leaf);
      Logger.debug(`  \u2713 Opened[${i}]: ${file.basename}`);
    }
    const activeLeaf = openedLeaves[activeTabIndex];
    if (!activeLeaf)
      return;
    this.pendingTabActivations.push({
      container,
      activeTabIndex,
      activeLeaf
    });
    Logger.debug(`  Queued tab activation for index ${activeTabIndex}`);
  }
  /**
   * Process all pending tab activations after windows are fully initialized
   */
  processPendingTabActivations() {
    var _a;
    if (this.pendingTabActivations.length === 0)
      return;
    if (PerfTimer.isEnabled()) {
      console.log(`[Perspecta] Processing ${this.pendingTabActivations.length} pending tab activations`);
    }
    for (const { container, activeTabIndex, activeLeaf } of this.pendingTabActivations) {
      if (typeof container.currentTab !== "undefined") {
        container.currentTab = activeTabIndex;
        if (typeof container.updateTabDisplay === "function") {
          container.updateTabDisplay();
        }
        if (typeof container.onResize === "function") {
          container.onResize();
        }
      }
      if (typeof container.selectTab === "function") {
        container.selectTab(activeLeaf);
      }
      if ((_a = activeLeaf.view) == null ? void 0 : _a.containerEl) {
        activeLeaf.view.containerEl.focus();
      }
      if (PerfTimer.isEnabled()) {
        console.log(`[Perspecta]   Activated tab at index ${activeTabIndex}`);
      }
    }
    this.pendingTabActivations = [];
  }
  async restoreRemainingTabs(existingLeaf, tabs, startIndex) {
    var _a, _b;
    Logger.debug(`restoreRemainingTabs: ${tabs.length} total tabs, starting from index ${startIndex}`);
    let activeTabIndex = 0;
    for (let i = 0; i < tabs.length; i++) {
      if (tabs[i].active) {
        activeTabIndex = i;
        break;
      }
    }
    const parent = existingLeaf.parent;
    if (!parent)
      return;
    const tabsToOpen = [];
    for (let i = startIndex; i < tabs.length; i++) {
      tabsToOpen.push({ tab: tabs[i], index: i });
    }
    tabsToOpen.sort((a, b) => {
      if (a.tab.active && !b.tab.active)
        return 1;
      if (!a.tab.active && b.tab.active)
        return -1;
      return a.index - b.index;
    });
    const activeIsFirstTab = activeTabIndex === 0;
    for (const { tab, index } of tabsToOpen) {
      const { file, method } = resolveFile2(this.app, tab);
      if (!file) {
        Logger.debug(`  tab[${index}]: file not found for ${tab.path}`);
        continue;
      }
      if (method !== "path") {
        this.pathCorrections.set(tab.path, {
          newPath: file.path,
          newName: file.basename
        });
      }
      const leaf = this.app.workspace.createLeafInParent(parent, (_b = (_a = parent.children) == null ? void 0 : _a.length) != null ? _b : 0);
      await leaf.openFile(file);
      Logger.debug(`  tab[${index}]: opened ${file.basename}, active=${tab.active}`);
    }
    if (activeIsFirstTab) {
      setTimeout(() => {
        this.app.workspace.setActiveLeaf(existingLeaf, { focus: false });
        Logger.debug(`  Activated first tab (existingLeaf)`);
      }, 100);
    }
  }
  getFirstTab(node) {
    if (node.type === "tabs")
      return node.tabs[0] || null;
    for (const child of node.children) {
      const tab = this.getFirstTab(child);
      if (tab)
        return tab;
    }
    return null;
  }
  closePopoutWindow(win) {
    const leaves = [];
    this.app.workspace.iterateAllLeaves((leaf) => {
      var _a, _b;
      if (((_b = (_a = leaf.view) == null ? void 0 : _a.containerEl) == null ? void 0 : _b.win) === win)
        leaves.push(leaf);
    });
    leaves.forEach((l) => l.detach());
  }
  getFocusedWindow(arr) {
    if (arr.focusedWindow === -1)
      return window;
    const popouts = this.getPopoutWindowObjects();
    const win = popouts[arr.focusedWindow];
    if (win && win.document.body.classList.contains("perspecta-proxy-window")) {
      return window;
    }
    return win != null ? win : window;
  }
  findWindowContainingFile(filePath) {
    let foundWin = null;
    this.app.workspace.iterateAllLeaves((leaf) => {
      var _a, _b, _c;
      if (!foundWin && hasFile(leaf.view) && leaf.view.file.path === filePath) {
        const win = (_c = (_b = (_a = leaf.view) == null ? void 0 : _a.containerEl) == null ? void 0 : _b.win) != null ? _c : window;
        if (win !== window && win.document.body.classList.contains("perspecta-proxy-window")) {
          return;
        }
        foundWin = win;
      }
    });
    return foundWin;
  }
  activateLeafByPath(win, filePath) {
    this.app.workspace.iterateAllLeaves((leaf) => {
      var _a, _b;
      if (((_b = (_a = leaf.view) == null ? void 0 : _a.containerEl) == null ? void 0 : _b.win) === win && hasFile(leaf.view) && leaf.view.file.path === filePath) {
        this.app.workspace.setActiveLeaf(leaf, { focus: false });
      }
    });
  }
  activateWindowLeaf(win, arr) {
    var _a;
    const start = performance.now();
    const root = win === window ? arr.main.root : (_a = arr.popouts[this.getPopoutWindowObjects().indexOf(win)]) == null ? void 0 : _a.root;
    if (!root)
      return;
    const activePath = this.findActiveTabPath(root);
    if (!activePath)
      return;
    let targetLeaf = null;
    this.app.workspace.iterateAllLeaves((leaf) => {
      var _a2, _b;
      if (!targetLeaf && ((_b = (_a2 = leaf.view) == null ? void 0 : _a2.containerEl) == null ? void 0 : _b.win) === win && hasFile(leaf.view) && leaf.view.file.path === activePath) {
        targetLeaf = leaf;
      }
    });
    if (targetLeaf) {
      this.app.workspace.setActiveLeaf(targetLeaf, { focus: false });
    }
    const elapsed = performance.now() - start;
    if (elapsed > 50) {
      Logger.warn(`\u26A0 SLOW activateWindowLeaf: ${elapsed.toFixed(1)}ms`);
    }
  }
  findActiveTabPath(node) {
    var _a, _b;
    if (node.type === "tabs") {
      return ((_a = node.tabs.find((t) => t.active)) == null ? void 0 : _a.path) || ((_b = node.tabs[0]) == null ? void 0 : _b.path) || null;
    }
    for (const child of node.children) {
      const path = this.findActiveTabPath(child);
      if (path)
        return path;
    }
    return null;
  }
  restoreWindowGeometry(win, state, sourceScreen) {
    if (COORDINATE_DEBUG) {
      console.log(`[Perspecta] restoreWindowGeometry called`, {
        hasCoords: state.x !== void 0 && state.y !== void 0,
        hasSize: state.width !== void 0 && state.height !== void 0,
        state: { x: state.x, y: state.y, width: state.width, height: state.height },
        sourceScreen
      });
    }
    if (state.width === void 0 || state.height === void 0 || state.x === void 0 || state.y === void 0) {
      if (COORDINATE_DEBUG) {
        console.log(`[Perspecta] restoreWindowGeometry: missing coordinates, skipping`);
      }
      return;
    }
    const physical = virtualToPhysical({
      x: state.x,
      y: state.y,
      width: state.width,
      height: state.height
    }, sourceScreen);
    if (COORDINATE_DEBUG) {
      console.log(`[Perspecta] restoreWindowGeometry: applying`, physical);
    }
    try {
      win.resizeTo(physical.width, physical.height);
    } catch (e) {
    }
    try {
      win.moveTo(physical.x, physical.y);
    } catch (e) {
    }
  }
  // Apply geometry directly without virtual-to-physical conversion (used for tiled layouts)
  restoreWindowGeometryDirect(win, geometry) {
    if (COORDINATE_DEBUG) {
      console.log(`[Perspecta] restoreWindowGeometryDirect: applying`, geometry);
    }
    try {
      win.resizeTo(geometry.width, geometry.height);
    } catch (e) {
    }
    try {
      win.moveTo(geometry.x, geometry.y);
    } catch (e) {
    }
  }
  isInRootSplit(leaf) {
    var _a;
    const el = (_a = leaf.view) == null ? void 0 : _a.containerEl;
    return el ? !el.closest(".mod-left-split") && !el.closest(".mod-right-split") : true;
  }
  restoreSidebarState(side, state) {
    var _a, _b, _c;
    try {
      const workspace = asExtendedWorkspace(this.app.workspace);
      const sidebar = side === "left" ? workspace.leftSplit : workspace.rightSplit;
      if (!sidebar)
        return;
      if (state.collapsed) {
        (_a = sidebar.collapse) == null ? void 0 : _a.call(sidebar);
        return;
      }
      (_b = sidebar.expand) == null ? void 0 : _b.call(sidebar);
      if (state.activeTab) {
        const sidebarSelector = side === "left" ? ".mod-left-split" : ".mod-right-split";
        const leaves = this.app.workspace.getLeavesOfType(state.activeTab);
        const leaf = leaves.find((l) => {
          var _a2, _b2;
          return (_b2 = (_a2 = l.view) == null ? void 0 : _a2.containerEl) == null ? void 0 : _b2.closest(sidebarSelector);
        });
        if (leaf) {
          this.app.workspace.revealLeaf(leaf);
          try {
            const tabGroup = getLeafTabGroup(leaf);
            if (tabGroup == null ? void 0 : tabGroup.setActiveLeaf) {
              tabGroup.setActiveLeaf(leaf);
            } else if ((tabGroup == null ? void 0 : tabGroup.selectTab) && typeof tabGroup.selectTab === "function") {
              const tabIndex = (_c = tabGroup.children) == null ? void 0 : _c.indexOf(leaf);
              if (typeof tabIndex === "number" && tabIndex >= 0)
                tabGroup.selectTab(tabIndex);
            }
          } catch (e) {
          }
        }
      }
    } catch (e) {
    }
  }
  showFocusTint(win) {
    const duration = this.settings.focusTintDuration;
    if (duration <= 0)
      return;
    if (win.document.body.classList.contains("perspecta-proxy-window")) {
      return;
    }
    const overlay = win.document.createElement("div");
    overlay.className = "perspecta-focus-tint";
    overlay.style.animationDuration = `${duration}s`;
    win.document.body.appendChild(overlay);
    overlay.addEventListener("animationend", () => overlay.remove());
    const cleanup = safeTimeout(() => {
      if (overlay.parentNode) {
        overlay.remove();
      }
    }, duration * 1e3 + 500);
  }
  showNoticeInWindow(win, message, timeout = 4e3) {
    if (win && win !== window) {
      if (win.document.body.classList.contains("perspecta-proxy-window")) {
        new import_obsidian7.Notice(message, timeout);
        return;
      }
      const el = win.document.createElement("div");
      el.className = "notice";
      el.textContent = message;
      let container = win.document.body.querySelector(".notice-container");
      if (!container) {
        container = win.document.createElement("div");
        container.className = "notice-container";
        win.document.body.appendChild(container);
      }
      container.appendChild(el);
      setTimeout(() => el.remove(), timeout);
    } else {
      new import_obsidian7.Notice(message, timeout);
    }
  }
  // ============================================================================
  // Context Details View
  // ============================================================================
  async showContextDetails() {
    var _a, _b, _c;
    const file = this.app.workspace.getActiveFile();
    if (!file) {
      new import_obsidian7.Notice("No active file", 4e3);
      return;
    }
    const context = await this.getContextForFile(file);
    if (!context) {
      new import_obsidian7.Notice("No context found in this note", 4e3);
      return;
    }
    const activeLeaf = this.app.workspace.activeLeaf;
    const targetWindow = (_c = (_b = (_a = activeLeaf == null ? void 0 : activeLeaf.view) == null ? void 0 : _a.containerEl) == null ? void 0 : _b.win) != null ? _c : window;
    const v2 = this.normalizeToV2(context);
    this.showContextDetailsModal(v2, file.name, targetWindow);
  }
  showContextDetailsModal(context, fileName, targetWindow) {
    const doc = targetWindow.document;
    const overlay = doc.createElement("div");
    overlay.className = "perspecta-debug-overlay";
    const modal = doc.createElement("div");
    modal.className = "perspecta-debug-modal perspecta-details-modal";
    const _h3 = modal.createEl("h3", { text: "Context Details" });
    const header = modal.createDiv({ cls: "perspecta-details-header" });
    header.createSpan({ cls: "perspecta-details-file", text: fileName });
    const date = new Date(context.ts);
    header.createSpan({ cls: "perspecta-details-date", text: date.toLocaleDateString() + " " + date.toLocaleTimeString() });
    const content = modal.createDiv({ cls: "perspecta-details-content" });
    const mainSection = content.createDiv({ cls: "perspecta-window-section" });
    mainSection.createDiv({ cls: "perspecta-window-title", text: "Main Window" });
    this.buildNodeDetailsDOM(mainSection, context.main.root, context.focusedWindow === -1);
    context.popouts.forEach((p, i) => {
      const popoutSection = content.createDiv({ cls: "perspecta-window-section" });
      popoutSection.createDiv({ cls: "perspecta-window-title", text: `Popout ${i + 1}` });
      this.buildNodeDetailsDOM(popoutSection, p.root, context.focusedWindow === i);
    });
    if (context.sourceScreen) {
      const ar = context.sourceScreen.aspectRatio;
      const screenType = ar > 2 ? "ultrawide" : ar > 1.7 ? "wide" : "standard";
      content.createDiv({ cls: "perspecta-screen-info", text: `Screen: ${screenType} (${ar.toFixed(2)})` });
    }
    const closeBtn = modal.createEl("button", { cls: "perspecta-details-close", text: "Close" });
    const closeModal = () => {
      modal.remove();
      overlay.remove();
    };
    overlay.onclick = closeModal;
    closeBtn.addEventListener("click", closeModal);
    doc.body.appendChild(overlay);
    doc.body.appendChild(modal);
  }
  buildNodeDetailsDOM(container, node, isFocusedWindow, sizePercent) {
    var _a;
    if (node.type === "tabs") {
      const tabList = container.createDiv({ cls: "perspecta-tab-list" });
      if (sizePercent) {
        tabList.createSpan({ cls: "perspecta-size-badge", text: sizePercent });
      }
      for (const t of node.tabs) {
        const name = ((_a = t.path.split("/").pop()) == null ? void 0 : _a.replace(/\.md$/, "")) || t.path;
        const folder = t.path.includes("/") ? t.path.split("/").slice(0, -1).join("/") : "";
        const classes = ["perspecta-tab-item"];
        if (t.active)
          classes.push("perspecta-tab-active");
        if (t.active && isFocusedWindow)
          classes.push("perspecta-tab-focused");
        const tabItem = tabList.createDiv({ cls: classes.join(" ") });
        tabItem.createSpan({ cls: "perspecta-tab-name", text: name });
        if (t.uid) {
          tabItem.createSpan({ cls: "perspecta-uid-badge", text: "uid", attr: { title: "Has UID for move/rename resilience" } });
        }
        if (folder) {
          tabItem.createSpan({ cls: "perspecta-tab-folder", text: folder });
        }
      }
    } else {
      const icon = node.direction === "horizontal" ? "\u2194" : "\u2195";
      const sizes = node.sizes;
      const total = (sizes == null ? void 0 : sizes.reduce((a, b) => a + b, 0)) || 0;
      const percentages = sizes == null ? void 0 : sizes.map((s) => total > 0 ? Math.round(s / total * 100) + "%" : void 0);
      const splitDiv = container.createDiv({ cls: "perspecta-split" });
      const splitHeader = splitDiv.createDiv({ cls: "perspecta-split-header" });
      splitHeader.appendText(`${icon} Split (${node.direction})`);
      if (sizePercent) {
        splitHeader.createSpan({ cls: "perspecta-size-badge", text: sizePercent });
      }
      const childrenDiv = splitDiv.createDiv({ cls: "perspecta-split-children" });
      node.children.forEach((child, i) => {
        this.buildNodeDetailsDOM(childrenDiv, child, isFocusedWindow, percentages == null ? void 0 : percentages[i]);
      });
    }
  }
  // ============================================================================
  // Debug Modal (Save Confirmation)
  // ============================================================================
  showContextDebugModal(context, fileName) {
    const overlay = document.createElement("div");
    overlay.className = "perspecta-debug-overlay";
    const modal = document.createElement("div");
    modal.className = "perspecta-debug-modal";
    modal.createEl("h3", { text: "Context Saved" });
    const fileP = modal.createEl("p");
    fileP.createEl("strong", { text: "File: " });
    fileP.appendText(fileName);
    const focusedP = modal.createEl("p");
    focusedP.createEl("strong", { text: "Focused: " });
    focusedP.appendText(context.focusedWindow === -1 ? "Main" : `Popout #${context.focusedWindow + 1}`);
    modal.createEl("h4", { text: "Main Window" });
    this.buildDebugNodeDOM(modal, context.main.root, 0);
    if (context.popouts.length) {
      modal.createEl("h4", { text: `Popouts (${context.popouts.length})` });
      context.popouts.forEach((p, i) => {
        modal.createEl("p", { text: `Popout #${i + 1}:` });
        this.buildDebugNodeDOM(modal, p.root, 0);
      });
    }
    const closeBtn = modal.createEl("button", { cls: "perspecta-debug-close", text: "Close" });
    const closeModal = () => {
      modal.remove();
      overlay.remove();
    };
    overlay.onclick = closeModal;
    closeBtn.addEventListener("click", closeModal);
    document.body.appendChild(overlay);
    document.body.appendChild(modal);
  }
  showRestoreDebugModal(storedContext, fileName) {
    const overlay = document.createElement("div");
    overlay.className = "perspecta-debug-overlay";
    const modal = document.createElement("div");
    modal.className = "perspecta-debug-modal";
    modal.createEl("h3", { text: "Context Restored - Comparison" });
    const fileP = modal.createEl("p");
    fileP.createEl("strong", { text: "File: " });
    fileP.appendText(fileName);
    modal.createEl("h4", { text: "\u{1F4CB} Stored State" });
    const storedSection = modal.createEl("div", { cls: "perspecta-debug-section" });
    this.buildDebugNodeDOM(storedSection, storedContext.main.root, 0);
    if (storedContext.popouts.length) {
      modal.createEl("h4", { text: `\u{1F4CB} Stored Popouts (${storedContext.popouts.length})` });
      storedContext.popouts.forEach((p, i) => {
        const popoutDiv = modal.createEl("div");
        popoutDiv.createEl("p", { text: `Popout #${i + 1}:` });
        this.buildDebugNodeDOM(popoutDiv, p.root, 0);
      });
    }
    modal.createEl("h4", { text: "\u{1F50D} Current State (After Restore)" });
    const currentSection = modal.createEl("div", { cls: "perspecta-debug-section" });
    const currentContext = this.captureWindowArrangement();
    this.buildDebugNodeDOM(currentSection, currentContext.main.root, 0);
    if (currentContext.popouts.length) {
      modal.createEl("h4", { text: `\u{1F50D} Current Popouts (${currentContext.popouts.length})` });
      currentContext.popouts.forEach((p, i) => {
        const popoutDiv = modal.createEl("div");
        popoutDiv.createEl("p", { text: `Popout #${i + 1}:` });
        this.buildDebugNodeDOM(popoutDiv, p.root, 0);
      });
    }
    const closeBtn = modal.createEl("button", { cls: "perspecta-debug-close", text: "Close" });
    const closeModal = () => {
      modal.remove();
      overlay.remove();
    };
    overlay.onclick = closeModal;
    closeBtn.addEventListener("click", closeModal);
    document.body.appendChild(overlay);
    document.body.appendChild(modal);
  }
  buildDebugNodeDOM(container, node, depth, sizePercent) {
    const wrapper = container.createDiv({ cls: `perspecta-debug-node perspecta-debug-depth-${depth}` });
    if (node.type === "tabs") {
      const header = wrapper.createSpan({ cls: "perspecta-debug-muted", text: "Tabs" });
      if (sizePercent) {
        header.createSpan({ cls: "perspecta-debug-size", text: ` (${sizePercent})` });
      }
      for (const t of node.tabs) {
        const tabLine = wrapper.createDiv({ cls: "perspecta-debug-tab" });
        tabLine.appendText(`\u{1F4C4} ${t.path.split("/").pop() || t.path}`);
        if (t.active)
          tabLine.appendText(" \u2713");
        if (t.propertiesCollapsed !== void 0) {
          const propsIcon = t.propertiesCollapsed ? "\u{1F53D}" : "\u{1F53C}";
          const propsText = t.propertiesCollapsed ? "Properties collapsed" : "Properties expanded";
          tabLine.createSpan({ cls: "perspecta-debug-props", text: ` ${propsIcon} ${propsText}` });
        }
      }
    } else {
      const sizes = node.sizes;
      const total = (sizes == null ? void 0 : sizes.reduce((a, b) => a + b, 0)) || 0;
      const percentages = sizes == null ? void 0 : sizes.map((s) => total > 0 ? Math.round(s / total * 100) + "%" : void 0);
      const icon = node.direction === "horizontal" ? "\u2194\uFE0F" : "\u2195\uFE0F";
      const header = wrapper.createDiv();
      header.appendText(`${icon} `);
      header.createEl("strong", { text: "Split" });
      header.appendText(` (${node.direction})`);
      if (sizePercent) {
        header.createSpan({ cls: "perspecta-debug-size", text: ` (${sizePercent})` });
      }
      node.children.forEach((child, i) => {
        this.buildDebugNodeDOM(wrapper, child, depth + 1, percentages == null ? void 0 : percentages[i]);
      });
    }
  }
  // ============================================================================
  // Context Indicator
  // ============================================================================
  setupContextIndicator() {
    this.registerEvent(this.app.workspace.on("file-open", (file) => {
      if (this.isClosingWindow)
        return;
      this.updateContextIndicator(file);
    }));
    this.registerEvent(this.app.metadataCache.on("changed", (file) => {
      if (this.isClosingWindow)
        return;
      if (file === this.app.workspace.getActiveFile())
        this.updateContextIndicator(file);
      this.updateFileExplorerIndicator(file);
    }));
  }
  updateContextIndicator(file) {
    var _a, _b;
    PerfTimer.begin("updateContextIndicator");
    const allDocs = this.getAllWindowDocuments();
    for (const doc of allDocs) {
      doc.querySelectorAll(".view-header-title-container .perspecta-context-indicator").forEach((el) => el.remove());
    }
    PerfTimer.mark("removeOldIndicators");
    if (!file) {
      PerfTimer.end("updateContextIndicator");
      return;
    }
    const hasContextFrontmatter = ((_b = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter) == null ? void 0 : _b[FRONTMATTER_KEY]) !== null;
    let hasContextExternal = false;
    if (this.settings.storageMode === "external") {
      const uid = getUidFromCache(this.app, file);
      if (uid && this.externalStore.has(uid)) {
        hasContextExternal = true;
      }
    }
    const hasContext = hasContextFrontmatter || hasContextExternal;
    PerfTimer.mark("checkHasContext");
    if (hasContext) {
      for (const doc of allDocs) {
        const header = doc.querySelector(".workspace-leaf.mod-active .view-header-title-container");
        if (header && !header.querySelector(".perspecta-context-indicator")) {
          const icon = this.createTargetIcon(doc);
          icon.setAttribute("aria-label", "Has saved context - click to restore");
          icon.addEventListener("click", () => this.restoreContext(file));
          header.appendChild(icon);
        }
      }
    }
    PerfTimer.end("updateContextIndicator");
  }
  /**
   * Get all window documents (main window + popouts)
   */
  getAllWindowDocuments() {
    const docs = [document];
    if (hasFloatingSplit(this.app.workspace)) {
      for (const container of this.app.workspace.floatingSplit.children) {
        const win = container == null ? void 0 : container.win;
        if (win && win !== window && win.document) {
          docs.push(win.document);
        }
      }
    }
    return docs;
  }
  createTargetIcon(doc = document) {
    const el = doc.createElement("span");
    el.className = "perspecta-context-indicator";
    (0, import_obsidian7.setIcon)(el, "target");
    return el;
  }
  // ============================================================================
  // File Explorer Indicators
  // ============================================================================
  async setupFileExplorerIndicators() {
    var _a, _b;
    PerfTimer.begin("setupFileExplorerIndicators");
    const mdFiles = this.app.vault.getMarkdownFiles();
    PerfTimer.mark(`getMarkdownFiles (${mdFiles.length} files)`);
    for (const file of mdFiles) {
      if ((_b = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter) == null ? void 0 : _b[FRONTMATTER_KEY]) {
        this.filesWithContext.add(file.path);
      }
    }
    PerfTimer.mark("scanForContextFiles (frontmatter)");
    const canvasFiles = this.app.vault.getFiles().filter((f) => f.extension === "canvas");
    for (const file of canvasFiles) {
      if (await canvasHasContext(this.app, file)) {
        this.filesWithContext.add(file.path);
      }
    }
    PerfTimer.mark(`scanForContextFiles (canvas: ${canvasFiles.length} files)`);
    const baseFiles = this.app.vault.getFiles().filter((f) => f.extension === "base");
    for (const file of baseFiles) {
      if (await baseHasContext(this.app, file)) {
        this.filesWithContext.add(file.path);
      }
    }
    PerfTimer.mark(`scanForContextFiles (base: ${baseFiles.length} files)`);
    if (this.settings.storageMode === "external") {
      await this.externalStore.ensureInitialized();
      const uidsWithContext = this.externalStore.getAllUids();
      for (const file of mdFiles) {
        const uid = getUidFromCache(this.app, file);
        if (uid && uidsWithContext.includes(uid)) {
          this.filesWithContext.add(file.path);
        }
      }
      PerfTimer.mark("scanForContextFiles (external)");
    }
    this.registerEvent(this.app.workspace.on("layout-change", () => this.debouncedRefreshIndicators()));
    this.registerEvent(
      this.app.metadataCache.on("changed", (file) => {
        if (this.isClosingWindow || this.isUnloading)
          return;
        if (["md", "canvas", "base"].includes(file.extension)) {
          this.updateFileExplorerIndicator(file);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (file, oldPath) => {
        if (this.isClosingWindow || this.isUnloading)
          return;
        if (this.filesWithContext.has(oldPath)) {
          this.filesWithContext.delete(oldPath);
          this.filesWithContext.add(file.path);
          this.debouncedRefreshIndicators();
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("delete", (file) => {
        if (this.isClosingWindow || this.isUnloading)
          return;
        if (this.filesWithContext.has(file.path)) {
          this.filesWithContext.delete(file.path);
          this.debouncedRefreshIndicators();
        }
      })
    );
    this.safeTimeout(() => this.refreshFileExplorerIndicators(), 500);
    PerfTimer.end("setupFileExplorerIndicators");
  }
  async updateFileExplorerIndicator(file) {
    var _a, _b;
    let hasContext = false;
    if (file.extension === "canvas") {
      hasContext = await canvasHasContext(this.app, file);
    } else if (file.extension === "base") {
      hasContext = await baseHasContext(this.app, file);
    } else {
      hasContext = ((_b = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter) == null ? void 0 : _b[FRONTMATTER_KEY]) !== null;
      if (!hasContext && this.settings.storageMode === "external") {
        const uid = getUidFromCache(this.app, file);
        if (uid && this.externalStore.has(uid)) {
          hasContext = true;
        }
      }
    }
    hasContext ? this.filesWithContext.add(file.path) : this.filesWithContext.delete(file.path);
    this.debouncedRefreshIndicators();
  }
  debouncedRefreshIndicators() {
    if (this.refreshIndicatorsTimeout)
      clearTimeout(this.refreshIndicatorsTimeout);
    this.refreshIndicatorsTimeout = setTimeout(() => {
      if (this.isClosingWindow) {
        this.refreshIndicatorsTimeout = null;
        return;
      }
      this.refreshFileExplorerIndicators();
      this.refreshIndicatorsTimeout = null;
    }, 100);
  }
  refreshFileExplorerIndicators() {
    PerfTimer.begin("refreshFileExplorerIndicators");
    document.querySelectorAll(".nav-file-title .perspecta-context-indicator").forEach((el) => el.remove());
    PerfTimer.mark("removeOldIndicators");
    this.filesWithContext.forEach((path) => {
      const el = document.querySelector(`.nav-file-title[data-path="${CSS.escape(path)}"]`);
      if (el && !el.querySelector(".perspecta-context-indicator")) {
        const icon = this.createTargetIcon();
        icon.setAttribute("aria-label", "Has saved context");
        el.insertBefore(icon, el.firstChild);
      }
    });
    PerfTimer.mark(`addIndicators (${this.filesWithContext.size} files)`);
    PerfTimer.end("refreshFileExplorerIndicators");
  }
  // ============================================================================
  // Utility
  // ============================================================================
  async openInNewWindow(file) {
    const leaf = this.app.workspace.openPopoutLeaf();
    await leaf.openFile(file);
  }
  /**
   * Convert a popout window to a minimalist proxy window (experimental)
   */
  async convertToProxyWindow(leaf, file) {
    var _a, _b;
    const win = leaf.view.containerEl.win;
    const x = (win == null ? void 0 : win.screenX) || 100;
    const y = (win == null ? void 0 : win.screenY) || 100;
    let arrangementUid;
    const uid = await getUidFromFile(this.app, file);
    if (uid && this.settings.storageMode === "external") {
      const arrangements = this.externalStore.getAll(uid);
      if (arrangements.length > 0) {
        arrangementUid = uid;
      }
    } else if (this.settings.storageMode === "frontmatter" && file.extension === "md") {
      const hasContext = await markdownHasContext(this.app, file);
      if (hasContext) {
        arrangementUid = uid || "frontmatter";
      }
    }
    leaf.detach();
    await new Promise((resolve) => setTimeout(resolve, 100));
    const proxyLeaf = this.app.workspace.openPopoutLeaf({
      size: { width: 250, height: 50 }
    });
    await proxyLeaf.setViewState({
      type: PROXY_VIEW_TYPE,
      state: {
        filePath: file.path,
        arrangementUid
      }
    });
    await new Promise((resolve) => setTimeout(resolve, 100));
    const newWin = (_b = (_a = proxyLeaf.view) == null ? void 0 : _a.containerEl) == null ? void 0 : _b.win;
    if (newWin && newWin !== window) {
      try {
        newWin.moveTo(x, y);
      } catch (e) {
      }
    }
  }
  /**
   * Checks if the current Obsidian version is compatible with the plugin.
   * Warns users about potential issues with older versions.
   *
   * Minimum recommended version: 1.4.0 (for metadataTypeManager API)
   */
  checkVersionCompatibility() {
    const MIN_RECOMMENDED_VERSION = "1.4.0";
    try {
      const currentVersion = this.app.version;
      if (!currentVersion)
        return;
      const parseVersion = (v) => {
        return v.split(".").map((n) => parseInt(n, 10) || 0);
      };
      const current = parseVersion(currentVersion);
      const minimum = parseVersion(MIN_RECOMMENDED_VERSION);
      let isOlder = false;
      for (let i = 0; i < minimum.length; i++) {
        if ((current[i] || 0) < minimum[i]) {
          isOlder = true;
          break;
        } else if ((current[i] || 0) > minimum[i]) {
          break;
        }
      }
      if (isOlder) {
        console.warn(
          `[Perspecta] Obsidian version ${currentVersion} detected. Some features may not work correctly. Recommended version: ${MIN_RECOMMENDED_VERSION} or later.`
        );
      }
    } catch (e) {
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.validateSettings();
    this.configureLogging();
  }
  async saveSettings() {
    this.validateSettings();
    await this.saveData(this.settings);
    this.configureLogging();
  }
  /**
   * Configures logging based on settings.
   * Per plugin guidelines: minimize console logging in production.
   */
  configureLogging() {
    const debugEnabled = this.settings.enableDebugLogging;
    PerfTimer.setEnabled(debugEnabled);
    COORDINATE_DEBUG = debugEnabled;
    setCoordinateDebug(debugEnabled);
    Logger.setLevel(debugEnabled ? 4 /* DEBUG */ : 1 /* ERROR */);
  }
  /**
   * Validates settings values are within acceptable ranges.
   * Clamps or resets invalid values to defaults.
   */
  validateSettings() {
    if (typeof this.settings.proxyPreviewScale !== "number" || isNaN(this.settings.proxyPreviewScale)) {
      this.settings.proxyPreviewScale = DEFAULT_SETTINGS.proxyPreviewScale;
    } else {
      this.settings.proxyPreviewScale = Math.max(0.1, Math.min(1, this.settings.proxyPreviewScale));
    }
    if (typeof this.settings.focusTintDuration !== "number" || isNaN(this.settings.focusTintDuration)) {
      this.settings.focusTintDuration = DEFAULT_SETTINGS.focusTintDuration;
    } else {
      this.settings.focusTintDuration = Math.max(0, Math.min(60, this.settings.focusTintDuration));
    }
    if (typeof this.settings.maxArrangementsPerNote !== "number" || isNaN(this.settings.maxArrangementsPerNote)) {
      this.settings.maxArrangementsPerNote = DEFAULT_SETTINGS.maxArrangementsPerNote;
    } else {
      this.settings.maxArrangementsPerNote = Math.max(1, Math.min(50, Math.floor(this.settings.maxArrangementsPerNote)));
    }
    if (this.settings.storageMode !== "frontmatter" && this.settings.storageMode !== "external") {
      this.settings.storageMode = DEFAULT_SETTINGS.storageMode;
    }
  }
};
/**
 * Perspecta Plugin - Main Entry Point
 *
 * A context-switching plugin for Obsidian that saves and restores window arrangements,
 * allowing users to quickly switch between different workspace configurations.
 *
 * @module main
 *
 * ## Architecture
 *
 * The plugin is organized into several modules:
 *
 * - **main.ts** (this file): Plugin entry point, commands, settings
 * - **types/**: Type definitions including internal Obsidian API types
 * - **utils/**: Utility functions (coordinates, wallpaper, file resolution, UID management)
 * - **storage/**: Context storage backends (markdown, canvas, base, external)
 * - **services/**: Window capture and restore services
 * - **ui/**: UI components (modals, proxy view)
 *
 * ## Obsidian API Usage
 *
 * ### Public APIs
 * - `Plugin` base class for plugin lifecycle
 * - `App.workspace` for workspace manipulation
 * - `App.vault` for file operations
 * - `App.metadataCache` for frontmatter access
 *
 * ### Internal APIs (undocumented)
 * These are used for advanced window management features.
 * All usage includes fallbacks for API changes.
 *
 * - `workspace.rootSplit` - Main window workspace root
 * - `workspace.floatingSplit` - Popout windows container
 * - `workspace.leftSplit` / `rightSplit` - Sidebars
 * - `WorkspaceLeaf.parent` - Parent container access
 * - `WorkspaceTabContainer.currentTab` - Active tab index
 * - `WorkspaceTabContainer.dimension` - Split size
 *
 * @see types/obsidian-internal.ts for type definitions
 * @see https://docs.obsidian.md/Plugins for official API docs
 *
 * ## Security Considerations
 *
 * - Path validation in file resolution prevents directory traversal
 * - Wallpaper operations use whitelisted commands only
 * - No arbitrary shell command execution
 * - Input validation on all user-provided data
 *
 * @author Perspecta Contributors
 * @license MIT
 */
